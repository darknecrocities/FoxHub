{
  "tU4Umtnfu01t9gLlnlK6b": {
    "title": "Pick a Language",
    "description": "You need to pick a programming language to learn the Computer Science concepts. My personal recommendation would be to pick C++ or C and the reason for that is:\n\n*   They allow you to deal with pointers and memory allocation/deallocation, so you feel the data structures and algorithms in your bones. In higher level languages like Python or Java, these are hidden from you. In day to day work, that's terrific, but when you're learning how these low-level data structures are built, it's great to feel close to the metal.\n*   You will be able to find a lot of resources for the topics listed in this roadmap using C or C++. You can find a lot of resources for Python and Java, but they are not as abundant as C++ and C.\n\nGiven below is the list of resources; pick ones relevant to the language of your choice.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Visit Dedicated C++ Roadmap",
        "url": "https://roadmap.sh/cpp",
        "type": "article"
      },
      {
        "title": "Learn C++ - Tutorials Point",
        "url": "https://www.tutorialspoint.com/cplusplus/index.htm",
        "type": "article"
      },
      {
        "title": "Learn C - Tutorials Point",
        "url": "https://www.tutorialspoint.com/cprogramming/index.htm",
        "type": "article"
      },
      {
        "title": "C++ Programming Course - Beginner to Advanced",
        "url": "https://www.youtube.com/watch?v=8jLOx1hD3_o",
        "type": "video"
      },
      {
        "title": "C++ Tutorial for Beginners - Full Course",
        "url": "https://www.youtube.com/watch?v=vLnPwxZdW4Y",
        "type": "video"
      },
      {
        "title": "C Programming Tutorial for Beginners",
        "url": "https://www.youtube.com/watch?v=KJgsSFOSQv0",
        "type": "video"
      },
      {
        "title": "Learn C Programming with Dr. Chuck",
        "url": "https://www.youtube.com/watch?v=j-_s8f5K30I",
        "type": "video"
      }
    ]
  },
  "RlKZzs44biQPgxD0tK1qx": {
    "title": "Python",
    "description": "Python is a well known programming language which is both a strongly typed and a dynamically typed language. Being an interpreted language, code is executed as soon as it is written and the Python syntax allows for writing code in functional, procedural or object-oriented programmatic ways.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Visit Dedicated Python Roadmap",
        "url": "https://roadmap.sh/python",
        "type": "article"
      },
      {
        "title": "Python",
        "url": "https://www.python.org/",
        "type": "article"
      },
      {
        "title": "Getting Started with Python",
        "url": "https://www.python.org/about/gettingstarted/",
        "type": "article"
      },
      {
        "title": "Automate the Boring Stuff",
        "url": "https://automatetheboringstuff.com/",
        "type": "article"
      },
      {
        "title": "Python principles - Python basics",
        "url": "https://pythonprinciples.com/",
        "type": "article"
      },
      {
        "title": "Python Crash Course",
        "url": "https://ehmatthes.github.io/pcc/",
        "type": "article"
      },
      {
        "title": "An Introduction to Python for Non-Programmers",
        "url": "https://thenewstack.io/an-introduction-to-python-for-non-programmers/",
        "type": "article"
      },
      {
        "title": "Getting Started with Python and InfluxDB",
        "url": "https://thenewstack.io/getting-started-with-python-and-influxdb/",
        "type": "article"
      },
      {
        "title": "Explore top posts about Python",
        "url": "https://app.daily.dev/tags/python?ref=roadmapsh",
        "type": "article"
      }
    ]
  },
  "mWW88VnkqWgDz02qw5zU-": {
    "title": "Go",
    "description": "Go is an open source programming language supported by Google. Go can be used to write cloud services, CLI tools, used for API development, and much more.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Visit Dedicated Go Roadmap",
        "url": "https://roadmap.sh/golang",
        "type": "article"
      },
      {
        "title": "A Tour of Go – Go Basics",
        "url": "https://go.dev/tour/welcome/1",
        "type": "article"
      },
      {
        "title": "Go Reference Documentation",
        "url": "https://go.dev/doc/",
        "type": "article"
      },
      {
        "title": "Go by Example - annotated example programs",
        "url": "https://gobyexample.com/",
        "type": "article"
      },
      {
        "title": "Making a RESTful JSON API in Go",
        "url": "https://thenewstack.io/make-a-restful-json-api-go/",
        "type": "article"
      },
      {
        "title": "Go, the Programming Language of the Cloud",
        "url": "https://thenewstack.io/go-the-programming-language-of-the-cloud/",
        "type": "article"
      },
      {
        "title": "Explore top posts about Golang",
        "url": "https://app.daily.dev/tags/golang?ref=roadmapsh",
        "type": "article"
      }
    ]
  },
  "jHKCLfLml8oZyj4829gx0": {
    "title": "C#",
    "description": "C# (pronounced \"C sharp\") is a general purpose programming language made by Microsoft. It is used to perform different tasks and can be used to create web apps, games, mobile apps, etc.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "C# Learning Path",
        "url": "https://docs.microsoft.com/en-us/learn/paths/csharp-first-steps/?WT.mc_id=dotnet-35129-website",
        "type": "article"
      },
      {
        "title": "Introduction to C#",
        "url": "https://docs.microsoft.com/en-us/shows/CSharp-101/?WT.mc_id=Educationalcsharp-c9-scottha",
        "type": "article"
      },
      {
        "title": "Explore top posts about C# Programming",
        "url": "https://app.daily.dev/tags/csharp?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "C# tutorials",
        "url": "https://www.youtube.com/watch?v=gfkTfcpWqAY&list=PLTjRvDozrdlz3_FPXwb6lX_HoGXa09Yef",
        "type": "video"
      }
    ]
  },
  "1bDjg-KBDKRmE6f1MWY8l": {
    "title": "Rust",
    "description": "Rust is a modern systems programming language focusing on safety, speed, and concurrency. It accomplishes these goals by being memory safe without using garbage collection.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Visit Dedicated Rust Roadmap",
        "url": "https://roadmap.sh/rust",
        "type": "article"
      },
      {
        "title": "The Rust Programming Language - online book",
        "url": "https://doc.rust-lang.org/book/",
        "type": "article"
      },
      {
        "title": "Rust by Example - collection of runnable examples",
        "url": "https://doc.rust-lang.org/stable/rust-by-example/index.html",
        "type": "article"
      },
      {
        "title": "Rust vs. Go: Why They’re Better Together",
        "url": "https://thenewstack.io/rust-vs-go-why-theyre-better-together/",
        "type": "article"
      },
      {
        "title": "Rust by the Numbers: The Rust Programming Language in 2021",
        "url": "https://thenewstack.io/rust-by-the-numbers-the-rust-programming-language-in-2021/",
        "type": "article"
      },
      {
        "title": "Explore top posts about Rust",
        "url": "https://app.daily.dev/tags/rust?ref=roadmapsh",
        "type": "article"
      }
    ]
  },
  "1kQJs-3Aw8Bi7d_Xh67zS": {
    "title": "C++",
    "description": "C++ is a powerful general-purpose programming language. It can be used to develop operating systems, browsers, games, and so on. C++ supports different ways of programming like procedural, object-oriented, functional, and so on. This makes C++ powerful as well as flexible.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Visit Dedicated C++ Roadmap",
        "url": "https://roadmap.sh/cpp",
        "type": "article"
      },
      {
        "title": "Learn C++",
        "url": "https://learncpp.com/",
        "type": "article"
      },
      {
        "title": "Cpp Reference",
        "url": "https://en.cppreference.com/",
        "type": "article"
      },
      {
        "title": "CPlusPlus",
        "url": "https://cplusplus.com/",
        "type": "article"
      },
      {
        "title": "C++ TutorialsPoint",
        "url": "https://www.tutorialspoint.com/cplusplus/index.htm",
        "type": "article"
      },
      {
        "title": "Explore top posts about C++ Programming",
        "url": "https://app.daily.dev/tags/c++?ref=roadmapsh",
        "type": "article"
      }
    ]
  },
  "n4IsklfYJXFIyF1rGWuEa": {
    "title": "C",
    "description": "C is a general-purpose computer programming language. It was created in the 1970s by Dennis Ritchie, and remains very widely used and influential. By design, C's features cleanly reflect the capabilities of the targeted CPUs.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Learn C - Tutorials Point",
        "url": "https://www.tutorialspoint.com/cprogramming/index.htm",
        "type": "article"
      },
      {
        "title": "Explore top posts about C Programming",
        "url": "https://app.daily.dev/tags/c?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "C Programming Tutorial for Beginners",
        "url": "https://www.youtube.com/watch?v=KJgsSFOSQv0",
        "type": "video"
      },
      {
        "title": "Learn C Programming with Dr. Chuck",
        "url": "https://www.youtube.com/watch?v=j-_s8f5K30I",
        "type": "video"
      },
      {
        "title": "C Programming Full Course (Bro Code)",
        "url": "https://youtu.be/87SH2Cn0s9A",
        "type": "video"
      }
    ]
  },
  "1lQSUFrrIGq19nUnM92-I": {
    "title": "Java",
    "description": "Java is general-purpose language, primarily used for Internet-based applications. It was created in 1995 by James Gosling at Sun Microsystems and is one of the most popular options for backend developers.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Visit Dedicated Java Roadmap",
        "url": "https://roadmap.sh/java",
        "type": "article"
      },
      {
        "title": "Java",
        "url": "https://www.java.com/",
        "type": "article"
      },
      {
        "title": "Explore top posts about Java",
        "url": "https://app.daily.dev/tags/java?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Java Crash Course",
        "url": "https://www.youtube.com/watch?v=eIrMbAQSU34",
        "type": "video"
      }
    ]
  },
  "NM7q5REW1sJgMhxJhPpLT": {
    "title": "Data Structures",
    "description": "As the name indicates itself, a **Data Structure** is a way of organizing the data in the **memory** so that it can be used efficiently. Some common data structures are array, linked list, stack, hashtable, queue, tree, heap, and graph.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Data Structures and Algorithms By Google",
        "url": "https://techdevguide.withgoogle.com/paths/data-structures-and-algorithms/",
        "type": "course"
      },
      {
        "title": "Visit Dedicated DSA Roadmap",
        "url": "https://roadmap.sh/datastructures-and-algorithms",
        "type": "article"
      },
      {
        "title": "Explore top posts about Data Structures",
        "url": "https://app.daily.dev/tags/data-structures?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Data Structures Illustrated",
        "url": "https://www.youtube.com/watch?v=9rhT3P1MDHk&list=PLkZYeFmDuaN2-KUIv-mvbjfKszIGJ4FaY",
        "type": "video"
      },
      {
        "title": "Data Structures playlist",
        "url": "https://youtube.com/playlist?list=PLDV1Zeh2NRsB6SWUrDFW2RmDotAfPbeHu&si=_EEf7x58G6lUcMGG",
        "type": "video"
      }
    ]
  },
  "gr8BK6vq4AVwp_aUozZmf": {
    "title": "Linked List",
    "description": "Arrays store elements in contiguous memory locations, resulting in easily calculable addresses for the elements stored and this allows faster access to an element at a specific index. Linked lists are less rigid in their storage structure and elements are usually not stored in contiguous locations, hence they need to be stored with additional tags giving a reference to the next element. This difference in the data storage scheme decides which data structure would be more suitable for a given situation.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Singly Linked Lists",
        "url": "https://www.coursera.org/lecture/data-structures/singly-linked-lists-kHhgK",
        "type": "course"
      },
      {
        "title": "Core: Linked Lists vs Arrays",
        "url": "https://www.coursera.org/lecture/data-structures-optimizing-performance/core-linked-lists-vs-arrays-rjBs9",
        "type": "course"
      },
      {
        "title": "In the Real World: Linked Lists vs Arrays",
        "url": "https://www.coursera.org/lecture/data-structures-optimizing-performance/in-the-real-world-lists-vs-arrays-QUaUd",
        "type": "course"
      },
      {
        "title": "Doubly Linked Lists",
        "url": "https://www.coursera.org/lecture/data-structures/doubly-linked-lists-jpGKD",
        "type": "course"
      },
      {
        "title": "Linked List Data Structure | Illustrated Data Structures",
        "url": "https://www.youtube.com/watch?v=odW9FU8jPRQ",
        "type": "video"
      },
      {
        "title": "Linked Lists in 4 minutes",
        "url": "https://www.youtube.com/watch?v=F8AbOfQwl1c",
        "type": "video"
      },
      {
        "title": "CS 61B Lecture 7: Linked Lists I",
        "url": "https://archive.org/details/ucberkeley_webcast_htzJdKoEmO0",
        "type": "video"
      },
      {
        "title": "CS 61B Lecture 7: Linked Lists II",
        "url": "https://archive.org/details/ucberkeley_webcast_-c4I3gFYe3w",
        "type": "video"
      },
      {
        "title": "Why you should avoid Linked Lists?",
        "url": "https://www.youtube.com/watch?v=YQs6IC-vgmo",
        "type": "video"
      }
    ]
  },
  "hJB5gO9tosRlC4UmdSNzl": {
    "title": "Stack",
    "description": "Stack is a linear collection of items where items are inserted and removed in a particular order. Stack is also called a LIFO Data Structure because it follows the \"Last In First Out\" principle i.e. the item that is inserted in the last is the one that is taken out first.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Stack Data Structure",
        "url": "https://www.coursera.org/lecture/data-structures/stacks-UdKzQ",
        "type": "course"
      },
      {
        "title": "Stack Data Structure | Illustrated Data Structures",
        "url": "https://www.youtube.com/watch?v=I5lq6sCuABE",
        "type": "video"
      },
      {
        "title": "Stack in 3 minutes",
        "url": "https://www.youtube.com/watch?v=KcT3aVgrrpU",
        "type": "video"
      }
    ]
  },
  "JI990pDX2jjNe6IH_Y_t0": {
    "title": "Queue",
    "description": "Queue is a linear collection of items where items are inserted and removed in a particular order. The queue is also called a FIFO Data Structure because it follows the \"First In, First Out\" principle i.e., the item that is inserted in the first is the one that is taken out first.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Queues - Coursera",
        "url": "https://www.coursera.org/lecture/data-structures/queues-EShpq",
        "type": "course"
      },
      {
        "title": "Circular Buffer - Wikipedia",
        "url": "https://en.wikipedia.org/wiki/Circular_buffer",
        "type": "article"
      },
      {
        "title": "Queue Data Structure | Illustrated Data Structures",
        "url": "https://www.youtube.com/watch?v=mDCi1lXd9hc",
        "type": "video"
      },
      {
        "title": "Queue in 3 Minutes",
        "url": "https://www.youtube.com/watch?v=D6gu-_tmEpQ",
        "type": "video"
      }
    ]
  },
  "G2dN2FO0SN_I-5AhO_EUk": {
    "title": "Hash Table",
    "description": "Hash Table, Map, HashMap, Dictionary or Associative are all the names of the same data structure. It is one of the most commonly used data structures.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Hash Tables - Princeton University",
        "url": "https://algs4.cs.princeton.edu/34hash/",
        "type": "article"
      },
      {
        "title": "Hash Table | Illustrated Data Structures",
        "url": "https://www.youtube.com/watch?v=jalSiaIi8j4",
        "type": "video"
      },
      {
        "title": "Hash Table in 4 Minutes",
        "url": "https://youtu.be/knV86FlSXJ8",
        "type": "video"
      },
      {
        "title": "Hashing with Chaining",
        "url": "https://www.youtube.com/watch?v=0M_kIqhwbFo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=9",
        "type": "video"
      },
      {
        "title": "(Advanced) Randomization: Universal & Perfect Hashing",
        "url": "https://www.youtube.com/watch?v=z0lJ2k0sl1g&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=11",
        "type": "video"
      },
      {
        "title": "(Advanced) Perfect hashing",
        "url": "https://www.youtube.com/watch?v=N0COwN14gt0&list=PL2B4EEwhKD-NbwZ4ezj7gyc_3yNrojKM9&index=4",
        "type": "video"
      }
    ]
  },
  "TwW6SO2IXqkxJXVjLzdwU": {
    "title": "Array",
    "description": "Arrays store elements in contiguous memory locations, resulting in easily calculable addresses for the elements stored and this allows faster access to an element at a specific index.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Array Data Structure - Coursera",
        "url": "https://www.coursera.org/lecture/data-structures/arrays-OsBSF",
        "type": "course"
      },
      {
        "title": "What is Array in Data Structure? Types & Syntax",
        "url": "https://www.simplilearn.com/tutorials/data-structure-tutorial/arrays-in-data-structure",
        "type": "article"
      },
      {
        "title": "Array Data Structure | Illustrated Data Structures",
        "url": "https://www.youtube.com/watch?v=QJNwK2uJyGs",
        "type": "video"
      },
      {
        "title": "Jagged Arrays",
        "url": "https://www.youtube.com/watch?v=1jtrQqYpt7g",
        "type": "video"
      },
      {
        "title": "Dynamic and Static Arrays",
        "url": "https://www.youtube.com/watch?v=PEnFFiQe1pM&list=PLDV1Zeh2NRsB6SWUrDFW2RmDotAfPbeHu&index=6",
        "type": "video"
      },
      {
        "title": "Dynamic Array Code",
        "url": "https://www.youtube.com/watch?v=tvw4v7FEF1w&list=PLDV1Zeh2NRsB6SWUrDFW2RmDotAfPbeHu&index=5",
        "type": "video"
      },
      {
        "title": "UC Berkeley CS61B - Linear and Multi-Dim Arrays (Start watching from 15m 32s)",
        "url": "https://archive.org/details/ucberkeley_webcast_Wp8oiO_CZZE",
        "type": "video"
      }
    ]
  },
  "_eWqiWUmOj0zUo_Ix3j1O": {
    "title": "Tree",
    "description": "A tree is non-linear and a hierarchical data structure consisting of a collection of nodes such that each node of the tree stores a value and a list of references to other nodes (the “children”).\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Tree Data Structure",
        "url": "https://www.programiz.com/dsa/trees",
        "type": "article"
      },
      {
        "title": "Tree | Illustrated Data Structures",
        "url": "https://www.youtube.com/watch?v=S2W3SXGPVyU",
        "type": "video"
      }
    ]
  },
  "G9dnegZ6zNvxrCZ3O_b_z": {
    "title": "Binary Tree",
    "description": "A binary tree is a tree data structure in which each node has at most two children, which are referred to as the left child and the right child.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Explore top posts about Binary Tree",
        "url": "https://app.daily.dev/tags/binary-tree?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Binary Trees - Part 1",
        "url": "https://www.youtube.com/watch?v=76dhtgZt38A&list=PLUl4u3cNGP63EdVPNLG3ToM6LaEUuStEY&index=9",
        "type": "video"
      },
      {
        "title": "Binary Trees - Part 2",
        "url": "https://www.youtube.com/watch?v=U1JYwHcFfso&list=PLUl4u3cNGP63EdVPNLG3ToM6LaEUuStEY&index=10",
        "type": "video"
      }
    ]
  },
  "et7l85gnxjvzD2tDyHT_T": {
    "title": "Binary Search Tree",
    "description": "A binary search tree, also called an ordered or sorted binary tree, is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node's left subtree and less than the ones in its right subtree.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Binary Search Trees - Coursera",
        "url": "https://www.coursera.org/learn/data-structures/lecture/E7cXP/introduction",
        "type": "course"
      },
      {
        "title": "Explore top posts about General Programming",
        "url": "https://app.daily.dev/tags/general-programming?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Tree | Illustrated Data Structures",
        "url": "https://www.youtube.com/watch?v=S2W3SXGPVyU",
        "type": "video"
      },
      {
        "title": "Binary Search Trees - MIT",
        "url": "https://www.youtube.com/watch?v=76dhtgZt38A",
        "type": "video"
      },
      {
        "title": "Binary Search Tree Implementation in C++",
        "url": "https://www.youtube.com/watch?v=COZK7NATh4k&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=29",
        "type": "video"
      },
      {
        "title": "BST implementation - memory allocation in stack and heap",
        "url": "https://www.youtube.com/watch?v=hWokyBoo0aI&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=30",
        "type": "video"
      },
      {
        "title": "Find Min and Max Element in Binary Search Tree",
        "url": "https://www.youtube.com/watch?v=Ut90klNN264&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=31",
        "type": "video"
      },
      {
        "title": "Check if Given Tree is Binary Search Tree or Not",
        "url": "https://www.youtube.com/watch?v=yEwSGhSsT0U&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=36",
        "type": "video"
      },
      {
        "title": "Delete an Element from Binary Search Tree",
        "url": "https://www.youtube.com/watch?v=gcULXE7ViZw&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=37",
        "type": "video"
      },
      {
        "title": "Inorder Successor in a binary search tree",
        "url": "https://www.youtube.com/watch?v=5cPbNCrdotA&list=PL2_aWCzGMAwI3W_JlcBbtYTwiQSsOTa6P&index=38",
        "type": "video"
      }
    ]
  },
  "Q8ZJNeTbc22Q08Mra-McY": {
    "title": "Full Binary Tree",
    "description": "A full Binary tree is a special type of binary tree in which every parent node/internal node has either two or no children. It is also known as a proper binary tree.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Full Binary Tree",
        "url": "https://www.programiz.com/dsa/full-binary-tree",
        "type": "article"
      }
    ]
  },
  "Jx1WWCjm8jkfAGtHv15n1": {
    "title": "Complete Binary Tree",
    "description": "A complete binary tree is a special type of binary tree where all the levels of the tree are filled completely except the lowest level nodes which are filled from as left as possible.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Complete Binary Tree - Programiz",
        "url": "https://www.programiz.com/dsa/complete-binary-tree",
        "type": "article"
      },
      {
        "title": "Complete Binary Trees",
        "url": "https://www.wscubetech.com/resources/dsa/complete-binary-tree",
        "type": "article"
      }
    ]
  },
  "ZaWGLvZyu4sIPn-zwVISN": {
    "title": " Balanced Tree",
    "description": "A balanced binary tree, also referred to as a height-balanced binary tree, is defined as a binary tree in which the height of the left and right subtree of any node differ by not more than 1.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Balanced Binary Tree",
        "url": "https://www.programiz.com/dsa/balanced-binary-tree",
        "type": "article"
      }
    ]
  },
  "w4sxmZR1BjX6wlrZmuOlf": {
    "title": "Unbalanced Tree",
    "description": "An unbalanced binary tree is one that is not balanced.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Balanced vs Unbalanced Binary Tree",
        "url": "https://stackoverflow.com/questions/59206128/balanced-vs-unbalanced-binary-tree-clarification-needed",
        "type": "article"
      },
      {
        "title": "Unbalanced Binary Tree",
        "url": "https://eng.libretexts.org/Bookshelves/Computer_Science/Databases_and_Data_Structures/Open_Data_Structures_-_An_Introduction_(Morin)/06%3A_Binary_Trees/6.02%3A_BinarySearchTree_-_An_Unbalanced_Binary_Search_Treee",
        "type": "article"
      }
    ]
  },
  "vQm046o6ozcvLoqg9L6eL": {
    "title": "Graph",
    "description": "Graphs in data structures are non-linear data structures made up of a finite number of nodes or vertices and the edges that connect them. Graphs in data structures are used to address real-world problems in which it represents the problem area as a network like telephone networks, circuit networks, and social networks.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Graph Data Structure",
        "url": "https://www.simplilearn.com/tutorials/data-structure-tutorial/graphs-in-data-structure",
        "type": "article"
      },
      {
        "title": "Graph Data Structure | Illustrated Data Structures",
        "url": "https://www.youtube.com/watch?v=0sQE8zKhad0",
        "type": "video"
      },
      {
        "title": "CSE373 2020 - Lecture 10 - Graph Data Structures",
        "url": "https://www.youtube.com/watch?v=Sjk0xqWWPCc&list=PLOtl7M3yp-DX6ic0HGT0PUX_wiNmkWkXx&index=10",
        "type": "video"
      },
      {
        "title": "CSE373 2020 - Lecture 11 - Graph Traversal",
        "url": "https://www.youtube.com/watch?v=ZTwjXj81NVY&list=PLOtl7M3yp-DX6ic0HGT0PUX_wiNmkWkXx&index=11",
        "type": "video"
      },
      {
        "title": "CSE373 2020 - Lecture 12 - Depth First Search",
        "url": "https://www.youtube.com/watch?v=KyordYB3BOs&list=PLOtl7M3yp-DX6ic0HGT0PUX_wiNmkWkXx&index=12",
        "type": "video"
      },
      {
        "title": "CSE373 2020 - Lecture 13 - Minimum Spanning Trees",
        "url": "https://www.youtube.com/watch?v=oolm2VnJUKw&list=PLOtl7M3yp-DX6ic0HGT0PUX_wiNmkWkXx&index=13",
        "type": "video"
      },
      {
        "title": "CSE373 2020 - Lecture 14 - Minimum Spanning Trees (cont)",
        "url": "https://www.youtube.com/watch?v=RktgPx0MarY&list=PLOtl7M3yp-DX6ic0HGT0PUX_wiNmkWkXx&index=14",
        "type": "video"
      },
      {
        "title": "CSE373 2020 - Lecture 15 - Graph Algorithms (cont 2)",
        "url": "https://www.youtube.com/watch?v=MUe5DXRhyAo&list=PLOtl7M3yp-DX6ic0HGT0PUX_wiNmkWkXx&index=15",
        "type": "video"
      },
      {
        "title": "6.006 Single-Source Shortest Paths Problem",
        "url": "https://www.youtube.com/watch?v=Aa2sqUhIn-E&index=15&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb",
        "type": "video"
      }
    ]
  },
  "6Jy8SXHuYA08h9iLjKFWR": {
    "title": "Directed Graph",
    "description": "A directed graph is graph, i.e., a set of objects (called vertices or nodes) that are connected together, where all the edges are directed from one vertex to another. A directed graph is sometimes called a digraph or a directed network. In contrast, a graph where the edges are bidirectional is called an undirected graph.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Directed Graph",
        "url": "https://en.wikipedia.org/wiki/Directed_graph",
        "type": "article"
      }
    ]
  },
  "QGx8it2N_85PiPVjpTGK_": {
    "title": "Undirected Graph",
    "description": "An undirected graph is graph, i.e., a set of objects (called vertices or nodes) that are connected together, where all the edges are bidirectional. An undirected graph is sometimes called an undirected network. In contrast, a graph where the edges point in a direction is called a directed graph.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Undirected Graph",
        "url": "https://mathinsight.org/definition/undirected_graph",
        "type": "article"
      }
    ]
  },
  "L4xtWOdqGUf4SbJkoOsNM": {
    "title": "Spanning Tree",
    "description": "A spanning tree is a subset of Graph G, which has all the vertices covered with minimum possible number of edges. Hence, a spanning tree does not have cycles and it cannot be disconnected..\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Spanning Tree",
        "url": "https://www.tutorialspoint.com/data_structures_algorithms/spanning_tree.htm",
        "type": "article"
      },
      {
        "title": "CSE373 2020 - Lecture 13 - Minimum Spanning Trees",
        "url": "https://www.youtube.com/watch?v=oolm2VnJUKw&list=PLOtl7M3yp-DX6ic0HGT0PUX_wiNmkWkXx&index=13",
        "type": "video"
      },
      {
        "title": "CSE373 2020 - Lecture 14 - Minimum Spanning Trees (cont)",
        "url": "https://www.youtube.com/watch?v=RktgPx0MarY&list=PLOtl7M3yp-DX6ic0HGT0PUX_wiNmkWkXx&index=14",
        "type": "video"
      },
      {
        "title": "Greedy Algorithms: Minimum Spanning Tree",
        "url": "https://www.youtube.com/watch?v=tKwnms5iRBU&index=16&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp",
        "type": "video"
      }
    ]
  },
  "HZ1kk0TQ13FLC9t13BZl5": {
    "title": "Adjacency Matrix",
    "description": "An adjacency matrix is a square matrix used to represent a finite graph. It is used to represent the connections between vertices in a graph. The matrix is filled with 0s and 1s, where a 1 represents a connection between two vertices and a 0 represents no connection.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Adjacency Matrix",
        "url": "https://en.wikipedia.org/wiki/Adjacency_matrix",
        "type": "article"
      }
    ]
  },
  "rTnKJcPniUtqvfOyC88N0": {
    "title": "Adjacency List",
    "description": "A graph can either be represented as an adjacency matrix or an adjacency list.\n\nThe adjacency matrix is a 2D array of size `V x V` where `V` is the number of vertices in a graph. Let the 2D array be `adj[][]`, a slot `adj[i][j] = 1` indicates that there is an edge from vertex `i` to vertex `j`.\n\nAdjacency list is an array of vectors. Size of the array is equal to the number of vertices. Let the array be `array[]`. An entry `array[i]` represents the list of vertices adjacent to the ith vertex. This representation can also be used to represent a weighted graph. The weights of edges can be represented as lists of pairs.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Adjacency Matrix - Graph Representation",
        "url": "https://www.programiz.com/dsa/graph-adjacency-matrix",
        "type": "article"
      },
      {
        "title": "Adjacency List - Graph Representation",
        "url": "https://www.programiz.com/dsa/graph-adjacency-list",
        "type": "article"
      }
    ]
  },
  "pw3ZCC3HKU7D5SQwte4vE": {
    "title": "Heap",
    "description": "Heap is a tree-based data structure that follows the properties of a complete binary tree and is either a Min Heap or a Max Heap.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Priority Queue - Introduction",
        "url": "https://www.coursera.org/lecture/data-structures/introduction-2OpTs",
        "type": "course"
      },
      {
        "title": "Heap Data Structure",
        "url": "https://www.programiz.com/dsa/heap-data-structure",
        "type": "article"
      },
      {
        "title": "CS 61B Lecture 24: Priority Queues",
        "url": "https://archive.org/details/ucberkeley_webcast_yIUFT6AKBGE",
        "type": "article"
      },
      {
        "title": "Heap | Illustrated Data Structures",
        "url": "https://www.youtube.com/watch?v=F_r0sJ1RqWk",
        "type": "video"
      },
      {
        "title": "Heaps and Heap Sort",
        "url": "https://www.youtube.com/watch?v=B7hVxCmfPtM&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=5",
        "type": "video"
      }
    ]
  },
  "UpBrpmrUwYUB9eesNxCq5": {
    "title": "Asymptotic Notation",
    "description": "The efficiency of an algorithm depends on the amount of time, storage and other resources required to execute the algorithm. The efficiency is measured with the help of asymptotic notations.\n\nAn algorithm may not have the same performance for different types of inputs. With the increase in the input size, the performance will change.\n\nThe study of change in performance of the algorithm with the change in the order of the input size is defined as asymptotic analysis.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Asymptotic Analysis: Big-O Notation and More",
        "url": "https://www.programiz.com/dsa/asymptotic-notations",
        "type": "article"
      },
      {
        "title": "Big-O Cheat Sheet",
        "url": "https://www.bigocheatsheet.com/",
        "type": "article"
      },
      {
        "title": "Big O Notation | Brilliant Math & Science Wiki",
        "url": "https://brilliant.org/wiki/big-o-notation/",
        "type": "article"
      },
      {
        "title": "Big O Notation — Calculating Time Complexity",
        "url": "https://www.youtube.com/watch?v=Z0bH0cMY0E8",
        "type": "video"
      },
      {
        "title": "Big O Notation in 5 Minutes",
        "url": "https://www.youtube.com/watch?v=__vX2sjlpXU",
        "type": "video"
      },
      {
        "title": "Asymptotic Notation - CS50",
        "url": "https://www.youtube.com/watch?v=iOq5kSKqeR4",
        "type": "video"
      },
      {
        "title": "CS 61B Lecture 19: Asymptotic Analysis",
        "url": "https://archive.org/details/ucberkeley_webcast_VIS4YDpuP98",
        "type": "video"
      }
    ]
  },
  "c-NrTtJuNihbHzyPEOKTW": {
    "title": "Big O",
    "description": "The Big O notation can be used to describe how the running time of an algorithm scales with the growth of the input size, ignoring implementation details such as programming language and computer speed. Specifically, it denotes the upper bound of the growth rate of a function that relates the running time of an algorithm to its input size. It can be used to compare algorithms and determine which one is better.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Big-O Notation: A Simple Explanation with Examples",
        "url": "https://medium.com/better-programming/big-o-notation-a-simple-explanation-with-examples-a56347d1daca",
        "type": "article"
      },
      {
        "title": "CS 61B Lecture 19: Asymptotic Analysis",
        "url": "https://archive.org/details/ucberkeley_webcast_VIS4YDpuP98",
        "type": "article"
      },
      {
        "title": "Big O Notation | Brilliant Math & Science Wiki",
        "url": "https://brilliant.org/wiki/big-o-notation/",
        "type": "article"
      },
      {
        "title": "Big O Notation — Calculating Time Complexity",
        "url": "https://www.youtube.com/watch?v=Z0bH0cMY0E8",
        "type": "video"
      },
      {
        "title": "Big O Notations",
        "url": "https://www.youtube.com/watch?v=V6mKVRU1evU",
        "type": "video"
      },
      {
        "title": "Big Oh Notation (and Omega and Theta)",
        "url": "https://www.youtube.com/watch?v=ei-A_wy5Yxw&list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN&index=3",
        "type": "video"
      }
    ]
  },
  "ThLpVZQIJ4diY5m0dik8m": {
    "title": "Big-Theta",
    "description": "If a function has the same Big O and Big Omega, they also become the function's Big Theta. Big Theta is used to describe the exact growth rate of a function. It is denoted by the symbol Θ.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Big O Notation | Brilliant Math & Science Wiki",
        "url": "https://brilliant.org/wiki/big-o-notation/",
        "type": "article"
      },
      {
        "title": "Big Oh Notation (and Omega and Theta)",
        "url": "https://www.youtube.com/watch?v=ei-A_wy5Yxw&list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN&index=3",
        "type": "video"
      },
      {
        "title": "Asymptotic Notation - CS50",
        "url": "https://www.youtube.com/watch?v=iOq5kSKqeR4",
        "type": "video"
      }
    ]
  },
  "X33735aeAVSlJ6yv9GS-h": {
    "title": "Big Omega",
    "description": "The Big Omega notation is similar to the Big O notation. The only difference is that it denotes the lower bound on the growth rate of a function.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Big O Notation | Brilliant Math & Science Wiki",
        "url": "https://brilliant.org/wiki/big-o-notation/",
        "type": "article"
      },
      {
        "title": "Big Oh Notation (and Omega and Theta)",
        "url": "https://www.youtube.com/watch?v=ei-A_wy5Yxw&list=PL1BaGV1cIH4UhkL8a9bJGG356covJ76qN&index=3",
        "type": "video"
      },
      {
        "title": "Asymptotic Notation - CS50",
        "url": "https://www.youtube.com/watch?v=iOq5kSKqeR4",
        "type": "video"
      }
    ]
  },
  "3F_QBv_sU39ehOxpurF88": {
    "title": "Constant",
    "description": "Constant time algorithms are the simplest and most efficient algorithms. They are algorithms that always take the same amount of time to run, regardless of the size of the input. This is the best case scenario for an algorithm, and is the goal of all algorithms.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Big O Notation — Calculating Time Complexity",
        "url": "https://www.youtube.com/watch?v=Z0bH0cMY0E8",
        "type": "video"
      },
      {
        "title": "Big O Notations",
        "url": "https://www.youtube.com/watch?v=V6mKVRU1evU",
        "type": "video"
      }
    ]
  },
  "nnlMNkQn1HU4U9yPbV9kQ": {
    "title": "Logarithmic",
    "description": "Logarithmic complexity algorithms are the second fastest algorithms. They are faster than linear algorithms, but slower than constant algorithms.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Big O Notation — Calculating Time Complexity",
        "url": "https://www.youtube.com/watch?v=Z0bH0cMY0E8",
        "type": "video"
      },
      {
        "title": "Big O Notations",
        "url": "https://www.youtube.com/watch?v=V6mKVRU1evU",
        "type": "video"
      }
    ]
  },
  "jymhjv8GiFALQpox6aZeu": {
    "title": "Linear",
    "description": "Linear algorithms are algorithms that have a runtime that is directly proportional to the size of the input. This means that the runtime of the algorithm will increase linearly with the size of the input. For example, if the input size is 10, the runtime will be 10 times the runtime of the algorithm when the input size is 1. If the input size is 100, the runtime will be 100 times the runtime of the algorithm when the input size is 1.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Linear Search Algorithm",
        "url": "https://www.geeksforgeeks.org/linear-search/",
        "type": "article"
      },
      {
        "title": "Big O Notation — Calculating Time Complexity",
        "url": "https://www.youtube.com/watch?v=Z0bH0cMY0E8",
        "type": "video"
      },
      {
        "title": "Big O Notations",
        "url": "https://www.youtube.com/watch?v=V6mKVRU1evU",
        "type": "video"
      }
    ]
  },
  "sVFvpsAO1_ZH9aliEj9aF": {
    "title": "Polynomial",
    "description": "Polynomial algorithms are algorithms that have a runtime that is a polynomial function of the input size. This means that the runtime is a function of the form `n^k` where `k` is a constant. For example, the runtime of the following algorithm is `n^2`:\n\n    def polynomial_algorithm(n):\n        for i in range(n):\n            for j in range(n):\n                print(i, j)\n    \n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Big O Notation — Calculating Time Complexity",
        "url": "https://www.youtube.com/watch?v=Z0bH0cMY0E8",
        "type": "video"
      },
      {
        "title": "Big O Notations",
        "url": "https://www.youtube.com/watch?v=V6mKVRU1evU",
        "type": "video"
      }
    ]
  },
  "5mMLr6tWbiSZuox1lx0_B": {
    "title": "Exponential",
    "description": "Exponential algorithms are those that grow at a rate of 2^n. This means that for each additional input, the algorithm will take twice as long to run. The following function is an example of an exponential algorithm:\n\n    def exponential(n):\n        if n == 0:\n            return 1\n        return exponential(n - 1) + exponential(n - 1)\n    \n\nAs you can see, the algorithm's runtime grows exponentially. For each additional input, the algorithm will take twice as long to run.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Big O Notation — Calculating Time Complexity",
        "url": "https://www.youtube.com/watch?v=Z0bH0cMY0E8",
        "type": "video"
      },
      {
        "title": "Big O Notations",
        "url": "https://www.youtube.com/watch?v=V6mKVRU1evU",
        "type": "video"
      }
    ]
  },
  "m0umGQNdvg95UiNpQZsQN": {
    "title": "Factorial",
    "description": "Factorial complexity algorithms have a runtime of `O(n!)`. This is the worst case scenario for an algorithm. Factorial complexity algorithms are very inefficient and should be avoided.\n\n    def generate_permutations(s):\n        # Base case: If the string length is 1, return a list containing the string\n        if len(s) == 1:\n            return [s]\n    \n        # Initialize the result list\n        permutations = []\n    \n        # Recursively generate all permutations\n        for i in range(len(s)):\n            # Current character\n            current_char = s[i]\n            # Remaining characters\n            remaining_chars = s[:i] + s[i + 1 :]\n            # Generate all permutations of the remaining characters\n            for perm in generate_permutations(remaining_chars):\n                # Add the current character to the front of each generated permutation\n                permutations.append(current_char + perm)\n    \n        return permutations\n    \n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Big O Cheat Sheet - Time Complexity Chart",
        "url": "https://www.freecodecamp.org/news/big-o-cheat-sheet-time-complexity-chart/",
        "type": "article"
      },
      {
        "title": "Factorial Explained",
        "url": "https://www.youtube.com/watch?v=pxh__ugRKz8",
        "type": "video"
      }
    ]
  },
  "7a6-AnBI-3tAU1dkOvPkx": {
    "title": "Common Algorithms",
    "description": "Here are some common algorithms that you should know. You can find more information about them in the Algorithms section of the Computer Science course.\n\n*   Sorting\n*   Recursion\n*   Searching\n*   Cache Algorithms\n*   Tree Algorithms\n*   Graph Algorithms\n*   Greedy Algorithms\n*   Backtracking\n*   Substring Search\n*   Suffix Arrays\n*   Dynamic Programming\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Top Algorithms and Data Structures",
        "url": "https://medium.com/data-science/top-algorithms-and-data-structures-you-really-need-to-know-ab9a2a91c7b5",
        "type": "article"
      }
    ]
  },
  "0_qNhprnXU3i8koW3XTdD": {
    "title": "Tail Recursion",
    "description": "Tail recursion is a special kind of recursion where the recursive call is the very last thing in the function. It's a function that does not do anything at all after recursing.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Tail Recursion",
        "url": "https://www.coursera.org/lecture/programming-languages/tail-recursion-YZic1",
        "type": "course"
      },
      {
        "title": "What is tail recursion? Why is it so bad?",
        "url": "https://www.quora.com/What-is-tail-recursion-Why-is-it-so-bad",
        "type": "article"
      },
      {
        "title": "Explore top posts about Recursion",
        "url": "https://app.daily.dev/tags/recursion?ref=roadmapsh",
        "type": "article"
      }
    ]
  },
  "iLEOuQgUgU5Jc38iXDpp5": {
    "title": "Non-Tail Recursion",
    "description": "Tail recursion is when a function can directly return the result of a recursive call - there are no outstanding operations, and there is no need for the call stack frame to be preserved. So it can be translated to a “goto with arguments”, and the stack usage will be constant.\n\nIn “non-tail recursion”, there are outstanding operations after the recursive call, and the stack frame cannot be nuked.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "What is non-tail recursion?",
        "url": "https://www.quora.com/What-is-non-tail-recursion",
        "type": "article"
      },
      {
        "title": "Tail vs Non-Tail Recursion",
        "url": "https://www.baeldung.com/cs/tail-vs-non-tail-recursion",
        "type": "article"
      },
      {
        "title": "Explore top posts about Recursion",
        "url": "https://app.daily.dev/tags/recursion?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Recursion (Solved Problem 1)",
        "url": "https://www.youtube.com/watch?v=IVLUGb_gDDE",
        "type": "video"
      },
      {
        "title": "Types of Recursion (Part 2) | Tail & Non-tail Recursion",
        "url": "https://www.youtube.com/watch?v=HIt_GPuD7wk",
        "type": "video"
      }
    ]
  },
  "cEsboPT8nLvo0Zt0_oBq6": {
    "title": "LRU Cache",
    "description": "LRU cache is a cache that evicts the least recently used item first. It is a very common cache algorithm. It is used in many places, such as in the browser cache, the database cache, and the cache of the operating system.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "The Magic of LRU Cache (100 Days of Google Dev)",
        "url": "https://www.youtube.com/watch?v=R5ON3iwx78M",
        "type": "video"
      },
      {
        "title": "Implementing LRU - Udacity",
        "url": "https://www.youtube.com/watch?v=bq6N7Ym81iI",
        "type": "video"
      },
      {
        "title": "LeetCode | 146 LRU Cache | C++ | Explanation",
        "url": "https://www.youtube.com/watch?v=8-FZRAjR7qU",
        "type": "video"
      }
    ]
  },
  "hna0HLu0l4NTNNpyGqlW5": {
    "title": "MFU Cache",
    "description": "MFU Cache is another cache algorithm. The difference is that instead of deleting the least frequently used entry, the MFU Cache deletes the most frequently used entry.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Comparison of MFU and LRU page replacement algorithms",
        "url": "https://stackoverflow.com/questions/13597246/comparison-of-mfu-and-lru-page-replacement-algorithms",
        "type": "article"
      },
      {
        "title": "Why does cache use Most Recently Used (MRU) algorithm as evict policy?",
        "url": "https://stackoverflow.com/questions/5088128/why-does-cache-use-most-recently-used-mru-algorithm-as-evict-policy",
        "type": "article"
      }
    ]
  },
  "8kTg4O9MrTHRUrp6U-ctA": {
    "title": "Binary Search",
    "description": "Binary search is a search algorithm that finds the position of a target value within a sorted array. Binary search compares the target value to the middle element of the array. If they are not equal, the half in which the target cannot lie is eliminated and the search continues on the remaining half, again taking the middle element to compare to the target value, and repeating this until the target value is found. If the search ends with the remaining half being empty, the target is not in the array.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Binary Search - Khan Academy",
        "url": "https://www.khanacademy.org/computing/computer-science/algorithms/binary-search/a/binary-search",
        "type": "article"
      },
      {
        "title": "Binary Search",
        "url": "https://www.topcoder.com/thrive/articles/Binary%20Search",
        "type": "article"
      },
      {
        "title": "Explore top posts about Binary Search",
        "url": "https://app.daily.dev/tags/binary-search?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Binary Search in 4 Minutes",
        "url": "https://www.youtube.com/watch?v=fDKIpRe8GW4&feature=youtu.be",
        "type": "video"
      },
      {
        "title": "Binary Search - CS50",
        "url": "https://www.youtube.com/watch?v=D5SrAga1pno",
        "type": "video"
      }
    ]
  },
  "XwyqBK9rgP1MMcJrdIzm5": {
    "title": "Linear Search",
    "description": "Linear search is a very simple algorithm that is used to search for a value in an array. It sequentially checks each element of the array until a match is found or until all the elements have been searched.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Linear Search",
        "url": "https://www.programiz.com/dsa/linear-search",
        "type": "article"
      }
    ]
  },
  "4wGBYFZpcdTt97WTbSazx": {
    "title": "Bubble Sort",
    "description": "Bubble sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements and swaps them if they are in the wrong order. The pass through the list is repeated until the list is sorted.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Bubble Sort Algorithm",
        "url": "https://www.programiz.com/dsa/bubble-sort",
        "type": "article"
      },
      {
        "title": "Bubble Sort",
        "url": "https://www.youtube.com/watch?v=P00xJgWzz2c&index=1&list=PL89B61F78B552C1AB",
        "type": "video"
      },
      {
        "title": "Bubble sort in 2 minutes",
        "url": "https://youtu.be/xli_FI7CuzA",
        "type": "video"
      }
    ]
  },
  "rOsHFXQm5jNz0RyZQ5ZGs": {
    "title": "Selection Sort",
    "description": "Selection sort is a sorting algorithm that selects the smallest unsorted item in the list and swaps it with index 0, then finds the next smallest and places it into index 1 and so on.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Selection Sort",
        "url": "https://www.coursera.org/lecture/algorithms-part1/selection-UQxFT",
        "type": "course"
      },
      {
        "title": "Selection Sort",
        "url": "https://en.wikipedia.org/wiki/Selection_sort",
        "type": "article"
      },
      {
        "title": "Selection Sort in 3 Minutes",
        "url": "https://www.youtube.com/watch?v=g-PGLbMth_g",
        "type": "video"
      }
    ]
  },
  "ujDCW6zZE8dV_fpNf-oIl": {
    "title": "Insertion Sort",
    "description": "Insertion sort is a simple sorting algorithm that builds the final sorted array one item at a time by comparisons. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Insertion Sort",
        "url": "https://www.programiz.com/dsa/insertion-sort",
        "type": "article"
      },
      {
        "title": "Insertion Sort — MIT",
        "url": "https://www.youtube.com/watch?v=Kg4bqzAqRBM&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=4",
        "type": "video"
      },
      {
        "title": "Insertion Sort in 3 Minutes",
        "url": "https://www.youtube.com/watch?v=JU767SDMDvA",
        "type": "video"
      }
    ]
  },
  "CovrRsBY-sYW_xSegcN6N": {
    "title": "Heap Sort",
    "description": "Heap sort is a comparison based sorting algorithm. It is similar to selection sort where we first find the maximum element and place the maximum element at the end. We repeat the same process for remaining element.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Heap Sort Algorithm",
        "url": "https://www.coursera.org/lecture/data-structures/heap-sort-hSzMO",
        "type": "course"
      },
      {
        "title": "Heap Sort Algorithm",
        "url": "https://www.programiz.com/dsa/heap-sort",
        "type": "article"
      },
      {
        "title": "Heap Sort in 4 Minutes",
        "url": "https://www.youtube.com/watch?v=2DmK_H7IdTo",
        "type": "video"
      },
      {
        "title": "Heap Sort Algorithm - MIT",
        "url": "https://www.youtube.com/watch?v=odNJmw5TOEE&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&t=3291s",
        "type": "video"
      },
      {
        "title": "Lecture 4 - Heaps and Heap Sort",
        "url": "https://www.youtube.com/watch?v=B7hVxCmfPtM&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=5",
        "type": "video"
      }
    ]
  },
  "be0Q8GW9ZX1JbPrBvbMji": {
    "title": "Quick Sort",
    "description": "Quick Sort is a divide and conquer algorithm. It picks an element as pivot and partitions the given array around the picked pivot. There are many different versions of quickSort that pick pivot in different ways.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Quick Sort Implementation in Python",
        "url": "https://github.com/jwasham/practice-python/blob/master/quick_sort/quick_sort.py",
        "type": "opensource"
      },
      {
        "title": "Quick Sort Algorithm",
        "url": "https://www.programiz.com/dsa/quick-sort",
        "type": "article"
      },
      {
        "title": "Quick Sort Implementation in C",
        "url": "http://www.cs.yale.edu/homes/aspnes/classes/223/examples/randomization/quick.c",
        "type": "article"
      },
      {
        "title": "Quick Sort in 4 Minutes",
        "url": "https://www.youtube.com/watch?v=Hoixgm4-P4M&feature=youtu.be",
        "type": "video"
      }
    ]
  },
  "Bh-whDbcCjl3m6mRm9w02": {
    "title": "Merge Sort",
    "description": "Merge sort is a divide and conquer algorithm. It divides the input array into two halves, calls itself for the two halves, and then merges the two sorted halves. The `merge()` function is used for merging two halves. The `merge(arr, l, m, r)` is key process that assumes that `arr[l..m]` and `arr[m+1..r]` are sorted and merges the two sorted sub-arrays into one.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Merge Sort Algorithm",
        "url": "https://www.programiz.com/dsa/merge-sort",
        "type": "article"
      },
      {
        "title": "Merge Sort in 3 Minutes",
        "url": "https://www.youtube.com/watch?v=4VqmGXwpLqc",
        "type": "video"
      }
    ]
  },
  "psTN5N66xoFHFopgd5faW": {
    "title": "Pre-Order Traversal",
    "description": "Pre-order traversal is a tree traversal algorithm that visits the root node first, then recursively traverses the left subtree, followed by the right subtree.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Tree | Illustrated Data Structures",
        "url": "https://www.youtube.com/watch?v=S2W3SXGPVyU",
        "type": "video"
      },
      {
        "title": "Pre-order tree traversal in 3 minutes",
        "url": "https://www.youtube.com/watch?v=1WxLM2hwL-U",
        "type": "video"
      }
    ]
  },
  "KTrgf14Q6rg2f0v4dqq2s": {
    "title": "In-Order Traversal",
    "description": "In-order traversal is a tree traversal algorithm that visits the left subtree, the root, and then the right subtree. This is the most common way to traverse a binary search tree. It is also used to create a sorted list of nodes in a binary search tree.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Tree Traversal Techniques",
        "url": "https://www.geeksforgeeks.org/tree-traversals-inorder-preorder-and-postorder/",
        "type": "article"
      },
      {
        "title": "Tree | Illustrated Data Structures",
        "url": "https://www.youtube.com/watch?v=S2W3SXGPVyU",
        "type": "video"
      }
    ]
  },
  "4_oGXwjzSY5cX9n7L4iAA": {
    "title": "Post Order Traversal",
    "description": "Post-order traversal is a type of tree traversal that visits the left subtree, then the right subtree, and finally the root node. This is the opposite of pre-order traversal, which visits the root node first, then the left subtree, and finally the right subtree.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Postorder Traversal of Binary Tree",
        "url": "https://www.geeksforgeeks.org/postorder-traversal-of-binary-tree/",
        "type": "article"
      },
      {
        "title": "Tree | Illustrated Data Structures",
        "url": "https://www.youtube.com/watch?v=S2W3SXGPVyU",
        "type": "video"
      }
    ]
  },
  "Ke_ch4fnuKIiGAXUM_LPP": {
    "title": "Breadth First Search",
    "description": "Breadth first search is a graph traversal algorithm that starts at the root node and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Breadth-First Search (BFS) and Depth-First Search (DFS) for Binary Trees in Java",
        "url": "https://www.digitalocean.com/community/tutorials/breadth-first-search-depth-first-search-bfs-dfs",
        "type": "article"
      },
      {
        "title": "BFS and DFS in a Binary Tree",
        "url": "https://www.youtube.com/watch?v=uWL6FJhq5fM",
        "type": "video"
      },
      {
        "title": "Breadth-first search in 4 minutes",
        "url": "https://www.youtube.com/watch?v=HZ5YTanv5QE",
        "type": "video"
      }
    ]
  },
  "chzP5_t2gMi6MstxEzCi5": {
    "title": "Depth First Search",
    "description": "Depth first search is a graph traversal algorithm that starts at a root node and explores as far as possible along each branch before backtracking.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Breadth-First Search (BFS) and Depth-First Search (DFS) for Binary Trees in Java",
        "url": "https://www.digitalocean.com/community/tutorials/breadth-first-search-depth-first-search-bfs-dfs",
        "type": "article"
      },
      {
        "title": "BFS and DFS in a Binary Tree",
        "url": "https://www.youtube.com/watch?v=uWL6FJhq5fM",
        "type": "video"
      },
      {
        "title": "Depth First Search in 4 Minutes",
        "url": "https://www.youtube.com/watch?v=Urx87-NMm6c",
        "type": "video"
      }
    ]
  },
  "vcV6TEM_PqXxtThdfMKGw": {
    "title": "Breadth First Search",
    "description": "Breadth first search for a graph is a way to traverse the graph. It starts at the root node and explores all of the neighbor nodes at the present depth prior to moving on to the nodes at the next depth level.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Graph Algorithms II - DFS, BFS, Kruskals Algorithm, Union Find Data Structure - Lecture 7",
        "url": "https://www.youtube.com/watch?v=ufj5_bppBsA&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&index=7",
        "type": "video"
      },
      {
        "title": "Breadth-first search in 4 minutes",
        "url": "https://www.youtube.com/watch?v=HZ5YTanv5QE",
        "type": "video"
      }
    ]
  },
  "Yf5gOIe7oiL19MjEVcpdw": {
    "title": "Depth First Search",
    "description": "Depth first search is a graph traversal algorithm that starts at a root node and explores as far as possible along each branch before backtracking.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Depth-first Search",
        "url": "https://en.wikipedia.org/wiki/Depth-first_search",
        "type": "article"
      }
    ]
  },
  "eY4nK2lPYsrR-a_8y2sao": {
    "title": "Bellman Ford's Algorithm",
    "description": "Bellman ford's algorithm is a graph algorithm that finds the shortest path from a source vertex to all other vertices in a graph. It is a dynamic programming algorithm that uses a bottom-up approach to find the shortest path. It is similar to Dijkstra's algorithm but it can handle negative weights. It is also similar to Floyd-Warshall's algorithm but it can handle negative weights and it is faster than Floyd-Warshall's algorithm.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Explore top posts about Data Science",
        "url": "https://app.daily.dev/tags/data-science?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Bellman-Ford - MIT",
        "url": "https://www.youtube.com/watch?v=f9cVS_URPc0&ab_channel=MITOpenCourseWare",
        "type": "video"
      },
      {
        "title": "Bellman-Ford in 4 Minutes",
        "url": "https://www.youtube.com/watch?v=9PHkk0UavIM",
        "type": "video"
      }
    ]
  },
  "oJstm-8c-4seWbIWcNgDv": {
    "title": "Dijkstra's Algorithm",
    "description": "Dijkstra's algorithm is a graph traversal algorithm that finds the shortest path between two nodes in a graph. It is a weighted graph algorithm, meaning that each edge in the graph has a weight associated with it. The algorithm works by finding the shortest path from the starting node to all other nodes in the graph. It does this by keeping track of the distance from the starting node to each node, and then choosing the node with the shortest distance from the starting node to visit next. It then updates the distance of each node from the starting node, and repeats the process until all nodes have been visited.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Explore top posts about Data Science",
        "url": "https://app.daily.dev/tags/data-science?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Dijkstras Algorithm - MIT",
        "url": "https://www.youtube.com/watch?v=NSHizBK9JD8&t=1731s&ab_channel=MITOpenCourseWare",
        "type": "video"
      },
      {
        "title": "Dijkstras Algorithm in 3 Minutes",
        "url": "https://www.youtube.com/watch?v=_lHSawdgXpI",
        "type": "video"
      }
    ]
  },
  "Yrk2PLUa-_FAPlhCkMl3e": {
    "title": "A* Algorithm",
    "description": "A\\* is a graph traversal algorithm that is used to find the shortest path between two nodes in a graph. It is a modified version of Dijkstra's algorithm that uses heuristics to find the shortest path. It is used in pathfinding and graph traversal.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "A* Search Algorithm - Wikipedia",
        "url": "https://en.wikipedia.org/wiki/A*_search_algorithm",
        "type": "article"
      },
      {
        "title": "Explore top posts about Data Science",
        "url": "https://app.daily.dev/tags/data-science?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "A* Pathfinding (E01: algorithm explanation)",
        "url": "https://www.youtube.com/watch?v=-L-WgKMFuhE",
        "type": "video"
      }
    ]
  },
  "aBjBHpq_OajgQjxdCobXD": {
    "title": "Finding Hamiltonian Paths",
    "description": "Hamiltonian paths are paths that visit every node in a graph exactly once. They are named after the famous mathematician Hamilton. Hamiltonian paths are a special case of Hamiltonian cycles, which are cycles that visit every node in a graph exactly once.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Hamiltonian Cycles",
        "url": "https://en.wikipedia.org/wiki/Hamiltonian_cycle",
        "type": "article"
      },
      {
        "title": "Hamiltonian Path",
        "url": "https://www.hackerearth.com/practice/algorithms/graphs/hamiltonian-path/tutorial/",
        "type": "article"
      },
      {
        "title": "Hamiltonian Paths and Cycles",
        "url": "https://medium.com/stamatics-iit-kanpur/hamiltonian-paths-and-cycles-4f233bfbc53a",
        "type": "article"
      },
      {
        "title": "Hamiltonian Paths - Lecture 7",
        "url": "https://people.csail.mit.edu/virgi/6.s078/lecture17.pdf",
        "type": "article"
      }
    ]
  },
  "HlAmTY1udqDT2mTfBU9P-": {
    "title": "Solving N Queen Problem",
    "description": "N Queen Problem is a famous problem in Computer Science. It is a problem of placing n queens on an n x n chessboard such that no two queens attack each other. The problem is to find all possible solutions to the problem.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "N-Queens problem using backtracking in Java/C++",
        "url": "https://www.digitalocean.com/community/tutorials/n-queens-problem-java-c-plus-plus",
        "type": "article"
      },
      {
        "title": "6.1 N Queens Problem using Backtracking",
        "url": "https://www.youtube.com/watch?v=xFv_Hl4B83A",
        "type": "video"
      }
    ]
  },
  "nODFT-i2YsxUVsgwWkIWn": {
    "title": "Maze Solving Problem",
    "description": "Maze solving problem is a classic problem in computer science. It is a problem where we have to find a path from a starting point to an end point in a maze. The maze is represented as a grid of cells. Each cell can be either a wall or a path. The path cells are connected to each other. The starting point and the end point are also given. The goal is to find a path from the starting point to the end point. The path can only be made up of path cells. The path cannot go through the wall cells.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Maze Solving Algorithms",
        "url": "https://github.com/john-science/mazelib/blob/main/docs/MAZE_SOLVE_ALGOS.md",
        "type": "opensource"
      },
      {
        "title": "Maze Solving Algorithms",
        "url": "https://kidscodecs.com/maze-solving-algorithms/",
        "type": "article"
      },
      {
        "title": "Maze Solving - Computerphile",
        "url": "https://www.youtube.com/watch?v=rop0W4QDOUI",
        "type": "video"
      },
      {
        "title": "Python Maze Solving Tutorial (Using Recursion)",
        "url": "https://www.youtube.com/watch?v=XP94WC_XnZc",
        "type": "video"
      }
    ]
  },
  "NcKW_3vJWL_rVlDBB_Qjs": {
    "title": "The Knight's Tour Problem",
    "description": "Knight's Tour Problem is a problem where we have to find a path for a knight to visit all the cells of a chessboard without visiting any cell twice.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Knights Tour",
        "url": "https://bradfieldcs.com/algos/graphs/knights-tour/",
        "type": "article"
      },
      {
        "title": "Knights Tour Problem",
        "url": "https://www.codesdope.com/course/algorithms-knights-tour-problem/",
        "type": "article"
      },
      {
        "title": "Backtracking: The Knight’s Tour Problem",
        "url": "https://www.codingninjas.com/codestudio/library/backtracking-the-knights-tour-problem",
        "type": "article"
      }
    ]
  },
  "l3X9UrEYTWs5kBXI1NNCf": {
    "title": "Dijkstra's Algorithm",
    "description": "Dijkstra's algorithm is a greedy algorithm that finds the shortest path between two nodes in a graph. It is a very common algorithm used in computer science and is used in many applications such as GPS navigation, network routing, and finding the shortest path in a maze.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Explore top posts about Data Science",
        "url": "https://app.daily.dev/tags/data-science?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Dijkstras Algorithm in 3 Minutes",
        "url": "https://www.youtube.com/watch?v=_lHSawdgXpI",
        "type": "video"
      },
      {
        "title": "Dijkstras Algorithm - MIT",
        "url": "https://www.youtube.com/watch?v=NSHizBK9JD8&t=1731s&ab_channel=MITOpenCourseWare",
        "type": "video"
      },
      {
        "title": "Speeding Up Dijkstras Algorithm - MIT",
        "url": "https://www.youtube.com/watch?v=CHvQ3q_gJ7E&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=18",
        "type": "video"
      }
    ]
  },
  "QrcijPiVT3bgqfkF-6ssi": {
    "title": "Huffman Coding",
    "description": "Huffman coding is a lossless data compression algorithm. The idea is to assign variable-length codes to input characters, lengths of the assigned codes are based on the frequencies of corresponding characters. The most frequent character gets the smallest code and the least frequent character gets the largest code.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Huffman Coding",
        "url": "https://www.programiz.com/dsa/huffman-coding",
        "type": "article"
      },
      {
        "title": "Huffman Coding - Greedy Method",
        "url": "https://www.youtube.com/watch?v=co4_ahEDCho",
        "type": "video"
      }
    ]
  },
  "Wqhg7E-lOz1oNcRXjUej8": {
    "title": "Kruskal's Algorithm",
    "description": "Kruskal's algorithm is a greedy algorithm that finds a minimum spanning tree for a connected weighted graph. It is a minimum spanning tree algorithm that takes a graph as input and finds the subset of the edges of that graph which form a tree that includes every vertex, where the total weight of all the edges in the tree is minimized. If the graph is not connected, then it finds a minimum spanning forest (a minimum spanning tree for each connected component).\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Explore top posts about Data Science",
        "url": "https://app.daily.dev/tags/data-science?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Kruskals Algorithm in 2 Minutes",
        "url": "https://www.youtube.com/watch?v=71UQH7Pr9kU",
        "type": "video"
      },
      {
        "title": "Graph Algorithms II - DFS, BFS, Kruskals Algorithm, Union Find Data Structure - Lecture 7",
        "url": "https://www.youtube.com/watch?v=ufj5_bppBsA&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&index=8",
        "type": "video"
      }
    ]
  },
  "Hqw2eGtgfbVggqXBnIOdI": {
    "title": "Ford-Fulkerson Algorithm",
    "description": "Ford Fulkerson Algorithm is a greedy algorithm that is used to find the maximum flow in a flow network. It is also known as the Edmonds-Karp Algorithm.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Ford-Fulkerson Algorithm",
        "url": "https://www.programiz.com/dsa/ford-fulkerson-algorithm",
        "type": "article"
      },
      {
        "title": "Explore top posts about Data Science",
        "url": "https://app.daily.dev/tags/data-science?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Ford-Fulkerson in 5 minutes",
        "url": "https://www.youtube.com/watch?v=Tl90tNtKvxs",
        "type": "video"
      }
    ]
  },
  "znpFIKwMJlepKJ8dH3kvC": {
    "title": "Prim's Algorithm",
    "description": "Prim's algorithm is a greedy algorithm that finds a minimum spanning tree for a weighted undirected graph. A minimum spanning tree is a subset of the edges of a connected, edge-weighted undirected graph that connects all the vertices together, without any cycles and with the minimum possible total edge weight. A minimum spanning tree for a weighted undirected graph is also called a minimum weight spanning tree or minimum cost spanning tree.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Prims Algorithm",
        "url": "https://www.programiz.com/dsa/prim-algorithm",
        "type": "article"
      },
      {
        "title": "Explore top posts about Data Science",
        "url": "https://app.daily.dev/tags/data-science?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Graph Algorithms I - Topological Sorting, Prims Algorithm - Lecture 6",
        "url": "https://www.youtube.com/watch?v=i_AQT_XfvD8&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&index=7",
        "type": "video"
      }
    ]
  },
  "l5--4opvZoc_seVn__5R3": {
    "title": "Rabin-Karp Algorithm",
    "description": "Rabin-Karp algorithm is a string searching algorithm that uses hashing to find any one of a set of pattern strings in a text. For strings of average length `n`, it performs in `O(n+m)` time with `O(m)` space, where `m` is the length of the pattern. It is often used in bioinformatics to search for DNA patterns.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Rabin Karps Algorithm",
        "url": "https://www.coursera.org/lecture/data-structures/rabin-karps-algorithm-c0Qkw",
        "type": "course"
      },
      {
        "title": "Optimization: Precomputation",
        "url": "https://www.coursera.org/learn/data-structures/lecture/nYrc8/optimization-precomputation",
        "type": "course"
      },
      {
        "title": "Optimization: Implementation and Analysis",
        "url": "https://www.coursera.org/learn/data-structures/lecture/h4ZLc/optimization-implementation-and-analysis",
        "type": "course"
      },
      {
        "title": "Explore top posts about Data Science",
        "url": "https://app.daily.dev/tags/data-science?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Lecture 9: Table Doubling, Karp-Rabin",
        "url": "https://www.youtube.com/watch?v=BRO7mVIFt08&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=9",
        "type": "video"
      },
      {
        "title": "Rolling Hashes, Amortized Analysis",
        "url": "https://www.youtube.com/watch?v=w6nuXg0BISo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=33",
        "type": "video"
      }
    ]
  },
  "n11ujPI3of-52l2KW2CDQ": {
    "title": "LFU Cache",
    "description": "LFU Cache is a data structure that stores key-value pairs. It has a fixed size and when it is full, it removes the least frequently used key-value pair. It is a variation of the LRU Cache and is used in many applications such as caching web pages, caching database queries, and caching images.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Least Frequently Used (LFU) Cache Implementation",
        "url": "https://www.geeksforgeeks.org/least-frequently-used-lfu-cache-implementation/",
        "type": "article"
      },
      {
        "title": "1117. Data Structure - LFU Cache",
        "url": "https://jojozhuang.github.io/algorithm/data-structure-lfu-cache/",
        "type": "article"
      }
    ]
  },
  "NUWk-7IXmMU-4TT-oS8fF": {
    "title": "String Search & Manipulations",
    "description": "String search and manipulation is a very important topic in computer science. It is used in many different applications, such as searching or replacing a specific pattern, word or character in a string.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "String-searching Algorithm",
        "url": "https://en.wikipedia.org/wiki/String-searching_algorithm",
        "type": "article"
      }
    ]
  },
  "L4M5yFRKKR2axKXGcIA7d": {
    "title": "Search Pattern in Text",
    "description": "Searching pattern in text is a very common task in computer science. It is used in many applications like spell checkers, text editors, and many more.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Search Pattern in Text",
        "url": "https://www.coursera.org/learn/data-structures/lecture/tAfHI/search-pattern-in-text",
        "type": "course"
      },
      {
        "title": "Pattern Searching",
        "url": "https://www.geeksforgeeks.org/pattern-searching/",
        "type": "article"
      }
    ]
  },
  "Ld1TUNS8713coMNvwhNIJ": {
    "title": "Suffix Arrays",
    "description": "Suffix arrays are a data structure that allows us to quickly find all the suffixes of a string in lexicographical order. This is useful for many problems, such as finding the longest common substring between two strings, or finding the number of distinct substrings of a string.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Suffix Arrays - Coursera",
        "url": "https://www.coursera.org/learn/algorithms-part2/lecture/TH18W/suffix-arrays",
        "type": "course"
      },
      {
        "title": "Suffix Arrays - Princeton University",
        "url": "https://algs4.cs.princeton.edu/63suffix/",
        "type": "article"
      },
      {
        "title": "Suffix Array Introduction",
        "url": "https://www.youtube.com/watch?v=zqKlL3ZpTqs",
        "type": "video"
      },
      {
        "title": "Advanced Data Structures: Suffix Arrays",
        "url": "https://www.youtube.com/watch?v=IzMxbboPcqQ",
        "type": "video"
      },
      {
        "title": "Suffix Arrays: building",
        "url": "https://www.youtube.com/watch?v=ZWlbhBjjwyA",
        "type": "video"
      }
    ]
  },
  "g3b0kt1fCAjjYyS2WelWi": {
    "title": "Brute Force Search",
    "description": "Brute force search is a simple algorithm that checks for a pattern in a string by comparing each character of the string with the first character of the pattern. If the first character matches, it then compares the next character of the string with the next character of the pattern and so on. If all the characters of the pattern match, then the pattern is found. If the first character does not match, then the algorithm compares the second character of the string with the first character of the pattern and so on.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Brute-Force Substring Search",
        "url": "https://www.coursera.org/learn/algorithms-part2/lecture/2Kn5i/brute-force-substring-search",
        "type": "course"
      },
      {
        "title": "A Beginner Guide to Brute Force Algorithm for Substring Search",
        "url": "https://nulpointerexception.com/2019/02/10/a-beginner-guide-to-brute-force-algorithm-for-substring-search/",
        "type": "article"
      },
      {
        "title": "Brute Force Algorithm in Cybersecurity and String Search",
        "url": "https://www.baeldung.com/cs/brute-force-cybersecurity-string-search",
        "type": "article"
      }
    ]
  },
  "8abFKMfaV9H8F38I0DcMT": {
    "title": "Knuth-Morris Pratt",
    "description": "Knuth morris pratt is a string searching algorithm that uses a precomputed array to find the substring in a string. This array is known as the prefix function. The prefix function is the longest prefix that is also a suffix of a substring. The prefix function is used to skip the characters that are already matched. The algorithm is as follows:\n\n*   Compute the prefix function of the substring.\n*   Traverse through the string and substring simultaneously.\n*   If the characters match, increment the index of both the string and substring.\n*   If the characters don't match, increment the index of the string by the value of the prefix function at the index of the substring.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Knuth-Morris Pratt",
        "url": "https://www.coursera.org/learn/algorithms-part2/lecture/TAtDr/knuth-morris-pratt",
        "type": "course"
      },
      {
        "title": "9.1 Knuth-Morris-Pratt KMP String Matching Algorithm",
        "url": "https://www.youtube.com/watch?v=V5-7GzOfADQ",
        "type": "video"
      }
    ]
  },
  "p6qub32jcaGloHXUDUrlG": {
    "title": "Boyer-Moore",
    "description": "Boyer Moore algorithm is a string searching algorithm that is used to find the index of a substring in a string. It is a very efficient algorithm that is used in many applications. It is used in text editors, compilers, and many other applications.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Boyer Moore Algorithm",
        "url": "https://www.coursera.org/learn/algorithms-part2/lecture/CYxOT/boyer-moore",
        "type": "course"
      },
      {
        "title": "Boyer-Moore String-search Algorithm",
        "url": "https://en.wikipedia.org/wiki/Boyer%E2%80%93Moore_string-search_algorithm",
        "type": "article"
      }
    ]
  },
  "Km5LvcJpyntrW2iA8h5e3": {
    "title": "Robin-Karp",
    "description": "Rabin-Karp algorithm is a string searching algorithm that uses hashing to find any one of a set of pattern strings in a text. For strings of average length `n`, it performs in `O(n+m)` time with `O(m)` space, where `m` is the length of the pattern. It is often used in bioinformatics to search for DNA patterns.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Rabin Karps Algorithm",
        "url": "https://www.coursera.org/lecture/data-structures/rabin-karps-algorithm-c0Qkw",
        "type": "course"
      },
      {
        "title": "Optimization: Precomputation",
        "url": "https://www.coursera.org/learn/data-structures/lecture/nYrc8/optimization-precomputation",
        "type": "course"
      },
      {
        "title": "Optimization: Implementation and Analysis",
        "url": "https://www.coursera.org/learn/data-structures/lecture/h4ZLc/optimization-implementation-and-analysis",
        "type": "course"
      },
      {
        "title": "Lecture 9: Table Doubling, Karp-Rabin",
        "url": "https://www.youtube.com/watch?v=BRO7mVIFt08&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=9",
        "type": "video"
      },
      {
        "title": "Rolling Hashes, Amortized Analysis",
        "url": "https://www.youtube.com/watch?v=w6nuXg0BISo&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=33",
        "type": "video"
      }
    ]
  },
  "E9hf1ux1KKGHvvAShm67w": {
    "title": "Substring Search",
    "description": "Substring search is the problem of finding a substring in a string. This is a very common problem in computer science, and there are many algorithms for solving it.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Introduction to Substring Search",
        "url": "https://www.coursera.org/lecture/algorithms-part2/introduction-to-substring-search-n3ZpG",
        "type": "course"
      },
      {
        "title": "What is the fastest substring search algorithm?",
        "url": "https://stackoverflow.com/questions/3183582/what-is-the-fastest-substring-search-algorithm",
        "type": "article"
      },
      {
        "title": "Substring Search - Exercises",
        "url": "https://algs4.cs.princeton.edu/53substring/",
        "type": "article"
      }
    ]
  },
  "-bawIWfrYuAxy8cP-AGFS": {
    "title": "Floating Point Math",
    "description": "Floating point numbers are numbers that have a decimal point in them. They are used to represent real numbers. For example, 3.14 is a floating point number. 3 is not a floating point number because it does not have a decimal point in it.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Representation of Floating Point Numbers - 1",
        "url": "https://www.youtube.com/watch?v=ji3SfClm8TU",
        "type": "video"
      },
      {
        "title": "Why 0.1 + 0.2 != 0.3? | Floating Point Math",
        "url": "https://www.youtube.com/watch?v=RIiq4tTt6rI",
        "type": "video"
      }
    ]
  },
  "vjMqqFsTxSjaiYxmliwLi": {
    "title": "Endianess",
    "description": "Endianness is the order in which bytes are stored in memory. The two most common types of endianness are big endian and little endian. Big endian stores the most significant byte first, while little endian stores the least significant byte first.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Endianness",
        "url": "https://developer.mozilla.org/en-US/docs/Glossary/Endianness",
        "type": "article"
      },
      {
        "title": "Big-Endian vs Little-Endian Explained with Examples",
        "url": "https://www.freecodecamp.org/news/what-is-endianness-big-endian-vs-little-endian/",
        "type": "article"
      },
      {
        "title": "Big Endian vs Little Endian.mp4",
        "url": "https://www.youtube.com/watch?v=JrNF0KRAlyo",
        "type": "video"
      },
      {
        "title": "Endianness Explained With an Egg - Computerphile",
        "url": "https://www.youtube.com/watch?v=NcaiHcBvDR4",
        "type": "video"
      }
    ]
  },
  "U8AgY6I-62mN5Ohg9MsG6": {
    "title": "Big Endian",
    "description": "Big endian is the most common type of endianness. In this type, the most significant byte is stored at the lowest memory address. This means that the most significant byte is stored first and the least significant byte is stored last.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Lecture 22. Big Endian and Little Endian",
        "url": "https://www.youtube.com/watch?v=T1C9Kj_78ek",
        "type": "video"
      }
    ]
  },
  "rD_5n5bjiNMVC0cPhEVyG": {
    "title": "Little Endian",
    "description": "Little Endian is a way of storing data in memory. It is the opposite of Big Endian. In Little Endian, the least significant byte is stored first. In Big Endian, the most significant byte is stored first.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Big Endian vs Little Endian",
        "url": "https://www.youtube.com/watch?v=JrNF0KRAlyo",
        "type": "video"
      },
      {
        "title": "Endianness Explained With an Egg - Computerphile",
        "url": "https://www.youtube.com/watch?v=NcaiHcBvDR4",
        "type": "video"
      }
    ]
  },
  "DMuMsEowpevTCALtziwTB": {
    "title": "Common UML Diagrams",
    "description": "UML is a standard way of visualizing a software system. It is a general-purpose, developmental, modeling language in the field of software engineering that is intended to provide a standard way to visualize the design of a system.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Unified Modeling Language (UML) Description",
        "url": "https://www.uml-diagrams.org/",
        "type": "article"
      },
      {
        "title": "UML Diagrams Full Course (Unified Modeling Language)",
        "url": "https://www.youtube.com/watch?v=WnMQ8HlmeXc",
        "type": "video"
      }
    ]
  },
  "04hpfxI2x958tQI-0clsp": {
    "title": "Unicode",
    "description": "Unicode is a standard for encoding characters. It is a superset of ASCII, which means that ASCII is a subset of Unicode. Unicode is a 16-bit encoding, which means that it can encode 2^16 = 65536 characters. This is a lot more than ASCII, which can only encode 128 characters.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "How Unicode Works: What Every Developer Needs to Know About Strings and 🦄",
        "url": "https://deliciousbrains.com/how-unicode-works/",
        "type": "article"
      },
      {
        "title": "Characters, Symbols and the Unicode Miracle - Computerphile",
        "url": "https://www.youtube.com/watch?v=MijmeoH9LT4",
        "type": "video"
      }
    ]
  },
  "hmwsNp60alS43kJg4A_Og": {
    "title": "ASCII",
    "description": "ASCII is a character encoding standard for electronic communication. It was developed from telegraph code and uses 7 bits to represent 128 different characters. The first 32 characters are non-printable control characters used to control devices like printers and typewriters. The remaining 96 characters are printable and include the letters of the English alphabet, numbers, punctuation, and various symbols.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Must Know about Character Encodings",
        "url": "https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/",
        "type": "article"
      },
      {
        "title": "Character Encoding",
        "url": "https://cs.lmu.edu/~ray/notes/charenc/",
        "type": "article"
      }
    ]
  },
  "DtG9EJonWi4_2oQ4fWOKY": {
    "title": "Character Encodings",
    "description": "Character encodings are a way of representing characters as numbers. They are used to store and transmit text. The most common character encoding is ASCII, which is a 7-bit encoding. This means that each character is represented by a number between 0 and 127. The ASCII character set contains 128 characters, including letters, numbers, punctuation, and control characters. The ASCII character set is a subset of the Unicode character set, which is a 16-bit encoding. Unicode is a superset of ASCII, so ASCII characters can be represented by Unicode. Unicode is the most common character encoding used on the web.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Must Know about Character Encodings",
        "url": "https://www.joelonsoftware.com/2003/10/08/the-absolute-minimum-every-software-developer-absolutely-positively-must-know-about-unicode-and-character-sets-no-excuses/",
        "type": "article"
      },
      {
        "title": "Character Encoding",
        "url": "https://cs.lmu.edu/~ray/notes/charenc/",
        "type": "article"
      }
    ]
  },
  "FZ8znJSz8PvQlnEyRLXmQ": {
    "title": "Class Diagrams",
    "description": "Class Diagrams are used to model the static structure of a system. They are used to show the classes, their attributes, operations (or methods), and the relationships between objects.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Class Diagrams",
        "url": "https://www.visual-paradigm.com/guide/uml-unified-modeling-language/uml-class-diagram-tutorial/",
        "type": "article"
      },
      {
        "title": "UML Class Diagram Tutorial",
        "url": "https://www.youtube.com/watch?v=UI6lqHOVHic",
        "type": "video"
      }
    ]
  },
  "dVvYbrcaxHLpvtX6HbS7g": {
    "title": "Usecase Diagrams",
    "description": "Usecase diagrams are a type of diagram that are used to model the interactions between the **actors** and the **usecases** of the system.\n\nAn actor is a person or a system that interacts with the system. Actors are represented by a rectangle with the name of the actor written inside it.\n\nA usecase is a task that the system performs. Usecases are represented by an ellipse with the name of the usecase written inside it.\n\nA usecase diagram is a diagram that shows the actors and the usecases of the system. The diagram is represented by a rectangle that contains the name of the system inside it. The actors are represented by rectangles and the usecases are represented by ellipses.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "UML Use Case Diagram Tutorial",
        "url": "https://www.lucidchart.com/pages/uml-use-case-diagram",
        "type": "article"
      },
      {
        "title": "What is Use Case Diagram?",
        "url": "https://www.visual-paradigm.com/guide/uml-unified-modeling-language/what-is-use-case-diagram/",
        "type": "article"
      },
      {
        "title": "UML Use Case Diagram Tutorial",
        "url": "https://www.youtube.com/watch?v=zid-MVo7M-E",
        "type": "video"
      }
    ]
  },
  "ptfRNiU0mC0Q5SLA_FWZu": {
    "title": "Activity Diagrams",
    "description": "Activity diagrams are used to model the flow of control in a system. They are used in conjunction with use case diagrams to model the behavior of the system for each use case. They are also used to model the behavior of a single class.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "UML Activity Diagram Tutorial",
        "url": "https://www.lucidchart.com/pages/uml-activity-diagram",
        "type": "article"
      },
      {
        "title": "What is Activity Diagram?",
        "url": "https://www.visual-paradigm.com/guide/uml-unified-modeling-language/what-is-activity-diagram/",
        "type": "article"
      }
    ]
  },
  "X0CKM9LaJUrgI5gIdqFvU": {
    "title": "Statemachine Diagrams",
    "description": "State machine diagrams are used to show the different states an object can be in at a given time. The object can be in one and only one state at a given time. State machine diagrams are similar to activity diagrams, but they are more focused on the flow of an object's state rather than the flow of the object itself.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "What is State Machine Diagram?",
        "url": "https://www.visual-paradigm.com/guide/uml-unified-modeling-language/what-is-state-machine-diagram/",
        "type": "article"
      },
      {
        "title": "State Machine Diagram Tutorial",
        "url": "https://www.lucidchart.com/pages/uml-state-machine-diagram",
        "type": "article"
      },
      {
        "title": "State Machine Diagram",
        "url": "https://www.sciencedirect.com/topics/computer-science/state-machine-diagram",
        "type": "article"
      }
    ]
  },
  "gaUT5K2xS-WQMrIA0Bkb_": {
    "title": "Sequence Diagrams",
    "description": "Sequence diagrams are a way to show how objects or systems interact with each other over time.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "How to Make a UML Sequence Diagram",
        "url": "https://www.youtube.com/watch?v=pCK6prSq8aw",
        "type": "video"
      },
      {
        "title": "Sequence Diagrams Tutorial",
        "url": "https://www.youtube.com/watch?v=cxG-qWthxt4&list=PLfoY2ARMh0hBthB9VqsQzogSouTjzkMHe&index=2",
        "type": "video"
      }
    ]
  },
  "-De1hU2ONGwhQmUpsyrCO": {
    "title": "Design Patterns",
    "description": "Design patterns are solutions to common problems in software design. They are formalized best practices that the programmer can use to solve common problems when designing an application or system.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Design Patterns for Humans",
        "url": "https://github.com/kamranahmedse/design-patterns-for-humans",
        "type": "opensource"
      },
      {
        "title": "Design Patterns",
        "url": "https://en.wikipedia.org/wiki/Software_design_pattern",
        "type": "article"
      },
      {
        "title": "Refactoring Guru - Design Patterns",
        "url": "https://refactoring.guru/design-patterns/",
        "type": "article"
      },
      {
        "title": "Explore top posts about Design Patterns",
        "url": "https://app.daily.dev/tags/design-patterns?ref=roadmapsh",
        "type": "article"
      }
    ]
  },
  "iPN9mSyFwYZER5HSkj6oL": {
    "title": "GoF Design Patterns",
    "description": "Gang of Four (GoF) design patterns are a set of 23 design patterns that were first described in the book \"Design Patterns: Elements of Reusable Object-Oriented Software\" by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides. The book is commonly referred to as the \"Gang of Four book\".\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Design Patterns for Humans",
        "url": "https://github.com/kamranahmedse/design-patterns-for-humans",
        "type": "opensource"
      }
    ]
  },
  "BGhJNtszbYJtKyhqr2jax": {
    "title": "Architectural Patterns",
    "description": "Architectural patterns are a high-level design pattern that focuses on the overall structure of the system. They are similar to design patterns, but they are more concerned with the structure of the system. They are used to solve problems that are common to many software systems.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "10 Common Software Architectural Patterns in a nutshell",
        "url": "https://towardsdatascience.com/10-common-software-architectural-patterns-in-a-nutshell-a0b47a1e9013",
        "type": "article"
      },
      {
        "title": "Architectural Pattern - Wikipedia",
        "url": "https://en.wikipedia.org/wiki/Architectural_pattern",
        "type": "article"
      }
    ]
  },
  "J7DKRklMtJ94Y-18Jo50r": {
    "title": "Dependency Injection",
    "description": "Dependency injection is a software design pattern that allows us to decouple the dependencies of a class from the class itself. This allows us to write more flexible and testable code.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Dependency Injection - StackOverflow",
        "url": "https://stackoverflow.com/questions/130794/what-is-dependency-injection",
        "type": "article"
      },
      {
        "title": "Explore top posts about Dependency Injection",
        "url": "https://app.daily.dev/tags/dependency-injection?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "What is Dependency Injection?",
        "url": "https://www.youtube.com/watch?v=0yc2UANSDiw",
        "type": "video"
      }
    ]
  },
  "PpFQ0zmObZLvmBvqhTEMz": {
    "title": "Null Object Pattern",
    "description": "Null object pattern is a design pattern that is used to represent a null value with an object. It is a way to avoid null reference exceptions by providing a default object that does nothing. It is a way to provide a default behavior in case data is not available.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Design Patterns - Null Object Pattern",
        "url": "https://www.tutorialspoint.com/design_pattern/null_object_pattern.htm",
        "type": "article"
      }
    ]
  },
  "_2Jddpz_cdwyeIgrg5qt_": {
    "title": "Type Object Pattern",
    "description": "Type object pattern is a creational design pattern that allows us to create a new object of a type without exposing the object creation logic to the client. It is used when we need to create a new object of a type, but we don't know which type we need to create until runtime. It is like a factory pattern, but instead of returning a new object of a type, it returns a new object of a type that is already created.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Type Object Pattern",
        "url": "https://gameprogrammingpatterns.com/type-object.html",
        "type": "article"
      }
    ]
  },
  "cdNi0EYrQ5nsgNxFVnXL8": {
    "title": "Basic Math Skills",
    "description": "Math is a fundamental skill for computer science.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Computer Science 70, 001 - Spring 2015 - Discrete Mathematics and Probability Theory",
        "url": "http://www.infocobuild.com/education/audio-video-courses/computer-science/cs70-spring2015-berkeley.html",
        "type": "article"
      },
      {
        "title": "Discrete Mathematics By IIT Ropar NPTEL",
        "url": "https://nptel.ac.in/courses/106/106/106106183/",
        "type": "article"
      },
      {
        "title": "Explore top posts about Math",
        "url": "https://app.daily.dev/tags/math?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Lec 1 | MIT 6.042J Mathematics for Computer Science, Fall 2010",
        "url": "https://www.youtube.com/watch?v=L3LMbpZIKhQ&list=PLB7540DEDD482705B",
        "type": "video"
      },
      {
        "title": "Integer Arithmetic, Karatsuba Multiplication",
        "url": "https://www.youtube.com/watch?v=eCaXlAaN2uE&index=11&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb",
        "type": "video"
      },
      {
        "title": "The Chinese Remainder Theorem (used in cryptography)",
        "url": "https://www.youtube.com/watch?v=ru7mWZJlRQg",
        "type": "video"
      },
      {
        "title": "Discrete Mathematics by Shai Simonson (19 videos)",
        "url": "https://www.youtube.com/playlist?list=PLWX710qNZo_sNlSWRMVIh6kfTjolNaZ8t",
        "type": "video"
      },
      {
        "title": "MIT 6.042J - Probability Introduction",
        "url": "https://www.youtube.com/watch?v=SmFwFdESMHI&index=18&list=PLB7540DEDD482705B",
        "type": "video"
      },
      {
        "title": "MIT 6.042J - Conditional Probability",
        "url": "https://www.youtube.com/watch?v=E6FbvM-FGZ8&index=19&list=PLB7540DEDD482705B",
        "type": "video"
      },
      {
        "title": "MIT 6.042J - Independence",
        "url": "https://www.youtube.com/watch?v=l1BCv3qqW4A&index=20&list=PLB7540DEDD482705B",
        "type": "video"
      },
      {
        "title": "MIT 6.042J - Random Variables",
        "url": "https://www.youtube.com/watch?v=MOfhhFaQdjw&list=PLB7540DEDD482705B&index=21",
        "type": "video"
      },
      {
        "title": "MIT 6.042J - Expectation I",
        "url": "https://www.youtube.com/watch?v=gGlMSe7uEkA&index=22&list=PLB7540DEDD482705B",
        "type": "video"
      },
      {
        "title": "MIT 6.042J - Expectation II",
        "url": "https://www.youtube.com/watch?v=oI9fMUqgfxY&index=23&list=PLB7540DEDD482705B",
        "type": "video"
      },
      {
        "title": "MIT 6.042J - Large Deviations",
        "url": "https://www.youtube.com/watch?v=q4mwO2qS2z4&index=24&list=PLB7540DEDD482705B",
        "type": "video"
      },
      {
        "title": "MIT 6.042J - Random Walks",
        "url": "https://www.youtube.com/watch?v=56iFMY8QW2k&list=PLB7540DEDD482705B&index=25",
        "type": "video"
      }
    ]
  },
  "HZ3_xyphbjhBPwwQo_rHH": {
    "title": "Probability",
    "description": "Probability is the study of how likely an event is to occur. It is a measure of how certain we are that an event will happen.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Explore top posts about Statistics",
        "url": "https://app.daily.dev/tags/statistics?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "MIT 6.042J - Probability Introduction",
        "url": "https://www.youtube.com/watch?v=SmFwFdESMHI&index=18&list=PLB7540DEDD482705B",
        "type": "video"
      },
      {
        "title": "MIT 6.042J - Conditional Probability",
        "url": "https://www.youtube.com/watch?v=E6FbvM-FGZ8&index=19&list=PLB7540DEDD482705B",
        "type": "video"
      },
      {
        "title": "MIT 6.042J - Independence",
        "url": "https://www.youtube.com/watch?v=l1BCv3qqW4A&index=20&list=PLB7540DEDD482705B",
        "type": "video"
      },
      {
        "title": "MIT 6.042J - Random Variables",
        "url": "https://www.youtube.com/watch?v=MOfhhFaQdjw&list=PLB7540DEDD482705B&index=21",
        "type": "video"
      },
      {
        "title": "MIT 6.042J - Expectation I",
        "url": "https://www.youtube.com/watch?v=gGlMSe7uEkA&index=22&list=PLB7540DEDD482705B",
        "type": "video"
      },
      {
        "title": "MIT 6.042J - Expectation II",
        "url": "https://www.youtube.com/watch?v=oI9fMUqgfxY&index=23&list=PLB7540DEDD482705B",
        "type": "video"
      },
      {
        "title": "MIT 6.042J - Large Deviations",
        "url": "https://www.youtube.com/watch?v=q4mwO2qS2z4&index=24&list=PLB7540DEDD482705B",
        "type": "video"
      },
      {
        "title": "MIT 6.042J - Random Walks",
        "url": "https://www.youtube.com/watch?v=56iFMY8QW2k&list=PLB7540DEDD482705B&index=25",
        "type": "video"
      }
    ]
  },
  "lWnAY0DgrUOmT6yqnxeBN": {
    "title": "Combinatorics",
    "description": "Combinatorics is the study of counting. It is a branch of mathematics that is used to solve problems in a variety of fields, including computer science, statistics, and physics. In computer science, combinatorics is used to solve problems related to counting the number of possible outcomes of a given problem. For example, if you are given a set of 10 objects, how many different ways can you arrange them? Or, if you are given a set of 10 objects, how many different ways can you choose 3 objects from that set? These are examples of combinatorial problems.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Probability and Combinatorics",
        "url": "https://www.khanacademy.org/math/probability/probability-and-combinatorics-topic",
        "type": "article"
      },
      {
        "title": "Math Skills: How to find Factorial, Permutation and Combination",
        "url": "https://www.youtube.com/watch?v=8RRo6Ti9d0U",
        "type": "video"
      },
      {
        "title": "Make School: Probability",
        "url": "https://www.youtube.com/watch?v=sZkAAk9Wwa4",
        "type": "video"
      },
      {
        "title": "Make School: More Probability and Markov Chains",
        "url": "https://www.youtube.com/watch?v=dNaJg-mLobQ",
        "type": "video"
      }
    ]
  },
  "YLCmZvoLkhOk9wlgYW2Ms": {
    "title": "Complexity Classes",
    "description": "In computer science, there exist some problems whose solutions are not yet found, the problems are divided into classes known as Complexity Classes. In complexity theory, a Complexity Class is a set of problems with related complexity. These classes help scientists to groups problems based on how much time and space they require to solve problems and verify the solutions. It is the branch of the theory of computation that deals with the resources required to solve a problem.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Trying to understand P vs NP vs NP Complete vs NP Hard",
        "url": "https://softwareengineering.stackexchange.com/questions/308178/trying-to-understand-p-vs-np-vs-np-complete-vs-np-hard",
        "type": "article"
      },
      {
        "title": "Complexity: P, NP, NP-completeness, Reductions",
        "url": "https://www.youtube.com/watch?v=eHZifpgyH_4&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=22",
        "type": "video"
      },
      {
        "title": "Complexity: Approximation Algorithms",
        "url": "https://www.youtube.com/watch?v=MEz1J9wY2iM&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=24",
        "type": "video"
      },
      {
        "title": "Complexity: Fixed-Parameter Algorithms",
        "url": "https://www.youtube.com/watch?v=4q-jmGrmxKs&index=25&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp",
        "type": "video"
      },
      {
        "title": "Lecture 23: Computational Complexity",
        "url": "https://www.youtube.com/watch?v=moPtwq_cVH8&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=24",
        "type": "video"
      },
      {
        "title": "Greedy Algs. II & Intro to NP Completeness",
        "url": "https://youtu.be/qcGnJ47Smlo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&t=2939",
        "type": "video"
      }
    ]
  },
  "3aM17dPKNi8tRJsW8lesI": {
    "title": "P",
    "description": "The P in the P class stands for Polynomial Time. It is the collection of decision problems(problems with a “yes” or “no” answer) that can be solved by a deterministic machine in polynomial time.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Trying to understand P vs NP vs NP Complete vs NP Hard",
        "url": "https://softwareengineering.stackexchange.com/questions/308178/trying-to-understand-p-vs-np-vs-np-complete-vs-np-hard",
        "type": "article"
      },
      {
        "title": "Complexity: P, NP, NP-completeness, Reductions",
        "url": "https://www.youtube.com/watch?v=eHZifpgyH_4&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=22",
        "type": "video"
      },
      {
        "title": "Complexity: Approximation Algorithms",
        "url": "https://www.youtube.com/watch?v=MEz1J9wY2iM&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=24",
        "type": "video"
      },
      {
        "title": "Complexity: Fixed-Parameter Algorithms",
        "url": "https://www.youtube.com/watch?v=4q-jmGrmxKs&index=25&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp",
        "type": "video"
      },
      {
        "title": "Lecture 23: Computational Complexity",
        "url": "https://www.youtube.com/watch?v=moPtwq_cVH8&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=24",
        "type": "video"
      },
      {
        "title": "Greedy Algs. II & Intro to NP Completeness",
        "url": "https://youtu.be/qcGnJ47Smlo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&t=2939",
        "type": "video"
      }
    ]
  },
  "ewXUHpOnjm8YrLhce1dAQ": {
    "title": "NP",
    "description": "The NP in NP class stands for Non-deterministic Polynomial Time. It is the collection of decision problems that can be solved by a non-deterministic machine in polynomial time.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Trying to understand P vs NP vs NP Complete vs NP Hard",
        "url": "https://softwareengineering.stackexchange.com/questions/308178/trying-to-understand-p-vs-np-vs-np-complete-vs-np-hard",
        "type": "article"
      },
      {
        "title": "Complexity: P, NP, NP-completeness, Reductions",
        "url": "https://www.youtube.com/watch?v=eHZifpgyH_4&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=22",
        "type": "video"
      },
      {
        "title": "Complexity: Approximation Algorithms",
        "url": "https://www.youtube.com/watch?v=MEz1J9wY2iM&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=24",
        "type": "video"
      },
      {
        "title": "Complexity: Fixed-Parameter Algorithms",
        "url": "https://www.youtube.com/watch?v=4q-jmGrmxKs&index=25&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp",
        "type": "video"
      },
      {
        "title": "Lecture 23: Computational Complexity",
        "url": "https://www.youtube.com/watch?v=moPtwq_cVH8&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=24",
        "type": "video"
      },
      {
        "title": "Greedy Algs. II & Intro to NP Completeness",
        "url": "https://youtu.be/qcGnJ47Smlo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&t=2939",
        "type": "video"
      },
      {
        "title": "NP Completeness II & Reductions",
        "url": "https://www.youtube.com/watch?v=e0tGC6ZQdQE&index=16&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm",
        "type": "video"
      },
      {
        "title": "NP Completeness III",
        "url": "https://www.youtube.com/watch?v=fCX1BGT3wjE&index=17&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm",
        "type": "video"
      },
      {
        "title": "NP Completeness IV",
        "url": "https://www.youtube.com/watch?v=NKLDp3Rch3M&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&index=18",
        "type": "video"
      }
    ]
  },
  "mJJ8DGUpBuHEJ7I6UTy1T": {
    "title": "NP Hard",
    "description": "An NP-hard problem is at least as hard as the hardest problem in NP and it is the class of the problems such that every problem in NP reduces to NP-hard.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Trying to understand P vs NP vs NP Complete vs NP Hard",
        "url": "https://softwareengineering.stackexchange.com/questions/308178/trying-to-understand-p-vs-np-vs-np-complete-vs-np-hard",
        "type": "article"
      },
      {
        "title": "Complexity: P, NP, NP-completeness, Reductions",
        "url": "https://www.youtube.com/watch?v=eHZifpgyH_4&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=22",
        "type": "video"
      },
      {
        "title": "Complexity: Approximation Algorithms",
        "url": "https://www.youtube.com/watch?v=MEz1J9wY2iM&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=24",
        "type": "video"
      },
      {
        "title": "Complexity: Fixed-Parameter Algorithms",
        "url": "https://www.youtube.com/watch?v=4q-jmGrmxKs&index=25&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp",
        "type": "video"
      },
      {
        "title": "Lecture 23: Computational Complexity",
        "url": "https://www.youtube.com/watch?v=moPtwq_cVH8&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=24",
        "type": "video"
      },
      {
        "title": "Greedy Algs. II & Intro to NP Completeness",
        "url": "https://youtu.be/qcGnJ47Smlo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&t=2939",
        "type": "video"
      },
      {
        "title": "NP Completeness II & Reductions",
        "url": "https://www.youtube.com/watch?v=e0tGC6ZQdQE&index=16&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm",
        "type": "video"
      },
      {
        "title": "NP Completeness III",
        "url": "https://www.youtube.com/watch?v=fCX1BGT3wjE&index=17&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm",
        "type": "video"
      },
      {
        "title": "NP Completeness IV",
        "url": "https://www.youtube.com/watch?v=NKLDp3Rch3M&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&index=18",
        "type": "video"
      }
    ]
  },
  "Lwkz7qozXRlVNA20zJbSw": {
    "title": "NP Complete",
    "description": "A problem is NP-complete if it is both NP and NP-hard. NP-complete problems are the hard problems in NP.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Trying to understand P vs NP vs NP Complete vs NP Hard",
        "url": "https://softwareengineering.stackexchange.com/questions/308178/trying-to-understand-p-vs-np-vs-np-complete-vs-np-hard",
        "type": "article"
      },
      {
        "title": "Complexity: P, NP, NP-completeness, Reductions",
        "url": "https://www.youtube.com/watch?v=eHZifpgyH_4&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=22",
        "type": "video"
      },
      {
        "title": "P vs. NP and the Computational Complexity Zoo",
        "url": "https://www.youtube.com/watch?v=YX40hbAHx3s",
        "type": "video"
      },
      {
        "title": "Greedy Algs. II & Intro to NP Completeness",
        "url": "https://youtu.be/qcGnJ47Smlo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&t=2939",
        "type": "video"
      },
      {
        "title": "NP Completeness II & Reductions",
        "url": "https://www.youtube.com/watch?v=e0tGC6ZQdQE&index=16&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm",
        "type": "video"
      },
      {
        "title": "NP Completeness III",
        "url": "https://www.youtube.com/watch?v=fCX1BGT3wjE&index=17&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm",
        "type": "video"
      },
      {
        "title": "NP Completeness IV",
        "url": "https://www.youtube.com/watch?v=NKLDp3Rch3M&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&index=18",
        "type": "video"
      }
    ]
  },
  "0btHNkzWL1w_-pUgU_k2y": {
    "title": "P = NP",
    "description": "The P = NP problem is one of the most famous problems in computer science. It asks whether a problem that can be solved in polynomial time on a non-deterministic machine (i.e., the problem is in NP) can also be solved in polynomial time on a deterministic machine (i.e., the problem is in P).\n\nIf you can find a polynomial-time solution to an NP-complete problem, then all problems in NP can be solved in polynomial time. This shows that P = NP.\n\nIf you can prove for any single NP-complete problem that it is only solvable in exponential time, then all NP-complete problems are only solvable in exponential time. This shows that P ≠ NP.\n\nSo far, we don't know whether P = NP or P ≠ NP.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Whats P=NP?, and why is it such a famous question?",
        "url": "https://stackoverflow.com/questions/111307/whats-p-np-and-why-is-it-such-a-famous-question",
        "type": "article"
      }
    ]
  },
  "ZG-hWjVoS3p9XfrtBL0sD": {
    "title": "Travelling Salesman Problem",
    "description": "The Travelling Salesman Problem (TSP) is a classic problem in computer science. It is a problem that is NP-complete, which means that it is a problem that is hard to solve. It is also a problem that is used to test the efficiency of algorithms.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Traveling Salesman Problem",
        "url": "https://en.wikipedia.org/wiki/Travelling_salesman_problem",
        "type": "article"
      },
      {
        "title": "What is the Traveling Salesman Problem?",
        "url": "https://www.youtube.com/watch?v=1pmBjIZ20pE",
        "type": "video"
      },
      {
        "title": "4.7 Traveling Salesperson Problem - Dynamic Programming",
        "url": "https://www.youtube.com/watch?v=XaXsJJh-Q5Y",
        "type": "video"
      },
      {
        "title": "Traveling Salesman Problem | Dynamic Programming | Graph Theory",
        "url": "https://www.youtube.com/watch?v=cY4HiiFHO1o",
        "type": "video"
      }
    ]
  },
  "yHeCRPhfAOWiggZeUHPU9": {
    "title": "Knapsack Problem",
    "description": "KnapSack Problem is a classic problem in computer science. It is a problem in which we are given a set of items, each with a weight and a value, and we need to determine which items to include in a collection so that the total weight is less than or equal to a given limit and the total value is as large as possible.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "How to solve the Knapsack Problem with dynamic programming",
        "url": "https://medium.com/@fabianterh/how-to-solve-the-knapsack-problem-with-dynamic-programming-eb88c706d3cf",
        "type": "article"
      },
      {
        "title": "3.1 Knapsack Problem - Greedy Method",
        "url": "https://www.youtube.com/watch?v=oTTzNMHM05I",
        "type": "video"
      }
    ]
  },
  "4QVVYjDODMWsjnrE-4UBs": {
    "title": "Longest Path Problem",
    "description": "Longest path problem is a problem that asks us to find the longest path in a graph.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Shortest/Longest path on a Directed Acyclic Graph (DAG) | Graph Theory",
        "url": "https://www.youtube.com/watch?v=TXkDpqjDMHA",
        "type": "video"
      },
      {
        "title": "Longest Simple Path - Intro to Algorithms",
        "url": "https://www.youtube.com/watch?v=lRH0tax5dFA",
        "type": "video"
      }
    ]
  },
  "4qUVacMEz3XFiL_dMre6P": {
    "title": "Tries",
    "description": "Tries are a data structure that can be used to store strings. The idea is to store the characters of the string in a tree-like structure, where each node of the tree represents a single character. We can use this structure to store strings in a way that allows us to quickly search for strings with a common prefix.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "0. Tries - Coursera",
        "url": "https://www.coursera.org/learn/algorithms-part2/home/week/4",
        "type": "course"
      },
      {
        "title": "1. R Way Tries",
        "url": "https://www.coursera.org/learn/algorithms-part2/lecture/CPVdr/r-way-tries",
        "type": "course"
      },
      {
        "title": "2. Ternary Search Tries",
        "url": "https://www.coursera.org/learn/algorithms-part2/lecture/yQM8K/ternary-search-tries",
        "type": "course"
      },
      {
        "title": "3. Character Based Operations",
        "url": "https://www.coursera.org/learn/algorithms-part2/lecture/jwNmV/character-based-operations",
        "type": "course"
      },
      {
        "title": "Tries - DataStructure Notes",
        "url": "http://www.cs.yale.edu/homes/aspnes/classes/223/notes.html#Tries",
        "type": "article"
      },
      {
        "title": "The Trie: A Neglected Data Structure",
        "url": "https://www.toptal.com/java/the-trie-a-neglected-data-structure",
        "type": "article"
      },
      {
        "title": "TopCoder - Using Tries",
        "url": "https://www.topcoder.com/thrive/articles/Using%20Tries",
        "type": "article"
      },
      {
        "title": "Stanford Lecture (real world use case)",
        "url": "https://www.youtube.com/watch?v=TJ8SkcUSdbU",
        "type": "video"
      },
      {
        "title": "MIT, Advanced Data Structures, Strings (can get pretty obscure about halfway through)",
        "url": "https://www.youtube.com/watch?v=NinWEPPrkDQ&index=16&list=PLUl4u3cNGP61hsJNdULdudlRL493b-XZf",
        "type": "video"
      }
    ]
  },
  "7DF3UhefOSqqTuccH8c8X": {
    "title": "Balanced Search Trees",
    "description": "Balanced search trees are a type of data structure that allow for fast insertion, deletion, and lookup of data. They are a type of self-balancing binary search tree, which means that they are a binary tree that maintains the binary search tree property while also keeping the tree balanced. This means that the tree is always approximately balanced, which allows for fast insertion, deletion, and lookup of data.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Self-balancing Binary Search Tree - Wikipedia",
        "url": "https://en.wikipedia.org/wiki/Self-balancing_binary_search_tree",
        "type": "article"
      },
      {
        "title": "Balanced Search Trees Operations and Applications 11 min",
        "url": "https://www.youtube.com/watch?v=IbNZ-x1I2IM",
        "type": "video"
      },
      {
        "title": "Balanced binary search tree rotations",
        "url": "https://www.youtube.com/watch?v=q4fnJZr8ztY",
        "type": "video"
      }
    ]
  },
  "OUistS7H7hQQxVV-lOg39": {
    "title": "AVL Trees",
    "description": "AVL trees are a type of self-balancing binary search tree. They are named after their inventors, Adelson-Velskii and Landis. AVL trees are the most popular self-balancing binary search tree.\n\nIn practice: From what I can tell, these aren't used much in practice, but I could see where they would be: The AVL tree is another structure supporting O(log n) search, insertion, and removal. It is more rigidly balanced than red–black trees, leading to slower insertion and removal but faster retrieval. This makes it attractive for data structures that may be built once and loaded without reconstruction, such as language dictionaries (or program dictionaries, such as the opcodes of an assembler or interpreter)\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "AVL Trees",
        "url": "https://www.coursera.org/learn/data-structures/lecture/Qq5E0/avl-trees",
        "type": "course"
      },
      {
        "title": "AVL Tree Implementation",
        "url": "https://www.coursera.org/learn/data-structures/lecture/PKEBC/avl-tree-implementation",
        "type": "course"
      },
      {
        "title": "Split And Merge",
        "url": "https://www.coursera.org/learn/data-structures/lecture/22BgE/split-and-merge",
        "type": "course"
      },
      {
        "title": "AVL Tree - Programiz",
        "url": "https://www.programiz.com/dsa/avl-tree",
        "type": "article"
      },
      {
        "title": "MIT AVL Trees / AVL Sort",
        "url": "https://www.youtube.com/watch?v=FNeL18KsWPc&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=6",
        "type": "video"
      }
    ]
  },
  "eOL0_SzxBn7_xhNcBDi2D": {
    "title": "Red / Black Trees",
    "description": "In computer science, a red–black tree is a kind of self-balancing binary search tree. Each node stores an extra bit representing \"color\", used to ensure that the tree remains balanced during insertions and deletions.\n\nThese are a translation of a 2-3 tree (see below).\n\nIn practice: Red–black trees offer worst-case guarantees for insertion time, deletion time, and search time. Not only does this make them valuable in time-sensitive applications such as real-time applications, but it makes them valuable building blocks in other data structures which provide worst-case guarantees; for example, many data structures used in computational geometry can be based on red–black trees, and the Completely Fair Scheduler used in current Linux kernels uses red–black trees. In the version 8 of Java, the Collection HashMap has been modified such that instead of using a LinkedList to store identical elements with poor hashcodes, a Red-Black tree is used.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Red-Black Tree - Wikipedia",
        "url": "https://en.wikipedia.org/wiki/Red%E2%80%93black_tree",
        "type": "article"
      },
      {
        "title": "An Introduction To Binary Search And Red Black Tree",
        "url": "https://www.topcoder.com/thrive/articles/An%20Introduction%20to%20Binary%20Search%20and%20Red-Black%20Trees",
        "type": "article"
      },
      {
        "title": "Red-Black Trees (playlist) in 30 minutes",
        "url": "https://www.youtube.com/playlist?list=PL9xmBV_5YoZNqDI8qfOZgzbqahCUmUEin",
        "type": "video"
      },
      {
        "title": "Aduni - Algorithms - Lecture 4 (link jumps to starting point)",
        "url": "https://youtu.be/1W3x0f_RmUo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&t=3871",
        "type": "video"
      },
      {
        "title": "Aduni - Algorithms - Lecture 5",
        "url": "https://www.youtube.com/watch?v=hm2GHwyKF1o&list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&index=5",
        "type": "video"
      }
    ]
  },
  "3jiV9R82qxpqIGfpEq_wK": {
    "title": "2 3 Search Trees",
    "description": "In practice: 2-3 trees have faster inserts at the expense of slower searches (since height is more compared to AVL trees).\n\nYou would use 2-3 tree very rarely because its implementation involves different types of nodes. Instead, people use Red Black trees.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "23-Tree Intuition and Definition",
        "url": "https://www.youtube.com/watch?v=C3SsdUqasD4&list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&index=2",
        "type": "video"
      },
      {
        "title": "Binary View of 23-Tree",
        "url": "https://www.youtube.com/watch?v=iYvBtGKsqSg&index=3&list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6",
        "type": "video"
      },
      {
        "title": "2-3 Trees (student recitation)",
        "url": "https://www.youtube.com/watch?v=TOb1tuEZ2X4&index=5&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp",
        "type": "video"
      }
    ]
  },
  "2-3-4-trees@IaPd_zuLbiOCwoSHQLoIG.md": {
    "title": "2 3 4 Trees",
    "description": "",
    "links": []
  },
  "UOYeM-hqIKCrB9hGez4Q_": {
    "title": "K-ary / M-ary Tree",
    "description": "Note: the N or K is the branching factor (max branches)\n\nBinary trees are a 2-ary tree, with branching factor = 2\n\n2-3 trees are 3-ary\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "K-Ary Tree",
        "url": "https://en.wikipedia.org/wiki/K-ary_tree",
        "type": "article"
      }
    ]
  },
  "s0Pi6CemUUsmZSEu2j2gH": {
    "title": "B-Tree",
    "description": "Fun fact: it's a mystery, but the B could stand for Boeing, Balanced, or Bayer (co-inventor).\n\nIn Practice: B-Trees are widely used in databases. Most modern filesystems use B-trees (or Variants). In addition to its use in databases, the B-tree is also used in filesystems to allow quick random access to an arbitrary block in a particular file. The basic problem is turning the file block i address into a disk block (or perhaps to a cylinder-head-sector) address\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "B-Tree - Wikipedia",
        "url": "https://en.wikipedia.org/wiki/B-tree",
        "type": "article"
      },
      {
        "title": "B-Tree Datastructure",
        "url": "http://btechsmartclass.com/data_structures/b-trees.html",
        "type": "article"
      },
      {
        "title": "Introduction to B-Trees",
        "url": "https://www.youtube.com/watch?v=I22wEC1tTGo&list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6&index=6",
        "type": "video"
      },
      {
        "title": "B-Tree Definition and Insertion",
        "url": "https://www.youtube.com/watch?v=s3bCdZGrgpA&index=7&list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6",
        "type": "video"
      },
      {
        "title": "B-Tree Deletion",
        "url": "https://www.youtube.com/watch?v=svfnVhJOfMc&index=8&list=PLA5Lqm4uh9Bbq-E0ZnqTIa8LRaL77ica6",
        "type": "video"
      },
      {
        "title": "B-Trees (playlist) in 26 minutes",
        "url": "https://www.youtube.com/playlist?list=PL9xmBV_5YoZNFPPv98DjTdD9X6UI9KMHz",
        "type": "video"
      }
    ]
  },
  "w-fvEiSJysywR3AOAB0ve": {
    "title": "System Design",
    "description": "System design is the process of defining the architecture, modules, interfaces, and data for a system to satisfy specified requirements. It is a very broad topic, and there are many ways to approach it.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "System Design Primer",
        "url": "https://github.com/donnemartin/system-design-primer",
        "type": "opensource"
      },
      {
        "title": "System Design: The Complete Course",
        "url": "https://dev.to/karanpratapsingh/system-design-the-complete-course-10fo",
        "type": "article"
      },
      {
        "title": "Explore top posts about Career",
        "url": "https://app.daily.dev/tags/career?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "System Design 101",
        "url": "https://www.youtube.com/watch?v=Y-Gl4HEyeUQ",
        "type": "video"
      },
      {
        "title": "Scaling the Unscalable",
        "url": "https://www.youtube.com/watch?v=a2rcgzludDU",
        "type": "video"
      },
      {
        "title": "System Design interview: Scale to 1 million users",
        "url": "https://www.youtube.com/watch?v=YkGHxOg9d3M",
        "type": "video"
      }
    ]
  },
  "-34WGppX6QC5fkCvfCghp": {
    "title": "Horizontal vs Vertical Scaling",
    "description": "Horizontal scaling is the process of adding more machines to your system. This is also known as scaling out. Vertical scaling is the process of adding more power to a single machine. This is also known as scaling up.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Scaling Horizontally vs. Scaling Vertically",
        "url": "https://www.digitalocean.com/resources/article/horizontal-scaling-vs-vertical-scaling",
        "type": "article"
      },
      {
        "title": "System Design Basics: Horizontal vs. Vertical Scaling",
        "url": "https://www.youtube.com/watch?v=xpDnVSmNFX0",
        "type": "video"
      },
      {
        "title": "Vertical vs. Horizontal Scaling for Database Servers",
        "url": "https://www.youtube.com/watch?v=R99R-SNbo9g",
        "type": "video"
      }
    ]
  },
  "xDiS0HmrEoPjkQg9x2O3o": {
    "title": "Load Balancing",
    "description": "Load balancing is the process of distributing network or application traffic across a cluster of servers. Load balancing is used to improve responsiveness and reliability of applications, maximize throughput, minimize response time, and avoid overload of any single server.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "What is Load Balancing? | How load balancers work",
        "url": "https://www.cloudflare.com/learning/performance/what-is-load-balancing/",
        "type": "article"
      },
      {
        "title": "Load Balancers 101",
        "url": "https://www.youtube.com/watch?v=galcDRNd5Ow",
        "type": "video"
      },
      {
        "title": "What is Load Balancing?",
        "url": "https://www.youtube.com/watch?v=gGLophKzJs8",
        "type": "video"
      }
    ]
  },
  "wAsZ-M5N9ERufQnBaXbAE": {
    "title": "Clustering",
    "description": "At a high level, a computer cluster is a group of two or more computers, or nodes, that run in parallel to achieve a common goal. This allows workloads consisting of a high number of individual, parallelizable tasks to be distributed among the nodes in the cluster. As a result, these tasks can leverage the combined memory and processing power of each computer to increase overall performance.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "System Design: Clustering",
        "url": "https://dev.to/karanpratapsingh/system-design-clustering-3726",
        "type": "article"
      }
    ]
  },
  "4u5w9QCptLWuY9O7_UU8V": {
    "title": "Caching",
    "description": "Caching is a way of storing data in a temporary storage to make future requests faster. It is one of the most important tools in the computer science toolbox.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "System Design - Caching",
        "url": "https://dev.to/karanpratapsingh/system-design-the-complete-course-10fo#caching",
        "type": "article"
      },
      {
        "title": "What is Caching | System Design Basics",
        "url": "https://www.youtube.com/watch?v=joifNgoXXFk",
        "type": "video"
      }
    ]
  },
  "r8V9bZpc98SrLvXc070bZ": {
    "title": "CDN",
    "description": "A CDN is a network of servers that are distributed geographically. The servers are connected to each other and to the internet. The servers are used to deliver content to users. The content is delivered to the user from the server that is closest to the user. This is done to reduce latency and improve the performance of the content delivery.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "What is a CDN?",
        "url": "https://www.cloudflare.com/learning/cdn/what-is-a-cdn/",
        "type": "article"
      },
      {
        "title": "Content Delivery Network (CDN) - System Design",
        "url": "https://dev.to/karanpratapsingh/system-design-the-complete-course-10fo#content-delivery-network-cdn",
        "type": "article"
      },
      {
        "title": "Content Delivery Networks",
        "url": "https://www.youtube.com/watch?v=6DXEPcXKQNY",
        "type": "video"
      }
    ]
  },
  "qLLJ_ehC8tSRfXsorYMQz": {
    "title": "Proxy",
    "description": "A proxy server is an intermediary piece of hardware/software sitting between the client and the backend server. It receives requests from clients and relays them to the origin servers. Typically, proxies are used to filter requests, log requests, or sometimes transform requests (by adding/removing headers, encrypting/decrypting, or compression).\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Proxy Servers",
        "url": "https://roadmap.sh/guides/proxy-servers",
        "type": "article"
      },
      {
        "title": "Proxy - System Design",
        "url": "https://dev.to/karanpratapsingh/system-design-the-complete-course-10fo#proxy",
        "type": "article"
      }
    ]
  },
  "GZI8EsEqiMJX3fSbO_E-7": {
    "title": "CAP Theorem",
    "description": "The CAP theorem states that it is impossible for a distributed data store to simultaneously provide more than two out of Consistency, Availability and Partition Tolerance.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "CAP Theorem",
        "url": "https://en.wikipedia.org/wiki/CAP_theorem",
        "type": "article"
      },
      {
        "title": "What is CAP Theorem?",
        "url": "https://www.youtube.com/watch?v=_RbsFXWRZ10",
        "type": "video"
      }
    ]
  },
  "LCPEzpyAuHY3ggN3nYrNN": {
    "title": "Queues",
    "description": "Messaging queues are a common way to decouple systems. They are used to decouple the producer of a message from the consumer of a message. This allows the producer to send a message and not have to wait for the consumer to process it. It also allows the consumer to process the message at their own pace.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Message Queues - System Design",
        "url": "https://dev.to/karanpratapsingh/system-design-the-complete-course-10fo#message-queues",
        "type": "article"
      },
      {
        "title": "What is a Message Queue?",
        "url": "https://www.youtube.com/watch?v=xErwDaOc-Gs",
        "type": "video"
      },
      {
        "title": "What is a Message Queue and Where is it used?",
        "url": "https://www.youtube.com/watch?v=oUJbuFMyBDk",
        "type": "video"
      }
    ]
  },
  "X1wv7xV69IEzepg8bF8oZ": {
    "title": "Architectural Styles",
    "description": "Architectural patterns are the fundamental organization of a system, defining how the system is composed and how its components interact. Architectural patterns are identified by their name, like client-server, peer-to-peer, and layered.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "List of Software Architecture Styles and Patterns",
        "url": "https://en.wikipedia.org/wiki/List_of_software_architecture_styles_and_patterns",
        "type": "article"
      }
    ]
  },
  "Kvz3Sn7L8CxP5ZXO1hlcU": {
    "title": "REST",
    "description": "REST, or REpresentational State Transfer, is an architectural style for providing standards between computer systems on the web, making it easier for systems to communicate with each other.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "What is a REST API?",
        "url": "https://www.redhat.com/en/topics/api/what-is-a-rest-api",
        "type": "article"
      },
      {
        "title": "Roy Fieldings dissertation chapter, Representational State Transfer (REST)",
        "url": "https://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm",
        "type": "article"
      },
      {
        "title": "Learn REST: A RESTful Tutorial",
        "url": "https://restapitutorial.com/",
        "type": "article"
      },
      {
        "title": "Explore top posts about REST API",
        "url": "https://app.daily.dev/tags/rest-api?ref=roadmapsh",
        "type": "article"
      }
    ]
  },
  "DeE_dZecLmKCjePovTfFS": {
    "title": "GraphQL",
    "description": "GraphQL is a query language for APIs and a runtime for fulfilling those queries with your existing data. GraphQL provides a complete and understandable description of the data in your API, gives clients the power to ask for exactly what they need and nothing more, makes it easier to evolve APIs over time, and enables powerful developer tools.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Visit Dedicated GraphQL Roadmap",
        "url": "https://roadmap.sh/graphql",
        "type": "article"
      },
      {
        "title": "GraphQL",
        "url": "https://graphql.org/",
        "type": "article"
      },
      {
        "title": "GraphQL Documentation",
        "url": "https://graphql.org/learn/",
        "type": "article"
      },
      {
        "title": "Apollo GraphQL Tutorials",
        "url": "https://www.apollographql.com/tutorials/",
        "type": "article"
      },
      {
        "title": "Explore top posts about GraphQL",
        "url": "https://app.daily.dev/tags/graphql?ref=roadmapsh",
        "type": "article"
      }
    ]
  },
  "M4vdwAbjLPrLjWUsG_P1I": {
    "title": "gRPC",
    "description": "gRPC is a platform agnostic serialization protocol that is used to communicate between services. Designed by Google in 2015, it is a modern alternative to REST APIs. It is a binary protocol that uses HTTP/2 as a transport layer. It is a high performance, open source, general-purpose RPC framework that puts mobile and HTTP/2 first.\n\nIt's main use case is for communication between two different languages within the same application. You can use Python to communicate with Go, or Java to communicate with C#.\n\ngRPC uses the protocol buffer language to define the structure of the data that is\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "gRPC Website",
        "url": "https://grpc.io/",
        "type": "article"
      },
      {
        "title": "gRPC Introduction",
        "url": "https://grpc.io/docs/what-is-grpc/introduction/",
        "type": "article"
      },
      {
        "title": "gRPC Core Concepts",
        "url": "https://grpc.io/docs/what-is-grpc/core-concepts/",
        "type": "article"
      },
      {
        "title": "Explore top posts about gRPC",
        "url": "https://app.daily.dev/tags/grpc?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Stephane Maarek - gRPC Introduction",
        "url": "https://youtu.be/XRXTsQwyZSU",
        "type": "video"
      }
    ]
  },
  "YMO9oD_sbzyDZPNU2xZwe": {
    "title": "Cloud Design Patterns",
    "description": "These design patterns are useful for building reliable, scalable, secure applications in the cloud.\n\nThe link below has cloud design patterns where each pattern describes the problem that the pattern addresses, considerations for applying the pattern, and an example based on Microsoft Azure. Most patterns include code samples or snippets that show how to implement the pattern on Azure. However, most patterns are relevant to any distributed system, whether hosted on Azure or other cloud platforms.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Cloud Design Patterns",
        "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/",
        "type": "article"
      },
      {
        "title": "Explore top posts about Cloud",
        "url": "https://app.daily.dev/tags/cloud?ref=roadmapsh",
        "type": "article"
      }
    ]
  },
  "XeJi6TwpI5Uaszj00Uv_2": {
    "title": "Long Polling",
    "description": "Long polling is a technique used to implement server push functionality over HTTP. It is a method of opening a request on the server and keeping it open until an event occurs, at which point the server responds. This is in contrast to a regular HTTP request, where the server responds immediately with whatever data is available at the time.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Long Polling",
        "url": "https://javascript.info/long-polling",
        "type": "article"
      },
      {
        "title": "What are Long-Polling, Websockets, Server-Sent Events (SSE) and Comet?",
        "url": "https://stackoverflow.com/questions/11077857/what-are-long-polling-websockets-server-sent-events-sse-and-comet",
        "type": "article"
      }
    ]
  },
  "gGmNJ8dK28iqrlQHPz6md": {
    "title": "Short Polling",
    "description": "In short polling, the client requests information from the server. The server processes the request. If data is available for the request, server responds to the request with the required information. However, if the server has no data available for the client, server returns an empty response. In both the situation, the connection will be closed after returning the response. Clients keep issuing new requests even after server sends the empty responses. This mechanism increases the network cost on the server.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "What are Long-Polling, Websockets, Server-Sent Events (SSE) and Comet?",
        "url": "https://stackoverflow.com/questions/11077857/what-are-long-polling-websockets-server-sent-events-sse-and-comet",
        "type": "article"
      }
    ]
  },
  "bVjI14VismTHNCyA0mEBP": {
    "title": "Web Sockets",
    "description": "Web sockets are a bidirectional communication protocol between a client and a server. They are used for real-time applications like chat, multiplayer games, and live data updates. Web sockets are also used to establish a connection between a server and a client. This connection is then used to send data in both directions.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "WebSockets",
        "url": "https://en.wikipedia.org/wiki/WebSocket",
        "type": "article"
      },
      {
        "title": "Web Sockets API",
        "url": "https://developer.mozilla.org/en-US/docs/Web/API/WebSockets_API",
        "type": "article"
      }
    ]
  },
  "JckRqZA8C6IqQLPpTCgf4": {
    "title": "SSE",
    "description": "Server-Sent Events is a server push technology enabling a client to receive automatic updates from a server via an HTTP connection, and describes how servers can initiate data transmission towards clients once an initial client connection has been established.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "What is Server-Sent Events (SSE) and how to implement it?",
        "url": "https://medium.com/yemeksepeti-teknoloji/what-is-server-sent-events-sse-and-how-to-implement-it-904938bffd73",
        "type": "article"
      },
      {
        "title": "Using server-sent events",
        "url": "https://developer.mozilla.org/en-US/docs/Web/API/Server-sent_events/Using_server-sent_events",
        "type": "article"
      },
      {
        "title": "Explore top posts about Cryptography",
        "url": "https://app.daily.dev/tags/cryptography?ref=roadmapsh",
        "type": "article"
      }
    ]
  },
  "zvlTQ0A-My4QDrslp_lru": {
    "title": "Databases",
    "description": "A database is a collection of useful data of one or more related organizations structured in a way to make data an asset to the organization. A database management system is a software designed to assist in maintaining and extracting large collections of data in a timely fashion.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "What is a Database?",
        "url": "https://www.oracle.com/database/what-is-database/",
        "type": "article"
      },
      {
        "title": "What are Databases?",
        "url": "https://www.prisma.io/dataguide/intro/what-are-databases",
        "type": "article"
      },
      {
        "title": "Explore top posts about Backend Development",
        "url": "https://app.daily.dev/tags/backend?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "DBMS by Stanford",
        "url": "https://www.youtube.com/watch?v=D-k-h0GuFmE&list=PL9ysvtVnryGpnIj9rcIqNDxakUn6v72Hm",
        "type": "video"
      }
    ]
  },
  "nprZscHdC_RdRIcGeGyVk": {
    "title": "SQL vs NoSQL Databases",
    "description": "SQL stands for Structured Query Language. It's used for relational databases. A SQL database is a collection of tables that stores a specific set of structured data. Some examples are PostgreSQL, MySQL, MariaDB etc.\n\nNoSQL stands for Not Only SQL. It's used for non-relational databases. A NoSQL database is a collection of collections that stores a specific set of unstructured data. Some examples are MongoDB, CouchDB, Redis etc.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Explore top posts about NoSQL",
        "url": "https://app.daily.dev/tags/nosql?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "SQL vs. NoSQL: Whats the difference?",
        "url": "https://www.youtube.com/watch?v=Q5aTUc7c4jg",
        "type": "video"
      },
      {
        "title": "Database Design Tips | Choosing the Best Database in a System Design Interview",
        "url": "https://www.youtube.com/watch?v=cODCpXtPHbQ&t=22s",
        "type": "video"
      },
      {
        "title": "NoSQL vs SQL – Which Type of Database Should You Use?",
        "url": "https://www.youtube.com/watch?v=FzlpwoeSrE0",
        "type": "video"
      }
    ]
  },
  "Rw7QjLC8hLtXSwmU_9kHC": {
    "title": "Normalization / Denormalization",
    "description": "Database normalization is a process used to organize a database into tables and columns. The idea is that a table should be about a specific topic and that only those columns which support that topic are included. This limits the number of duplicate data contained within your database. This makes the database more flexible by eliminating issues stemming from database modifications.\n\nDenormalization is the opposite of normalization. It is the process of adding redundant data to a database to improve read performance. This is done by adding duplicate data into multiple tables to avoid expensive joins. This is done at the expense of increased storage and decreased write performance.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Normalization vs. Denormalization | Events and Event Streaming",
        "url": "https://www.youtube.com/watch?v=sDU94hraq8g",
        "type": "video"
      },
      {
        "title": "Normalization - 1NF, 2NF, 3NF and 4NF",
        "url": "https://www.youtube.com/watch?v=UrYLYV7WSHM",
        "type": "video"
      }
    ]
  },
  "XnxxEmr2TyW2kOpB4gtR5": {
    "title": "Entity-Relationship Model",
    "description": "Entity relationship model is a high-level data model that describes the logical structure of a database. It is a graphical representation of entities and their relationships to each other, typically used in modeling the organization of data within databases or information systems.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Entity Relationship Diagram (ERD) Tutorial - Part 1",
        "url": "https://www.youtube.com/watch?v=QpdhBUYk7Kk",
        "type": "video"
      },
      {
        "title": "Entity Relationship Diagram (ERD) Tutorial - Part 2",
        "url": "https://www.youtube.com/watch?v=-CuY5ADwn24",
        "type": "video"
      }
    ]
  },
  "ii1vF74u3yrFNlw_21b3B": {
    "title": "DDL",
    "description": "DDL or Data Definition Language actually consists of the SQL commands that can be used to define the database schema. It simply deals with descriptions of the database schema and is used to create and modify the structure of database objects in the database. DDL is a set of SQL commands used to create, modify, and delete database structures but not data. These commands are normally not used by a general user, who should be accessing the database via an application.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "DDL",
        "url": "https://en.wikipedia.org/wiki/Data_definition_language",
        "type": "article"
      }
    ]
  },
  "tcQSH-eAvJUZuePTDjAIb": {
    "title": "DML",
    "description": "The SQL commands that manipulate data in the database belong to DML, or Data Manipulation Language, and this includes most of the SQL statements. DCL is the component of the SQL statement that controls access to data and to the database. Basically, DCL statements are grouped with DML statements.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "DML: Data Manipulation Language",
        "url": "https://satoricyber.com/glossary/dml-data-manipulation-language",
        "type": "article"
      },
      {
        "title": "Difference Between DDL and DML",
        "url": "https://appmaster.io/blog/difference-between-ddl-and-dml",
        "type": "article"
      }
    ]
  },
  "05lkb3B86Won7Rkf-8DeD": {
    "title": "DQL",
    "description": "DQL statements are used for performing queries on the data within schema objects. The purpose of the DQL Command is to get some schema relation based on the query passed to it. We can define DQL as follows it is a component of SQL statement that allows getting data from the database and imposing order upon it. It includes the SELECT statement. This command allows getting the data out of the database to perform operations with it. When a SELECT is fired against a table or tables the result is compiled into a further temporary table, which is displayed or perhaps received by the program i.e. a front-end.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Data Query Language",
        "url": "https://en.wikipedia.org/wiki/Data_query_language",
        "type": "article"
      }
    ]
  },
  "4bUmfuP2qgcli8I2Vm9zh": {
    "title": "DCL",
    "description": "DCL includes commands such as GRANT and REVOKE which mainly deal with the rights, permissions, and other controls of the database system.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "DCL",
        "url": "https://en.wikipedia.org/wiki/Data_Control_Language",
        "type": "article"
      }
    ]
  },
  "_sm63rZNKoibVndeNgOpW": {
    "title": "Locking",
    "description": "Locks are used to prevent data from being modified by multiple processes at the same time. This is important because if two processes are modifying the same data at the same time, the data can become corrupted. Locks are used to prevent this from happening.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Locking in Databases and Isolation Mechanisms",
        "url": "https://medium.com/inspiredbrilliance/what-are-database-locks-1aff9117c290",
        "type": "article"
      },
      {
        "title": "Understanding Database Lock Timeouts and Deadlocks",
        "url": "https://www.dbta.com/Columns/DBA-Corner/Understanding-Database-Lock-Timeouts-and-Deadlocks-148659.aspx",
        "type": "article"
      },
      {
        "title": "Row-Level Database Locks Explained - (Read vs Exclusive)",
        "url": "https://www.youtube.com/watch?v=nuBi2XbHH18",
        "type": "video"
      }
    ]
  },
  "W5B-v-BFcCRmuN0L1m6PI": {
    "title": "ACID Model",
    "description": "ACID are the four properties of any database system that help in making sure that we are able to perform the transactions in a reliable manner. It's an acronym which refers to the presence of four properties: atomicity, consistency, isolation and durability\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "What is ACID Compliant Database?",
        "url": "https://retool.com/blog/whats-an-acid-compliant-database/",
        "type": "article"
      },
      {
        "title": "What is ACID Compliance?: Atomicity, Consistency, Isolation",
        "url": "https://fauna.com/blog/what-is-acid-compliance-atomicity-consistency-isolation",
        "type": "article"
      },
      {
        "title": "ACID Explained: Atomic, Consistent, Isolated & Durable",
        "url": "https://www.youtube.com/watch?v=yaQ5YMWkxq4",
        "type": "video"
      }
    ]
  },
  "q3nRhTYS5wg9tYnQe2sCF": {
    "title": "BASE",
    "description": "The rise in popularity of NoSQL databases provided a flexible and fluidity with ease to manipulate data and as a result, a new database model was designed, reflecting these properties. The acronym BASE is slightly more confusing than ACID but however, the words behind it suggest ways in which the BASE model is different and acronym BASE stands for:-\n\n*   **B**asically **A**vailable\n*   **S**oft state\n*   **E**ventual consistency\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "ACID vs. BASE Database Model",
        "url": "https://phoenixnap.com/kb/acid-vs-base",
        "type": "article"
      },
      {
        "title": "What Is BASE in Database Engineering?",
        "url": "https://www.lifewire.com/abandoning-acid-in-favor-of-base-1019674",
        "type": "article"
      }
    ]
  },
  "uqfeiQ9K--QkGNwks4kjk": {
    "title": "CAP Theorem",
    "description": "CAP is an acronym for Consistency, Availability, and Partition Tolerance. According to the CAP theorem, any distributed system can only guarantee two of the three properties at any time. You can't guarantee all three properties at once.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "What is CAP Theorem?",
        "url": "https://www.bmc.com/blogs/cap-theorem/",
        "type": "article"
      },
      {
        "title": "CAP Theorem - Wikipedia",
        "url": "https://en.wikipedia.org/wiki/CAP_theorem",
        "type": "article"
      },
      {
        "title": "An Illustrated Proof of the CAP Theorem",
        "url": "https://mwhittaker.github.io/blog/an_illustrated_proof_of_the_cap_theorem/",
        "type": "article"
      },
      {
        "title": "CAP Theorem and its applications in NoSQL Databases",
        "url": "https://www.ibm.com/uk-en/cloud/learn/cap-theorem",
        "type": "article"
      },
      {
        "title": "What is CAP Theorem?",
        "url": "https://www.youtube.com/watch?v=_RbsFXWRZ10",
        "type": "video"
      }
    ]
  },
  "g6HeyLptaAYx9QBKuHQyM": {
    "title": "PACELC",
    "description": "The PACELC Theorem is an extension of the CAP Theorem. One of the questions that CAP Theorem wasn’t able to answer was “what happens when there is no Partition, What Logical Combination then a Distributed System have?“. So to answer this, In addition to Consistency, Availability, and Partition Tolerance it also includes Latency as one of the desired properties of a Distributed System. The acronym PACELC stands for Partitioned, Availability, Consistency Else Latency, Consistency.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "PACELC Theorem",
        "url": "https://www.scylladb.com/glossary/pacelc-theorem/",
        "type": "article"
      }
    ]
  },
  "BEbsUA39kZ5itqCwD585f": {
    "title": "Indexes",
    "description": "An index is a data structure that you build and assign on top of an existing table that basically looks through your table and tries to analyze and summarize so that it can create shortcuts.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Database Indexes Explained",
        "url": "https://www.essentialsql.com/what-is-a-database-index/",
        "type": "article"
      },
      {
        "title": "Database Indexing Explained",
        "url": "https://www.youtube.com/watch?v=-qNSXK7s7_w",
        "type": "video"
      }
    ]
  },
  "lOj_ReWI1kQ3WajJZYOWU": {
    "title": "Views",
    "description": "Views in SQL are kind of virtual tables. A view also has rows and columns as they are in a real table in the database. We can create a view by selecting fields from one or more tables present in the database. A View can either have all the rows of a table or specific rows based on certain condition.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Database Views",
        "url": "https://www.ibm.com/docs/en/eamfoc/7.6.0?topic=structure-views",
        "type": "article"
      },
      {
        "title": "SQL Views - Wikipedia",
        "url": "https://en.wikipedia.org/wiki/View_(SQL)",
        "type": "article"
      }
    ]
  },
  "KhvYJtSCUBOpEZXjHpQde": {
    "title": "Transactions",
    "description": "In short, a database transaction is a sequence of multiple operations performed on a database, and all served as a single logical unit of work — taking place wholly or not at all. In other words, there's never a case where only half of the operations are performed and the results saved.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "What are Transactions?",
        "url": "https://fauna.com/blog/database-transaction",
        "type": "article"
      },
      {
        "title": "Database Transaction",
        "url": "https://en.wikipedia.org/wiki/Database_transaction",
        "type": "article"
      }
    ]
  },
  "FjhZGhzJjYyDn0PShKmpX": {
    "title": "Stored Procedures",
    "description": "Stored Procedures are created to perform one or more DML operations on Database. It is nothing but the group of SQL statements that accepts some input in the form of parameters and performs some task and may or may not returns a value.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "SQL Stored Procedures",
        "url": "https://www.programiz.com/sql/stored-procedures",
        "type": "article"
      }
    ]
  },
  "3r21avMlo0xFB9i7PHccX": {
    "title": "Database Federation",
    "description": "Federation (or functional partitioning) splits up databases by function. The federation architecture makes several distinct physical databases appear as one logical database to end-users.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Database Federation",
        "url": "https://dev.to/karanpratapsingh/system-design-the-complete-course-10fo#database-federation",
        "type": "article"
      },
      {
        "title": "Explore top posts about Database",
        "url": "https://app.daily.dev/tags/database?ref=roadmapsh",
        "type": "article"
      }
    ]
  },
  "WUEmEtlszbISSIWDKpvg6": {
    "title": "Replication",
    "description": "Replication is a process that involves sharing information to ensure consistency between redundant resources such as multiple databases, to improve reliability, fault-tolerance, or accessibility.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Database Replication",
        "url": "https://dev.to/karanpratapsingh/system-design-the-complete-course-10fo#database-replication",
        "type": "article"
      },
      {
        "title": "Replication (computing)",
        "url": "https://en.wikipedia.org/wiki/Replication_(computing)",
        "type": "article"
      }
    ]
  },
  "3K65efPag2076dy-MeTg4": {
    "title": "Sharding",
    "description": "Database sharding is a method of distributing data across multiple machines. It is a horizontal scaling technique, as opposed to vertical scaling, which is scaling by adding more power to a single machine. Sharding is a common way to scale a database.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Sharding",
        "url": "https://dev.to/karanpratapsingh/system-design-the-complete-course-10fo#sharding",
        "type": "article"
      },
      {
        "title": "Explore top posts about Backend Development",
        "url": "https://app.daily.dev/tags/backend?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Sharding & Database Partitioning | System Design Basics",
        "url": "https://www.youtube.com/watch?v=RynPj8C0BXA",
        "type": "video"
      },
      {
        "title": "Database Sharding - Watch",
        "url": "https://www.youtube.com/watch?v=hdxdhCpgYo8",
        "type": "video"
      },
      {
        "title": "Database Sharding in 5 minutes",
        "url": "https://www.youtube.com/watch?v=kSH4bt8ypOQ",
        "type": "video"
      }
    ]
  },
  "zG5t3HqbZnh9CGRqp1Sb-": {
    "title": "Networking",
    "description": "Networking is the process of connecting two or more computing devices together for the purpose of sharing data. In a data network, shared data may be as simple as a printer or as complex as a global financial transaction.\n\nIf you have networking experience or want to be a reliability engineer or operations engineer, expect questions from these topics. Otherwise, this is just good to know.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Khan Academy - Networking",
        "url": "https://www.khanacademy.org/computing/code-org/computers-and-the-internet",
        "type": "article"
      },
      {
        "title": "Explore top posts about Networking",
        "url": "https://app.daily.dev/tags/networking?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Computer Networking Course - Network Engineering",
        "url": "https://www.youtube.com/watch?v=qiQR5rTSshw",
        "type": "video"
      },
      {
        "title": "Networking Video Series (21 videos)",
        "url": "https://www.youtube.com/playlist?list=PLEbnTDJUr_IegfoqO4iPnPYQui46QqT0j",
        "type": "video"
      }
    ]
  },
  "pZ5x_zDYGzW9VxYycyXtN": {
    "title": "OSI Model",
    "description": "The OSI and TCP/IP model is used to help the developer to design their system for interoperability. The OSI model has 7 layers while the TCP/IP model has a more summarized form of the OSI model only consisting 4 layers. This is important if you're trying to design a system to communicate with other systems.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Cloudflare - What is the OSI model",
        "url": "https://www.cloudflare.com/learning/ddos/glossary/open-systems-interconnection-model-osi/",
        "type": "article"
      },
      {
        "title": "TCP/IP and the OSI Model Explained!",
        "url": "https://www.youtube.com/watch?v=e5DEVa9eSN0",
        "type": "video"
      }
    ]
  },
  "Fed5y1D95WPpqoVg7kmob": {
    "title": "TCP/IP Model",
    "description": "The OSI and TCP/IP model is used to help the developer to design their system for interoperability. The OSI model has 7 layers while the TCP/IP model has a more summarized form of the OSI model only consisting 4 layers. This is important if you're trying to design a system to communicate with other systems.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Cloudflare - What is the OSI model",
        "url": "https://www.cloudflare.com/learning/ddos/glossary/open-systems-interconnection-model-osi/",
        "type": "article"
      },
      {
        "title": "TCP/IP and the OSI Model Explained!",
        "url": "https://www.youtube.com/watch?v=e5DEVa9eSN0",
        "type": "video"
      }
    ]
  },
  "fYjoXB4rnkM5gg46sqVz5": {
    "title": "DNS",
    "description": "The Domain Name System (DNS) is the phonebook of the Internet. Humans access information online through domain names, like [nytimes.com](http://nytimes.com) or [espn.com](http://espn.com). Web browsers interact through Internet Protocol (IP) addresses. DNS translates domain names to IP addresses so browsers can load Internet resources.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "What is DNS?",
        "url": "https://www.cloudflare.com/en-gb/learning/dns/what-is-dns/",
        "type": "article"
      },
      {
        "title": "How DNS works (comic)",
        "url": "https://howdns.works/",
        "type": "article"
      },
      {
        "title": "Explore top posts about DNS",
        "url": "https://app.daily.dev/tags/dns?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "DNS and How does it Work?",
        "url": "https://www.youtube.com/watch?v=Wj0od2ag5sk",
        "type": "video"
      },
      {
        "title": "DNS Records",
        "url": "https://www.youtube.com/watch?v=7lxgpKh_fRY",
        "type": "video"
      },
      {
        "title": "Complete DNS mini-series",
        "url": "https://www.youtube.com/watch?v=zEmUuNFBgN8&list=PLTk5ZYSbd9MhMmOiPhfRJNW7bhxHo4q-K",
        "type": "video"
      }
    ]
  },
  "2tUwl-br-SRuwADSzmQag": {
    "title": "HTTP",
    "description": "HTTP is the `TCP/IP` based application layer communication protocol which standardizes how the client and server communicate with each other. It defines how the content is requested and transmitted across the internet.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Everything you need to know about HTTP",
        "url": "https://cs.fyi/guide/http-in-depth",
        "type": "article"
      },
      {
        "title": "What is HTTP?",
        "url": "https://www.cloudflare.com/en-gb/learning/ddos/glossary/hypertext-transfer-protocol-http/",
        "type": "article"
      },
      {
        "title": "An overview of HTTP",
        "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/Overview",
        "type": "article"
      },
      {
        "title": "HTTP/3 From A To Z: Core Concepts",
        "url": "https://www.smashingmagazine.com/2021/08/http3-core-concepts-part1/",
        "type": "article"
      },
      {
        "title": "HTTP/1 to HTTP/2 to HTTP/3",
        "url": "https://www.youtube.com/watch?v=a-sBfyiXysI",
        "type": "video"
      },
      {
        "title": "HTTP Crash Course & Exploration",
        "url": "https://www.youtube.com/watch?v=iYM2zFP3Zn0",
        "type": "video"
      }
    ]
  },
  "3pu2bGhoCLFIs6kNanwtz": {
    "title": "TLS & HTTPS",
    "description": "TLS (Transport Layer Security) is a cryptographic protocol that provides privacy and data integrity between two communicating applications. It is widely used to secure HTTP, although it can be used with any protocol. TLS is often used in combination with HTTPS, which is HTTP over TLS.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "What is TLS & How Does it Work? - Internet Society",
        "url": "https://www.internetsociety.org/deploy360/tls/basics/",
        "type": "article"
      },
      {
        "title": "What is TLS (Transport Layer Security)? - Cloudflare",
        "url": "https://www.cloudflare.com/learning/ssl/transport-layer-security-tls/",
        "type": "article"
      },
      {
        "title": "SSL and HTTPS",
        "url": "https://www.youtube.com/watch?v=S2iBR2ZlZf0",
        "type": "video"
      },
      {
        "title": "SSL/TLS - Cristina Formaini",
        "url": "https://www.youtube.com/watch?v=Rp3iZUvXWlM",
        "type": "video"
      }
    ]
  },
  "u-c-UFegRb7xqsmvj9gVb": {
    "title": "Sockets",
    "description": "A socket is an interface for network communication. It is a way for two programs to communicate with each other over a network. It is a way for a client to send a request to a server and for the server to send a response back to the client.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "A Beginners Guide to WebSockets",
        "url": "https://www.youtube.com/watch?v=8ARodQ4Wlf4",
        "type": "video"
      },
      {
        "title": "WebSockets in 100 Seconds & Beyond with Socket.io",
        "url": "https://www.youtube.com/watch?v=1BfCnjr_Vjg",
        "type": "video"
      }
    ]
  },
  "JnJbJtsqKbVETY2vdLqCO": {
    "title": "Security",
    "description": "Web security refers to the protective measures taken by the developers to protect the web applications from threats that could affect the business.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "OWASP Web Application Security Testing Checklist",
        "url": "https://github.com/0xRadi/OWASP-Web-Checklist",
        "type": "opensource"
      },
      {
        "title": "Why HTTPS Matters",
        "url": "https://developers.google.com/web/fundamentals/security/encrypt-in-transit/why-https",
        "type": "article"
      },
      {
        "title": "Wikipedia - OWASP",
        "url": "https://en.wikipedia.org/wiki/OWASP",
        "type": "article"
      },
      {
        "title": "OWASP Top 10 Security Risks",
        "url": "https://sucuri.net/guides/owasp-top-10-security-vulnerabilities-2021/",
        "type": "article"
      },
      {
        "title": "OWASP Cheatsheets",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/AJAX_Security_Cheat_Sheet.html",
        "type": "article"
      },
      {
        "title": "Content Security Policy (CSP)",
        "url": "https://developer.mozilla.org/en-US/docs/Web/HTTP/CSP",
        "type": "article"
      },
      {
        "title": "Explore top posts about Security",
        "url": "https://app.daily.dev/tags/security?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "MIT 6.858 Computer Systems Security, Fall 2014",
        "url": "https://www.youtube.com/playlist?list=PLUl4u3cNGP62K2DjQLRxDNRi0z2IRWnNh",
        "type": "video"
      }
    ]
  },
  "bDZ34BPm3lX06ERSE10cY": {
    "title": "Public Key Cryptography",
    "description": "Public-key cryptography, or asymmetric cryptography, is the field of cryptographic systems that use pairs of related keys. Each key pair consists of a public key and a corresponding private key. Key pairs are generated with cryptographic algorithms based on mathematical problems termed one-way functions.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Public-key Cryptography",
        "url": "https://en.wikipedia.org/wiki/Public-key_cryptography",
        "type": "article"
      },
      {
        "title": "Explore top posts about Cryptography",
        "url": "https://app.daily.dev/tags/cryptography?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Public Key Cryptography - Computerphile",
        "url": "https://www.youtube.com/watch?v=GSIDS_lvRv4",
        "type": "video"
      },
      {
        "title": "Public Key Cryptography: RSA Encryption Algorithm",
        "url": "https://www.youtube.com/watch?v=wXB-V_Keiu8",
        "type": "video"
      }
    ]
  },
  "7r7o8pYhFHVAJIv0wNT6X": {
    "title": "Hashing / Encryption / Encoding",
    "description": "Hashing is a one-way function that takes an input and produces a fixed-length output. The output is called a hash. The hash is a unique representation of the input. The hash is deterministic, meaning that the same input will always produce the same hash. The hash is irreversible, meaning that it is impossible to go from the hash back to the original input. The hash is not collision-resistant, meaning that it is possible to find two different inputs that produce the same hash.\n\nEncryption is a two-way function that takes an input and produces an output. The output is called ciphertext. The ciphertext is a unique representation of the input. The ciphertext is deterministic, meaning that the same input will always produce the same ciphertext. The ciphertext is reversible, meaning that it is possible to go from the ciphertext back to the original input. The ciphertext is collision-resistant, meaning that it is impossible to find two different inputs that produce the same ciphertext.\n\nEncoding is a two-way function that takes an input and produces an output. The output is called encoded text. The encoded text is a unique representation of the input. The encoded text is deterministic, meaning that the same input will always produce the same encoded text. The encoded text is reversible, meaning that it is possible to go from the encoded text back to the original input. The encoded text is collision-resistant, meaning that it is impossible to find two different inputs that produce the same encoded text.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Explore top posts about Encryption",
        "url": "https://app.daily.dev/tags/encryption?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Encoding, Encryption and Hashing -- Whats the Difference?",
        "url": "https://www.youtube.com/watch?v=-bAnBzvMLig",
        "type": "video"
      }
    ]
  },
  "EX_e4B6G07zTb4JjJ7482": {
    "title": "Hashing Algorithms",
    "description": "Hashing algorithms are used to generate a unique value for a given input. This value is called a hash. Hashing algorithms are used to verify the integrity of data, to store passwords, and to generate unique identifiers for data.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Hashing Algorithm Overview:",
        "url": "https://www.okta.com/identity-101/hashing-algorithms/",
        "type": "article"
      },
      {
        "title": "Explore top posts about Algorithms",
        "url": "https://app.daily.dev/tags/algorithms?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Hashing Algorithms and Security - Computerphile",
        "url": "https://www.youtube.com/watch?v=b4b8ktEV4Bg",
        "type": "video"
      },
      {
        "title": "Top Hashing Algorithms In Cryptography | MD5 and SHA 256 Algorithms Expalined | Simplilearn",
        "url": "https://www.youtube.com/watch?v=Plp4F3ZfC7A",
        "type": "video"
      },
      {
        "title": "SHA: Secure Hashing Algorithm - Computerphile",
        "url": "https://www.youtube.com/watch?v=DMtFhACPnTY",
        "type": "video"
      }
    ]
  },
  "3rPSp135TdSCyvXzEzn4p": {
    "title": "OWASP Top 10",
    "description": "OWASP or Open Web Application Security Project is an online community that produces freely-available articles, methodologies, documentation, tools, and technologies in the field of web application security.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "OWASP Web Application Security Testing Checklist",
        "url": "https://github.com/0xRadi/OWASP-Web-Checklist",
        "type": "opensource"
      },
      {
        "title": "OWASP",
        "url": "https://owasp.org/",
        "type": "article"
      },
      {
        "title": "OWASP - Wiki",
        "url": "https://en.wikipedia.org/wiki/OWASP",
        "type": "article"
      },
      {
        "title": "OWASP Top 10 Security Risks",
        "url": "https://sucuri.net/guides/owasp-top-10-security-vulnerabilities-2021/",
        "type": "article"
      },
      {
        "title": "OWASP Cheatsheets",
        "url": "https://cheatsheetseries.owasp.org/cheatsheets/AJAX_Security_Cheat_Sheet.html",
        "type": "article"
      }
    ]
  },
  "-emdKpD5uRNuvem5rbFXJ": {
    "title": "How Computers Work",
    "description": "Computers are everywhere. They are in our phones, our cars, our homes, and even in our pockets. But how do they actually work? How do they take in information, and how do they output information?\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "How CPU Executes A Program",
        "url": "https://www.youtube.com/watch?v=XM4lGflQFvA",
        "type": "video"
      },
      {
        "title": "How Computers Calculate - ALU",
        "url": "https://youtu.be/1I5ZMmrOfnA",
        "type": "video"
      },
      {
        "title": "Registers and RAM",
        "url": "https://youtu.be/fpnE6UAfbtU",
        "type": "video"
      },
      {
        "title": "The Central Processing Unit (CPU)",
        "url": "https://youtu.be/FZGugFqdr60",
        "type": "video"
      },
      {
        "title": "Instructions and Programs",
        "url": "https://youtu.be/zltgXvg6r3k",
        "type": "video"
      }
    ]
  },
  "1eglba39q426Nh0E0qcdj": {
    "title": "How CPU Executes Programs",
    "description": "The CPU executes programs by repeatedly fetching instructions from memory, decoding them to understand the operation, and then executing those operations. This cycle, called the fetch-decode-execute cycle, continues for each instruction in the program, with the CPU using registers for temporary storage and a program counter to keep track of the next instruction. Modern CPUs use techniques like pipelining and caches to speed up this process, enabling them to execute complex programs efficiently.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Explore top posts about Computing",
        "url": "https://app.daily.dev/tags/computing?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "How CPU Executes a Program",
        "url": "https://www.youtube.com/watch?v=XM4lGflQFvA",
        "type": "video"
      }
    ]
  },
  "GDLKJkKgB-i7n0YcV2NDa": {
    "title": "How Computers Calculate",
    "description": "Computers calculate using the binary system, where all data is represented as 0s and 1s. These binary states correspond to the ON/OFF positions of transistors, which are the building blocks of logic gates (AND, OR, NOT). Numbers, characters, and instructions are broken into binary sequences (bits), and grouped into bytes (8 bits). Arithmetic operations like addition are performed through logic gates, which combine binary values. The CPU executes these calculations by following a fetch-decode-execute cycle. Complex calculations, such as handling decimals, use floating-point representation. Programs written in high-level languages are compiled into machine code for the CPU to execute.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "How Does A Computer Calculate Numbers?",
        "url": "https://www.sciencing.com/computer-calculate-numbers-4705975/",
        "type": "article"
      },
      {
        "title": "How Computers Calculate - ALU",
        "url": "https://youtu.be/1I5ZMmrOfnA",
        "type": "video"
      }
    ]
  },
  "U3379F4AO1KSmGtVmPr27": {
    "title": "Registers and RAM",
    "description": "**_Registers_** are the smallest data-holding elements built into the processor itself. Registers are the memory locations that are directly accessible by the processor. The registers hold the instruction or operands currently accessed by the CPU.\n\nRegisters are the high-speed accessible storage elements. The processor accesses the registers within one CPU clock cycle. The processor can decode the instructions and perform operations on the register contents at more than one operation per CPU clock cycle.\n\n**_Memory_** is a hardware device that stores computer programs, instructions, and data. The memory that is internal to the processor is primary memory (RAM), and the memory that is external to the processor is secondary (**Hard Drive**).\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "RAM vs. Registers - What's the Difference?",
        "url": "https://thisvsthat.io/ram-vs-registers",
        "type": "article"
      },
      {
        "title": "Registers and RAM",
        "url": "https://youtu.be/fpnE6UAfbtU",
        "type": "video"
      }
    ]
  },
  "AxiGqbteK7ZSXEUt_zckH": {
    "title": "Instructions and Programs",
    "description": "Instructions are the most basic commands a CPU can understand, directing it to perform specific actions like adding numbers or moving data. A program, on the other hand, is a collection of these instructions, organized in a sequence to accomplish a particular task. Think of instructions as individual words and a program as a complete sentence or story; the CPU executes these instructions one by one, following the program's logic, to achieve the desired outcome.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Instruction and Programs",
        "url": "https://nerdfighteria.info/v/zltgXvg6r3k/",
        "type": "article"
      },
      {
        "title": "Instructions and Programs",
        "url": "https://youtu.be/zltgXvg6r3k",
        "type": "video"
      }
    ]
  },
  "DjTQjMbika4_yTzrBpcmB": {
    "title": "CPU Cache",
    "description": "A CPU cache is a hardware cache used by the central processing unit of a computer to reduce the average cost to access data from the main memory. A cache is a smaller, faster memory, located closer to a processor core, which stores copies of the data from frequently used main memory locations.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "What is CPU Cache",
        "url": "https://www.howtogeek.com/854138/what-is-cpu-cache/",
        "type": "article"
      },
      {
        "title": "Explore top posts about Computing",
        "url": "https://app.daily.dev/tags/computing?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "MIT 6.004 L15: The Memory Hierarchy",
        "url": "https://www.youtube.com/watch?v=vjYF_fAZI5E&list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-&index=24",
        "type": "video"
      },
      {
        "title": "MIT 6.004 L16: Cache Issues",
        "url": "https://www.youtube.com/watch?v=ajgC3-pyGlk&index=25&list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-",
        "type": "video"
      }
    ]
  },
  "ETEUA7jaEGyOEX8tAVNWs": {
    "title": "Processes and Threads",
    "description": "Processes and threads are the basic building blocks of a computer program. They are the smallest units of execution in a program. A process is an instance of a program that is being executed. A thread is a sequence of instructions within a process that can be executed independently of other code.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Whats the difference between Process and a Thread?",
        "url": "https://www.quora.com/What-is-the-difference-between-a-process-and-a-thread",
        "type": "article"
      },
      {
        "title": "Operating Systems and System Programming",
        "url": "https://archive.org/details/ucberkeley-webcast-PL-XXv-cvA_iBDyz-ba4yDskqMDY6A1w_c",
        "type": "article"
      },
      {
        "title": "25 hour Operating Systems Course - freecodecamp",
        "url": "https://youtu.be/yK1uBHPdp30?si=gGPdK7cM4KlP6Qq0",
        "type": "video"
      }
    ]
  },
  "RbdT5MOE4L-E7PPWKRITX": {
    "title": "Process Forking",
    "description": "Process forking is a way to create a new process from an existing process. The new process is a copy of the existing process. The new process is called a child process and the existing process is called a parent process.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Fork System Call in Operating System",
        "url": "https://www.geeksforgeeks.org/fork-system-call-in-operating-system/",
        "type": "article"
      },
      {
        "title": "Understanding fork() system call for new process creation",
        "url": "https://www.youtube.com/watch?v=PwxTbksJ2fo",
        "type": "video"
      },
      {
        "title": "fork() and exec() System Calls",
        "url": "https://www.youtube.com/watch?v=IFEFVXvjiHY",
        "type": "video"
      },
      {
        "title": "The fork() function in C",
        "url": "https://www.youtube.com/watch?v=cex9XrZCU14",
        "type": "video"
      }
    ]
  },
  "jVsZFTzyrYEDyR8LiBQL0": {
    "title": "Memory Management",
    "description": "Memory management is the process of allocating and deallocating memory. It is a very important part of any programming language.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "MIT 6.004 L15: The Memory Hierarchy",
        "url": "https://www.youtube.com/watch?v=vjYF_fAZI5E&list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-&index=24",
        "type": "video"
      },
      {
        "title": "MIT 6.004 L16: Cache Issues",
        "url": "https://www.youtube.com/watch?v=ajgC3-pyGlk&index=25&list=PLrRW1w6CGAcXbMtDFj205vALOGmiRc82-",
        "type": "video"
      }
    ]
  },
  "O6-vG3FuoYet4D0hbiyrv": {
    "title": "Lock / Mutex / Semaphore",
    "description": "A lock allows only one thread to enter the part that's locked and the lock is not shared with any other processes.\n\nA mutex is the same as a lock but it can be system wide (shared by multiple processes).\n\nA semaphore does the same as a mutex but allows x number of threads to enter, this can be used for example to limit the number of cpu, io or ram intensive tasks running at the same time.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "What is the difference between lock, mutex and semaphore?",
        "url": "https://stackoverflow.com/questions/2332765/what-is-the-difference-between-lock-mutex-and-semaphore",
        "type": "article"
      },
      {
        "title": "What is a Semaphore",
        "url": "https://stackoverflow.com/questions/34519/what-is-a-semaphore/40238#40238",
        "type": "article"
      }
    ]
  },
  "xUo5Ox_HTgGyeQMDIkVyK": {
    "title": "Concurrency in Multiple Cores",
    "description": "Concurrency or Parallelism is simultaneous execution of processes on a multiple cores per CPU or multiple CPUs (on a single motherboard). Concurrency is when Parallelism is achieved on a single core/CPU by using scheduling algorithms that divides the CPU's time (time-slice).\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Difference between Multi-core and concurrent Programming?",
        "url": "https://stackoverflow.com/questions/5372861/what-is-the-difference-between-multicore-and-concurrent-programming",
        "type": "article"
      },
      {
        "title": "Concurrency in Multicore systems",
        "url": "https://cs.stackexchange.com/questions/140793/concurrency-in-multiple-core",
        "type": "article"
      },
      {
        "title": "Mastering Concurrency",
        "url": "https://www.harrisonclarke.com/blog/mastering-concurrency-a-guide-for-software-engineers",
        "type": "article"
      }
    ]
  },
  "Ge2nagN86ofa2y-yYR1lv": {
    "title": "Scheduling Algorithms",
    "description": "CPU Scheduling is the process of selecting a process from the ready queue and allocating the CPU to it. The selection of a process is based on a particular scheduling algorithm. The scheduling algorithm is chosen depending on the type of system and the requirements of the processes.\n\nHere is the list of some of the most commonly used scheduling algorithms:\n\n*   **First Come First Serve (FCFS):** The process that arrives first is allocated the CPU first. It is a non-preemptive algorithm.\n*   **Shortest Job First (SJF):** The process with the smallest execution time is allocated the CPU first. It is a non-preemptive algorithm.\n*   **Shortest Remaining Time First (SRTF):** The process with the smallest remaining execution time is allocated the CPU first. It is a preemptive algorithm.\n*   **Round Robin (RR):** The process is allocated the CPU for a fixed time slice. The time slice is usually 10 milliseconds. It is a preemptive algorithm.\n*   **Priority Scheduling:** The process with the highest priority is allocated the CPU first. It is a preemptive algorithm.\n*   **Multi-level Queue Scheduling:** The processes are divided into different queues based on their priority. The process with the highest priority is allocated the CPU first. It is a preemptive algorithm.\n*   **Multi-level Feedback Queue Scheduling:** The processes are divided into different queues based on their priority. The process with the highest priority is allocated the CPU first. If a process is preempted, it is moved to the next queue. It is a preemptive algorithm.\n*   **Highest Response Ratio Next(HRRN):** CPU is allotted to the next process which has the highest response ratio and not to the process having less burst time. It is a Non-Preemptive algorithm.\n*   **Lottery Scheduling:** The process is allocated the CPU based on a lottery system. It is a preemptive algorithm.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "CPU Scheduling in Operating System",
        "url": "https://www.scaler.com/topics/operating-system/cpu-scheduling/",
        "type": "article"
      }
    ]
  },
  "cpQvB0qMDL3-NWret7oeA": {
    "title": "CPU Interrupts",
    "description": "CPU Interrupts are a way for the CPU to communicate with the rest of the computer. They are a way for the CPU to tell the rest of the computer that it needs to do something. For example, if the CPU is running a program and it needs to read from the keyboard, it will send an interrupt to the keyboard to tell it to send the data to the CPU. The CPU will then wait for the keyboard to send the data and then continue running the program.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "System Interrupts 100% CPU",
        "url": "https://www.wikihow.com/System-Interrupts-100-Cpu",
        "type": "article"
      },
      {
        "title": "Explore top posts about Computing",
        "url": "https://app.daily.dev/tags/computing?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Interrupts",
        "url": "https://youtu.be/iKlAWIKEyuw",
        "type": "video"
      }
    ]
  },
  "IEX6v_MYpE5Ylk_28K2ZU": {
    "title": "Processes vs Threads",
    "description": "Processes and threads are the basic building blocks of a computer program. They are the smallest units of execution in a program. A process is an instance of a program that is being executed. A thread is a sequence of instructions within a process that can be executed independently of other code.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Whats the difference between Process and a Thread?",
        "url": "https://www.quora.com/What-is-the-difference-between-a-process-and-a-thread",
        "type": "article"
      },
      {
        "title": "Operating Systems and System Programming",
        "url": "https://archive.org/details/ucberkeley-webcast-PL-XXv-cvA_iBDyz-ba4yDskqMDY6A1w_c",
        "type": "article"
      }
    ]
  },
  "C1eNsPjiQo8INbvL2Lt7L": {
    "title": "K-D Trees",
    "description": "K-D Trees are a data structure that allow for fast nearest neighbor search in high dimensional spaces. They are a generalization of binary search trees, and are used in a variety of applications, including computer vision and computational geometry.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "K-D Tree Algorithm",
        "url": "https://www.youtube.com/watch?v=Y4ZgLlDfKDg",
        "type": "video"
      },
      {
        "title": "K-d Trees - Computerphile",
        "url": "https://www.youtube.com/watch?v=BK5x7IUTIyU",
        "type": "video"
      }
    ]
  },
  "K96ggeWqd5OwoNnkL04pc": {
    "title": "Skip Lists",
    "description": "Skip lists are a data structure that allows you to perform operations on a sorted list in O(log n) time. Skip lists are a probabilistic data structure, which means that the probability of a certain operation taking a certain amount of time is a certain value. In the case of skip lists, the probability of an operation taking O(log n) time is 1.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Skip Lists",
        "url": "https://en.wikipedia.org/wiki/Skip_list",
        "type": "article"
      },
      {
        "title": "Randomization: Skip Lists",
        "url": "https://www.youtube.com/watch?v=2g9OSRKJuzM&index=10&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp",
        "type": "video"
      }
    ]
  },
  "pLBfkzi0qfgVRqi_4AmMI": {
    "title": "Co-NP",
    "description": "Co-NP stands for the complement of NP Class. It means if the answer to a problem in Co-NP is No, then there is proof that can be checked in polynomial time.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Trying to understand P vs NP vs NP Complete vs NP Hard",
        "url": "https://softwareengineering.stackexchange.com/questions/308178/trying-to-understand-p-vs-np-vs-np-complete-vs-np-hard",
        "type": "article"
      },
      {
        "title": "Complexity: P, NP, NP-completeness, Reductions",
        "url": "https://www.youtube.com/watch?v=eHZifpgyH_4&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=22",
        "type": "video"
      },
      {
        "title": "Complexity: Approximation Algorithms",
        "url": "https://www.youtube.com/watch?v=MEz1J9wY2iM&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp&index=24",
        "type": "video"
      },
      {
        "title": "Complexity: Fixed-Parameter Algorithms",
        "url": "https://www.youtube.com/watch?v=4q-jmGrmxKs&index=25&list=PLUl4u3cNGP6317WaSNfmCvGym2ucw3oGp",
        "type": "video"
      },
      {
        "title": "Lecture 23: Computational Complexity",
        "url": "https://www.youtube.com/watch?v=moPtwq_cVH8&list=PLUl4u3cNGP61Oq3tWYp6V_F-5jb5L2iHb&index=24",
        "type": "video"
      },
      {
        "title": "Greedy Algs. II & Intro to NP Completeness",
        "url": "https://youtu.be/qcGnJ47Smlo?list=PLFDnELG9dpVxQCxuD-9BSy2E7BWY3t5Sm&t=2939",
        "type": "video"
      }
    ]
  },
  "hTPLcuOW7eEE5oYhNfmOG": {
    "title": "Bitwise Operators",
    "description": "Bitwise operators are used to perform operations on individual bits of a number. They are used in cryptography, image processing, and other applications.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Bit Manipulation",
        "url": "https://www.youtube.com/watch?v=7jkIUgLC29I",
        "type": "video"
      },
      {
        "title": "Binary: Plusses & Minuses (Why We Use Twos Complement) - Computerphile",
        "url": "https://www.youtube.com/watch?v=lKTsv6iVxV4",
        "type": "video"
      },
      {
        "title": "Algorithms: Bit Manipulation",
        "url": "https://www.youtube.com/watch?v=NLKQEOgBAnw",
        "type": "video"
      }
    ]
  },

  "ofwdZm05AUqCIWmfgGHk8": {
    "title": "Diamond Inheritance",
    "description": "Diamond inheritance is a specific scenario in multiple inheritance where a class is derived from two or more classes, which in turn, are derived from a common base class. It creates an ambiguity that arises from duplicating the common base class, which leads to an ambiguous behavior while calling the duplicate members.\n\nTo resolve this ambiguity, you can use virtual inheritance. A virtual base class is a class that is shared by multiple classes using `virtual` keyword in C++. This ensures that only one copy of the base class is inherited in the final derived class, and thus, resolves the diamond inheritance problem.\n\n_Example:_\n\n    #include <iostream>\n    \n    class Base {\n    public:\n        void print() {\n            std::cout << \"Base class\\n\";\n        }\n    };\n    \n    class Derived1 : virtual public Base {\n    public:\n        void derived1Print() {\n            std::cout << \"Derived1 class\\n\";\n        }\n    };\n    \n    class Derived2 : virtual public Base {\n    public:\n        void derived2Print() {\n            std::cout << \"Derived2 class\\n\";\n        }\n    };\n    \n    class Derived3 : public Derived1, public Derived2 {\n    public:\n        void derived3Print() {\n            std::cout << \"Derived3 class\\n\";\n        }\n    };\n    \n    int main() {\n        Derived3 d3;\n        d3.print(); // Now, there is no ambiguity in calling the base class function\n        d3.derived1Print();\n        d3.derived2Print();\n        d3.derived3Print();\n    \n        return 0;\n    }\n    \n\nIn the code above, `Derived1` and `Derived2` are derived from the `Base` class using virtual inheritance. So, when we create an object of `Derived3` and call the `print()` function from the `Base` class, there is no ambiguity, and the code executes without any issues.",
    "links": []
  },
  "ZHjU60uzJTezADRhDTESG": {
    "title": "Forward Declaration",
    "description": "Forward declaration is a way of declaring a symbol (class, function, or variable) before defining it in the code. It helps the compiler understand the type, size, and existence of the symbol. This declaration is particularly useful when we have cyclic dependencies or to reduce compilation time by avoiding unnecessary header inclusions in the source file.\n\nClass Forward Declaration\n-------------------------\n\nTo use a class type before it is defined, you can declare the class without defining its members, like this:\n\n    class ClassA; // forward declaration\n    \n\nYou can then use pointers or references to the class in your code before defining the class itself:\n\n    void do_something (ClassA& obj);\n    \n    class ClassB {\n    public:\n        void another_function(ClassA& obj);\n    };\n    \n\nHowever, if you try to make an object of `ClassA` or call its member functions without defining the class, you will get a compilation error.\n\nFunction Forward Declaration\n----------------------------\n\nFunctions must be declared before using them, and a forward declaration can be used to declare a function without defining it:\n\n    int add(int a, int b); // forward declaration\n    \n    int main() {\n        int result = add(2, 3);\n        return 0;\n    }\n    \n    int add(int a, int b) {\n        return a + b;\n    }\n    \n\nEnum and Typedef Forward Declaration\n------------------------------------\n\nFor `enum` and `typedef`, it is not possible to forward declare because they don't have separate declaration and definition stages.\n\nKeep in mind that forward declarations should be used cautiously, as they can make the code more difficult to understand.",
    "links": []
  },
  "NvODRFR0DLINB0RlPSsvt": {
    "title": "Introduction to Language",
    "description": "C++ is a general-purpose, high-performance programming language. It was developed by Bjarne Stroustrup at Bell Labs starting in 1979. C++ is an extension of the C programming language, adding features such as classes, objects, and exceptions.\n\nBasics of C++ Programming\n-------------------------\n\nHere are some basic components and concepts in C++ programming:\n\nIncluding Libraries\n-------------------\n\nIn C++, we use the `#include` directive to include libraries or header files into our program. For example, to include the standard input/output library, we write:\n\n    #include <iostream>\n    \n\nMain Function\n-------------\n\nThe entry point of a C++ program is the `main` function. Every C++ program must have a `main` function:\n\n    int main() {\n        // Your code goes here\n        return 0;\n    }\n    \n\nInput/Output\n------------\n\nTo perform input and output operations in C++, we can use the built-in objects `std::cin` for input and `std::cout` for output, available in the `iostream` library. Here's an example of reading an integer and printing its value:\n\n    #include <iostream>\n    \n    int main() {\n        int number;\n        std::cout << \"Enter an integer: \";\n        std::cin >> number;\n        std::cout << \"You entered: \" << number << '\\n';\n        return 0;\n    }\n    \n\nVariables and Data Types\n------------------------\n\nC++ has several basic data types for representing integer, floating-point, and character values:\n\n*   `int`: integer values\n*   `float`: single-precision floating-point values\n*   `double`: double-precision floating-point values\n*   `char`: single characters\n*   `bool`: boolean values\n\nVariables must be declared with a data type before they can be used:\n\n    int x;\n    float y;\n    double z;\n    char c;\n    bool b;\n    \n\nControl Structures\n------------------\n\nC++ provides control structures for conditional execution and iteration, such as `if`, `else`, `while`, `for`, and `switch` statements.\n\n### If-Else Statement\n\n    if (condition) {\n        // Code to execute if the condition is true\n    } else {\n        // Code to execute if the condition is false\n    }\n    \n\n### While Loop\n\n    while (condition) {\n        // Code to execute while the condition is true\n    }\n    \n\n### For Loop\n\n    for (initialization; condition; update) {\n        // Code to execute while the condition is true\n    }\n    \n\n### Switch Statement\n\n    switch (variable) {\n        case value1:\n            // Code to execute if variable == value1\n            break;\n        case value2:\n            // Code to execute if variable == value2\n            break;\n        // More cases...\n        default:\n            // Code to execute if variable does not match any case value\n    }\n    \n\nFunctions\n---------\n\nFunctions are reusable blocks of code that can be called with arguments to perform a specific task. Functions are defined with a return type, a name, a parameter list, and a body.\n\n    ReturnType functionName(ParameterType1 parameter1, ParameterType2 parameter2) {\n        // Function body\n        // ...\n        return returnValue;\n    }\n    \n\nFor example, here's a function that adds two integers and returns the result:\n\n    int add(int a, int b) {\n        return a + b;\n    }\n    \n    int main() {\n        int result = add(3, 4);\n        std::cout << \"3 + 4 = \" << result << '\\n';\n        return 0;\n    }\n    \n\nThis basic introduction to C++ should provide you with a good foundation for further learning. Explore more topics such as classes, objects, inheritance, polymorphism, templates, and the Standard Template Library (STL) to deepen your understanding of C++ and start writing more advanced programs.\n\nLearn more from the following resources:",
    "links": [
      {
        "title": "LearnC++",
        "url": "https://www.learncpp.com/",
        "type": "article"
      },
      {
        "title": "C++ Full Course by freeCodeCamp",
        "url": "https://youtu.be/vLnPwxZdW4Y",
        "type": "video"
      }
    ]
  },
  "x_28LiDVshqWns_aIBsdx": {
    "title": "What is C++?",
    "description": "C++ is a general-purpose programming language created by Bjarne Stroustrup as an extension of the C programming language. It was first introduced in 1985 and provides object-oriented features like classes and inheritance. C++ is widely used in various applications like game development, system programming, embedded systems, and high-performance computing.\n\nC++ is a statically-typed language, meaning that the type of a variable is determined during compilation, and has an extensive library called the C++ Standard Library, which provides a rich set of functions, algorithms, and data structures for various tasks.\n\nC++ builds upon the features of C, and thus, most C programs can be compiled and run with a C++ compiler.\n\nCode Example\n------------\n\nHere's a simple example of a C++ program that demonstrates some essential features of the language:\n\n    #include <iostream>\n    \n    // A simple function to add two numbers\n    int add(int a, int b) {\n        return a + b;\n    }\n    \n    class Calculator {\n    public:\n        // A member function to multiply two numbers\n        int multiply(int a, int b) {\n            return a * b;\n        }\n    };\n    \n    int main() {\n        int x = 5;\n        int y = 3;\n    \n        // Using the standalone function 'add'\n        int sum = add(x, y);\n        std::cout << \"Sum: \" << sum << '\\n';\n    \n        // Using a class and member function\n        Calculator calc;\n        int product = calc.multiply(x, y);\n        std::cout << \"Product: \" << product << '\\n';\n    \n        return 0;\n    }\n    \n\nIn the above program, we define a simple function `add` and a class `Calculator` with a member function `multiply`. The `main` function demonstrates how to use these to perform basic arithmetic.\n\nLearn more from the following resources:",
    "links": [
      {
        "title": "Learn C++",
        "url": "https://www.learncpp.com/",
        "type": "article"
      },
      {
        "title": "Explore top posts about C++",
        "url": "https://app.daily.dev/tags/c++?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "C++ Tutorial for Beginners - Full Course",
        "url": "https://youtu.be/vLnPwxZdW4Y",
        "type": "video"
      }
    ]
  },
  "tl6VCQ5IEGDVyFcgj7jDm": {
    "title": "Why use C++",
    "description": "C++ is a popular and widely used programming language for various reasons. Here are some of the reasons why you might choose to utilize C++:\n\nPerformance\n-----------\n\nC++ is designed to provide high performance and efficiency. It offers fine-grained control over system resources, making it easier to optimize your software.\n\nPortability\n-----------\n\nC++ is supported on different computer architectures and operating systems, allowing you to write portable code that runs on various platforms without making major modifications.\n\nObject-Oriented Programming\n---------------------------\n\nC++ supports object-oriented programming (OOP) - a paradigm that allows you to design programs using classes and objects, leading to better code organization and reusability.\n\n    class MyClass {\n        public:\n            void myFunction() {\n                // Code here\n            }\n    };\n    \n    int main() {\n        MyClass obj;\n        obj.myFunction();\n    }\n    \n\nSupport for low-level and high-level programming\n------------------------------------------------\n\nC++ allows you to write both low-level code, like memory manipulation, as well as high-level abstractions, like creating classes and using the Standard Template Library (STL).\n\n    #include <iostream>\n    #include <vector>\n    \n    int main() {\n        // Low-level programming\n        int number = 42;\n        int* ptr_number = &number;\n    \n        // High-level programming\n        std::vector<int> myVector = {1, 2, 3};\n        for (const auto &i: myVector) {\n            std::cout << i << '\\n';\n        }\n    }\n    \n\nExtensive Libraries\n-------------------\n\nC++ offers a vast range of libraries and tools, such as the Standard Template Library (STL), Boost, and Qt, among others, that can aid in the development of your projects and make it more efficient.\n\nCombination with C language\n---------------------------\n\nC++ can be combined with C, offering the capabilities of both languages and allowing you to reuse your existing C code. By incorporating C++ features, you can enhance your code and improve its functionality.\n\nActive Community\n----------------\n\nC++ has been around for a long time and has a large, active community of users who contribute to the growth of the language, express new ideas, and engage in discussions that help develop the language further. This makes finding solutions to any problems you experience much easier.\n\nIn summary, C++ offers a great balance of performance, portability, and feature set, making it a versatile and powerful programming language suitable for many applications. With its extensive libraries, active community, and continuous development, C++ is an excellent choice for any software development project.",
    "links": []
  },
  "2Ag0t3LPryTF8khHLRfy-": {
    "title": "C vs C++",
    "description": "C and C++ are two popular programming languages with some similarities, but they also have key differences. C++ is an extension of the C programming language, with added features such as object-oriented programming, classes, and exception handling. Although both languages are used for similar tasks, they have their own syntax and semantics, which makes them distinct from each other.\n\nSyntax and Semantics\n--------------------\n\n### C\n\n*   C is a procedural programming language.\n*   Focuses on functions and structured programming.\n*   Does not support objects or classes.\n*   Memory management is manual, using functions like `malloc` and `free`.\n\n    #include <stdio.h>\n    \n    void printHello() {\n        printf(\"Hello, World!\\n\");\n    }\n    \n    int main() {\n        printHello();\n        return 0;\n    }\n    \n\n### C++\n\n*   C++ is both procedural and object-oriented.\n*   Supports both functions and classes.\n*   Incorporates different programming paradigms.\n*   Memory management can be manual (like C) or rely on constructors/destructors and smart pointers.\n\n    #include <iostream>\n    \n    class HelloWorld {\n    public:\n        void printHello() {\n            std::cout << \"Hello, World!\\n\";\n        }\n    };\n    \n    int main() {\n        HelloWorld obj;\n        obj.printHello();\n        return 0;\n    }\n    \n\nCode Reusability and Modularity\n-------------------------------\n\n### C\n\n*   Code reusability is achieved through functions and modular programming.\n*   High cohesion and low coupling are achieved via structured design.\n*   Function libraries can be created and included through headers.\n\n### C++\n\n*   Offers better code reusability with classes, inheritance, and polymorphism.\n*   Code modularity is enhanced through namespaces and well-designed object-oriented hierarchy.\n\nError Handling\n--------------\n\n### C\n\n*   Error handling in C is done primarily through return codes.\n*   Lacks support for exceptions or any built-in error handling mechanism.\n\n### C++\n\n*   Offers exception handling, which can be used to handle errors that may occur during program execution.\n*   Enables catching and handling exceptions with `try`, `catch`, and `throw` keywords, providing more control over error handling.\n\nConclusion\n----------\n\nBoth C and C++ are powerful languages with unique features and capabilities. While C is simpler and focuses on procedural programming, C++ offers the versatility of using different programming paradigms and improved code organization. Understanding the differences between these two languages can help you decide which one is more suitable for your specific needs and programming style.",
    "links": []
  },
  "Zc_TTzmM36yWsu3GvOy9x": {
    "title": "Setting up your Environment",
    "description": "Setting up C++ requires a few steps, including installing a compiler, configuring an Integrated Development Environment (IDE), and creating a new C++ project.\n\n1\\. Installing a Compiler\n-------------------------\n\nA compiler is required to convert C++ code into machine language. Some popular C++ compilers include:\n\n*   GCC (GNU Compiler Collection) for Linux and macOS, but can also be used on Windows through MinGW\n*   MSVC (Microsoft Visual C++) for Windows\n\nTo install a compiler, simply follow the instructions provided by the respective websites.\n\n2\\. Configuring an IDE\n----------------------\n\nAn IDE is a software application that provides facilities for programming, such as code editing, debugging, and building. Some popular C++ IDEs include:\n\n*   [@article@Visual Studio](https://visualstudio.microsoft.com/vs/features/cplusplus/) (Windows, macOS)\n*   [@article@Eclipse](https://eclipse.org) (Windows, macOS, Linux)\n*   [@article@Code::Blocks](http://www.codeblocks.org) (Windows, macOS, Linux)\n\nAfter downloading and installing an IDE, you might need to configure it to use the installed compiler. Check the documentation of the respective IDE for instructions on how to do this.\n\n3\\. Creating a New C++ Project\n------------------------------\n\nOnce you have your IDE and compiler set up, you can create a new C++ project and start writing code. In general, follow these steps to create a new C++ project:\n\n*   Open the IDE and create a new project.\n*   Select the project type (C++ Application or Console Application).\n*   Specify the project name and location.\n*   Let the IDE generate the main.cpp and build files (such as Makefile or CMakeLists.txt) for you.\n\nExample: Hello World in C++\n---------------------------\n\nCreate a new file called `main.cpp` within your project and include this code:\n\n    #include <iostream>\n    \n    int main() {\n        std::cout << \"Hello, World!\\n\";\n        return 0;\n    }\n    \n\nThen, follow the IDE's instructions to build and run your program. You should see \"Hello, World!\" displayed in the console.\n\nSummary\n-------\n\nSetting up C++ involves:\n\n*   Installing a compiler (e.g. GCC, MinGW, or MSVC)\n*   Configuring an IDE (e.g. Visual Studio, Eclipse, or Code::Blocks)\n*   Creating a new C++ project and writing code\n\nBy following these steps, you'll be ready to start developing C++ applications!",
    "links": []
  },
  "0J_ltQEJh2g28OE2ZEYJj": {
    "title": "Installing C++",
    "description": "Before you can start programming in C++, you will need to have a compiler installed on your system. A compiler is a program that converts the C++ code you write into an executable file that your computer can run. There are several popular C++ compilers to choose from, depending on your operating system and preference.\n\n### Windows\n\nFor Windows, one popular option is to install the [Microsoft Visual Studio IDE](https://visualstudio.microsoft.com/vs/), which includes the Microsoft Visual C++ compiler (MSVC).\n\nAlternatively, you can also install the [MinGW-w64](https://mingw-w64.org/) compiler system, which is a Windows port of the GNU Compiler Collection (GCC). To install MinGW-w64, follow these steps:\n\n*   Download the installer from [here](https://sourceforge.net/projects/mingw-w64/files/).\n*   Run the installer and select your desired architecture, version, and install location.\n*   Add the `bin` folder inside the installation directory to your system's `PATH` environment variable.\n\n### macOS\n\nFor macOS, you can install the Apple LLVM `clang` compiler which is part of the Xcode Command Line Tools. To do this, open a terminal and enter:\n\n    xcode-select --install\n    \n\nThis will prompt a dialog to install the Command Line Tools, which includes the `clang` compiler.\n\n### Linux\n\nOn Linux, you can install the GNU Compiler Collection (GCC) through your distribution's package manager. Here are some examples for popular Linux distributions:\n\n*   Ubuntu, Debian, and derivatives:\n\n    sudo apt-get install g++ build-essential\n    \n\n*   Fedora, CentOS, RHEL, and derivatives:\n\n    sudo dnf install gcc-c++ make\n    \n\n*   Arch Linux and derivatives:\n\n    sudo pacman -S gcc make\n    \n\n### Checking the Installation\n\nTo confirm that the compiler is installed and available on your system, open a terminal/command prompt, and enter the following command:\n\n    g++ --version\n    \n\nYou should see output displaying the version of your installed C++ compiler.\n\nNow you're ready to start writing and compiling your C++ code!",
    "links": []
  },
  "ew0AfyadpXPRO0ZY3Z19k": {
    "title": "Code Editors / IDEs",
    "description": "Code editors and IDEs are programs specifically designed for editing, managing and writing source code. They offer a wide range of features that make the development process easier and faster. Here's a brief introduction to some of the most popular code editors and IDEs for C++:\n\n*   **Visual Studio**: Visual Studio is an Integrated Development Environment (IDE) for Windows, developed by Microsoft. It includes its own integrated compiler known as Microsoft Visual C++ (MSVC).\n    \n*   **Visual Studio Code (VSCode)**: Visual Studio Code is a popular, free, open-source, and lightweight code editor developed by Microsoft. It offers an extensive library of extensions that enhance functionality for C++ development.\n    \n*   **Sublime Text**: Sublime Text is a cross-platform text editor that is quite popular among developers due to its speed and minimalist design. It supports C++ with the help of plugins and has a variety of themes and packages available for customization.\n    \n*   **CLion**: CLion is an Integrated Development Environment (IDE) developed by JetBrains specifically for C and C++ developers. It provides advanced features like code completion, refactoring support, debugging, and more. It's worth noting that CLion is a commercial IDE, but there is community version available.\n    \n\nThese are just a few examples, and there are many other code editors available, including Atom, Notepad++, and Geany. They all have their features and may suit different developers' needs. Finding the right code editor is often a matter of personal preference and workflow.\n\nTo work with C++ in your chosen code editor, you often need to install some additional tools and add-ons, such as compilers, linters, and debugger support. Make sure to follow the instructions provided in the editor's documentation to set up C++ correctly.\n\nLearn more from the following resources:",
    "links": [
      {
        "title": "Using C++ on Linux in VSCode",
        "url": "https://code.visualstudio.com/docs/cpp/config-linux",
        "type": "article"
      },
      {
        "title": "Explore top posts about General Programming",
        "url": "https://app.daily.dev/tags/general-programming?ref=roadmapsh",
        "type": "article"
      }
    ]
  },
  "SEq0D2Zg5WTsIDtd1hW9f": {
    "title": "Running your First Program",
    "description": "In this section, we'll discuss the basic structure of a C++ program, walk you through your first program (the \"Hello, World!\" example), and provide additional explanations of its syntax.\n\nHello, World!\n-------------\n\nThe first program that most people learn to write in any programming language is often a simple one that displays the message \"Hello, World!\" on the screen. Here's the classic \"Hello, World!\" program in C++:\n\n    #include <iostream>\n    \n    int main() {\n      std::cout << \"Hello, World!\\n\";\n      return 0;\n    }\n    \n\nLet's break down the different components of this program:\n\nHeader Files & Preprocessor Directives\n--------------------------------------\n\nThe first line of the program `#include <iostream>` is a [preprocessor directive](https://en.cppreference.com/w/cpp/preprocessor) that tells the compiler to include the header file `iostream`. Header files provide function and class declarations that we can use in our C++ programs.\n\n    #include <iostream>\n    \n\n`main()` Function\n-----------------\n\nIn C++, the `main()` function serves as the entry point of your program. The operating system runs your program by calling this `main()` function. It should be defined only once in your program and must return an integer. The keyword `int` is the return type of this function which is an integer. Unlike C in C++ it is mandatory to have `int` as the return type for the `main` function.\n\n    int main() {\n      // Your code goes here.\n    }\n    \n\nOutput to the Console\n---------------------\n\nTo output text to the console, we use the `std::cout` object and the insertion operator `<<`. In the \"Hello, World!\" example, we used the following line to print \"Hello, World!\" to the console:\n\n    std::cout << \"Hello, World!\\n\";\n    \n\n*   `std`: This is the namespace where C++ standard library entities (classes and functions) reside. It stands for \"standard\"\n*   `std::cout`: The standard \"character output\" stream that writes to the console\n*   `\"Hello, World!\"`: The string literal to print\n*   `'\\n'`: The \"end line\" manipulator that inserts a newline character and flushes the output buffer\n\nReturn Statement\n----------------\n\nLastly, the `return 0;` statement informs the operating system that the program executed successfully. Returning any other integer value indicates that an error occurred:\n\n    return 0;\n    \n\nNow that you understand the basic components of a C++ program, you can write your first program, compile it, and run it to see the \"Hello, World!\" message displayed on the screen.",
    "links": []
  },
  "kl2JI_Wl47c5r8SYzxvCq": {
    "title": "Basic Operations",
    "description": "Basic operations in C++ refer to the fundamental arithmetic, relational, and logical operations that can be performed using C++ programming language, which are essential for any kind of program or calculation in a real-world scenario.\n\nHere's a summary of the basic operations in C++\n\nArithmetic Operations\n---------------------\n\nThese operations are used for performing calculations in C++ and include the following:\n\n*   **Addition (+)**: Adds two numbers.\n\n    int a = 5;\n    int b = 6;\n    int sum = a + b; // sum is 11\n    \n\n*   **Subtraction (-)**: Subtracts one number from the other.\n\n    int a = 10;\n    int b = 6;\n    int diff = a - b; // diff is 4\n    \n\n*   **Multiplication (\\*)**: Multiplies two numbers.\n\n    int a = 3;\n    int b = 4;\n    int product = a * b; // product is 12\n    \n\n*   **Division (/)**: Divides one number by another, yields quotient.\n\n    int a = 12;\n    int b = 4;\n    int quotient = a / b; // quotient is 3\n    \n\n*   **Modulus (%)**: Divides one number by another, yields remainder.\n\n    int a = 15;\n    int b = 4;\n    int remainder = a % b; // remainder is 3\n    \n\nRelational Operators\n--------------------\n\nThese operations compare two values and return a boolean value (true/false) depending on the comparison. The relational operations are:\n\n*   **Equal to (==)**: Returns true if both operands are equal.\n\n    5 == 5 // true\n    3 == 4 // false\n    \n\n*   **Not equal to (!=)**: Returns true if operands are not equal.\n\n    5 != 2 // true\n    1 != 1 // false\n    \n\n*   **Greater than (>)**: Returns true if the first operand is greater than the second.\n\n    5 > 3 // true\n    2 > 3 // false\n    \n\n*   **Less than (<)**: Returns true if the first operand is less than the second.\n\n    3 < 5 // true\n    6 < 5 // false\n    \n\n*   **Greater than or equal to (>=)**: Returns true if the first operand is greater than or equal to the second.\n\n    5 >= 5 // true\n    6 >= 2 // true\n    3 >= 4 // false\n    \n\n*   **Less than or equal to (<=)**: Returns true if the first operand is less than or equal to the second.\n\n    4 <= 4 // true\n    2 <= 3 // true\n    5 <= 4 // false\n    \n\nLogical Operators\n-----------------\n\nLogical operators are used for combining multiple conditions or boolean values.\n\n*   **AND (&&)**: Returns true if both operands are true.\n\n    true && true // true\n    true && false // false\n    \n\n*   **OR (||)**: Returns true if any one of the operands is true.\n\n    true || false // true\n    false || false // false\n    \n\n*   **NOT (!)**: Returns true if the operand is false and vice versa.\n\n    !true // false\n    !false // true",
    "links": []
  },
  "8aOSpZLWwZv_BEYiurhyR": {
    "title": "Arithmetic Operators",
    "description": "Arithmetic operators are used to perform mathematical operations with basic variables such as integers and floating-point numbers. Here is a brief summary of the different arithmetic operators in C++:\n\n1\\. Addition Operator (`+`)\n---------------------------\n\nIt adds two numbers together.\n\n    int sum = a + b;\n    \n\n2\\. Subtraction Operator (`-`)\n------------------------------\n\nIt subtracts one number from another.\n\n    int difference = a - b;\n    \n\n3\\. Multiplication Operator (`*`)\n---------------------------------\n\nIt multiplies two numbers together.\n\n    int product = a * b;\n    \n\n4\\. Division Operator (`/`)\n---------------------------\n\nIt divides one number by another. Note that if both operands are integers, it will perform integer division and the result will be an integer.\n\n    int quotient = a / b; // integer division\n    float quotient = float(a) / float(b); // floating-point division\n    \n\n5\\. Modulus Operator (`%`)\n--------------------------\n\nIt calculates the remainder of an integer division.\n\n    int remainder = a % b;\n    \n\n6\\. Increment Operator (`++`)\n-----------------------------\n\nIt increments the value of a variable by 1. There are two ways to use this operator: prefix (`++x`) and postfix (`x++`). Prefix increments the value before returning it, whereas postfix returns the value first and then increments it.\n\n    int x = 5;\n    int y = ++x; // x = 6, y = 6\n    int z = x++; // x = 7, z = 6\n    \n\n7\\. Decrement Operator (`--`)\n-----------------------------\n\nIt decrements the value of a variable by 1. It can also be used in prefix (`--x`) and postfix (`x--`) forms.\n\n    int x = 5;\n    int y = --x; // x = 4, y = 4\n    int z = x--; // x = 3, z = 4\n    \n\nThese are the basic arithmetic operators in C++ that allow you to perform mathematical operations on your variables. Use them in combination with other control structures, such as loops and conditionals, to build more complex programs.",
    "links": []
  },
  "Y9gq8WkDA_XGe68JkY2UZ": {
    "title": "Logical Operators",
    "description": "Logical operators are used to perform logical operations on the given expressions, mostly to test the relationship between different variables or values. They return a boolean value i.e., either true (1) or false (0) based on the result of the evaluation.\n\nC++ provides the following logical operators:\n\n*   **AND Operator (&&)** The AND operator checks if both the operands/conditions are true, then the expression is true. If any one of the conditions is false, the whole expression will be false.\n    \n        (expression1 && expression2)\n        \n    \n    Example:\n    \n        int a = 5, b = 10;\n        if (a > 0 && b > 0) {\n            std::cout << \"Both values are positive.\\n\";\n        }\n        \n    \n*   **OR Operator (||)** The OR operator checks if either of the operands/conditions are true, then the expression is true. If both the conditions are false, it will be false.\n    \n        (expression1 || expression2)\n        \n    \n    Example:\n    \n        int a = 5, b = -10;\n        if (a > 0 || b > 0) {\n            std::cout << \"At least one value is positive.\\n\";\n        }\n        \n    \n*   **NOT Operator (!)** The NOT operator reverses the result of the condition/expression it is applied on. If the condition is true, the NOT operator will make it false and vice versa.\n    \n        !(expression)\n        \n    \n    Example:\n    \n        int a = 5;\n        if (!(a < 0)) {\n            std::cout << \"The value is not negative.\\n\";\n        }\n        \n    \n\nUsing these operators, you can create more complex logical expressions, for example:\n\n    int a = 5, b = -10, c = 15;\n    \n    if (a > 0 && (b > 0 || c > 0)) {\n        std::cout << \"At least two values are positive.\\n\";\n    }\n    \n\nThis covers the essential information about logical operators in C++.",
    "links": []
  },
  "zE4iPSq2KsrDSByQ0sGK_": {
    "title": "Bitwise Operators",
    "description": "Bitwise operations are operations that directly manipulate the bits of a number. Bitwise operations are useful for various purposes, such as optimizing algorithms, performing certain calculations, and manipulating memory in lower-level programming languages like C and C++.\n\nHere is a quick summary of common bitwise operations in C++:\n\nBitwise AND (`&`)\n-----------------\n\nThe bitwise AND operation (`&`) is a binary operation that takes two numbers, compares them bit by bit, and returns a new number where each bit is set (1) if the corresponding bits in both input numbers are set (1); otherwise, the bit is unset (0).\n\nExample:\n\n    int result = 5 & 3; // result will be 1 (0000 0101 & 0000 0011 = 0000 0001)\n    \n\nBitwise OR (`|`)\n----------------\n\nThe bitwise OR operation (`|`) is a binary operation that takes two numbers, compares them bit by bit, and returns a new number where each bit is set (1) if at least one of the corresponding bits in either input number is set (1); otherwise, the bit is unset (0).\n\nExample:\n\n    int result = 5 | 3; // result will be 7 (0000 0101 | 0000 0011 = 0000 0111)\n    \n\nBitwise XOR (`^`)\n-----------------\n\nThe bitwise XOR (exclusive OR) operation (`^`) is a binary operation that takes two numbers, compares them bit by bit, and returns a new number where each bit is set (1) if the corresponding bits in the input numbers are different; otherwise, the bit is unset (0).\n\nExample:\n\n    int result = 5 ^ 3; // result will be 6 (0000 0101 ^ 0000 0011 = 0000 0110)\n    \n\nBitwise NOT (`~`)\n-----------------\n\nThe bitwise NOT operation (`~`) is a unary operation that takes a single number, and returns a new number where each bit is inverted (1 becomes 0, and 0 becomes 1).\n\nExample:\n\n    int result = ~5; // result will be -6 (1111 1010)\n    \n\nBitwise Left Shift (`<<`)\n-------------------------\n\nThe bitwise left shift operation (`<<`) is a binary operation that takes two numbers, a value and a shift amount, and returns a new number by shifting the bits of the value to the left by the specified shift amount. The vacated bits are filled with zeros.\n\nExample:\n\n    int result = 5 << 1; // result will be 10 (0000 0101 << 1 = 0000 1010)\n    \n\nBitwise Right Shift (`>>`)\n--------------------------\n\nThe bitwise right shift operation (`>>`) is a binary operation that takes two numbers, a value and a shift amount, and returns a new number by shifting the bits of the value to the right by the specified shift amount. The vacated bits are filled with zeros or sign bit depending on the input value being signed or unsigned.\n\nExample:\n\n    int result = 5 >> 1; // result will be 2 (0000 0101 >> 1 = 0000 0010)\n    \n\nThese were the most common bitwise operations in C++. Remember to use them carefully and understand their behavior when applied to specific data types and scenarios.\n\nLearn more from the following resources:",
    "links": [
      {
        "title": "Intro to Binary and Bitwise Operators in C++",
        "url": "https://youtu.be/KXwRt7og0gI",
        "type": "video"
      },
      {
        "title": "Bitwise AND (&), OR (|), XOR (^) and NOT (~) in C++",
        "url": "https://youtu.be/HoQhw6_1NAA",
        "type": "video"
      }
    ]
  },
  "s5Gs4yF9TPh-psYmtPzks": {
    "title": "Control Flow & Statements",
    "description": "",
    "links": []
  },
  "_IP_e1K9LhNHilYTDh7L5": {
    "title": "for / while / do while loops",
    "description": "Loops are an essential concept in programming that allow you to execute a block of code repeatedly until a specific condition is met. In C++, there are three main types of loops: `for`, `while`, and `do-while`.\n\nFor Loop\n--------\n\nA `for` loop is used when you know the number of times you want to traverse through a block of code. It consists of an initialization statement, a condition, and an increment/decrement operation.\n\nHere's the syntax for a `for` loop:\n\n    for (initialization; condition; increment/decrement) {\n        // block of code to execute\n    }\n    \n\nFor example:\n\n    #include <iostream>\n    \n    int main() {\n        for (int i = 0; i < 5; i++) {\n            std::cout << \"Iteration: \" << i << '\\n';\n        }\n        return 0;\n    }\n    \n\nWhile Loop\n----------\n\nA `while` loop runs as long as a specified condition is `true`. The loop checks for the condition before entering the body of the loop.\n\nHere's the syntax for a `while` loop:\n\n    while (condition) {\n        // block of code to execute\n    }\n    \n\nFor example:\n\n    #include <iostream>\n    \n    int main() {\n        int i = 0;\n        while (i < 5) {\n            std::cout << \"Iteration: \" << i << '\\n';\n            i++;\n        }\n        return 0;\n    }\n    \n\nDo-While Loop\n-------------\n\nA `do-while` loop is similar to a `while` loop, with the key difference being that the loop body is executed at least once, even when the condition is `false`.\n\nHere's the syntax for a `do-while` loop:\n\n    do {\n        // block of code to execute\n    } while (condition);\n    \n\nFor example:\n\n    #include <iostream>\n    \n    int main() {\n        int i = 0;\n        do {\n            std::cout << \"Iteration: \" << i << '\\n';\n            i++;\n        } while (i < 5);\n        return 0;\n    }\n    \n\nIn summary, loops are an integral part of C++ programming that allow you to execute a block of code multiple times. The three types of loops in C++ are `for`, `while`, and `do-while`. Each type has its own specific use case and can be chosen depending on the desired behavior.\n\nLearn more from the following resources:",
    "links": [
      {
        "title": "C++ For Loop",
        "url": "https://www.w3schools.com/cpp/cpp_for_loop.asp",
        "type": "article"
      }
    ]
  },
  "bjpFWxiCKGz28E-ukhZBp": {
    "title": "if else / switch / goto",
    "description": "C++ provides you with tools which helps you to control the way your program behaves (logic flows) based on how the user interact with your program. Here we will discuss about `if-else`, `switch` and `goto` are three common ways to guide the flow of logic in your code.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "The 'if-else' Statement in C++",
        "url": "https://www.youtube.com/watch?v=9-BjXs1vMSc",
        "type": "video"
      },
      {
        "title": "Learn C++ With Me - Switch Statement",
        "url": "https://www.youtube.com/watch?v=uOlLs1OYSSI",
        "type": "video"
      },
      {
        "title": "Why is it illegal to use \"goto\"?",
        "url": "https://youtu.be/AKJhThyTmQw?si=gjEqAsDZVMDGVAT2",
        "type": "video"
      }
    ]
  },
  "oYi3YOc1GC2Nfp71VOkJt": {
    "title": "Functions",
    "description": "A **function** is a group of statements that perform a specific task, organized as a separate unit in a program. Functions help in breaking the code into smaller, manageable, and reusable blocks.\n\nThere are mainly two types of functions in C++:\n\n*   **Standard library functions**: Pre-defined functions available in the C++ standard library, such as `sort()`, `strlen()`, `sqrt()`, and many more. These functions are part of the standard library, so you need to include the appropriate header file to use them.\n    \n*   **User-defined functions**: Functions created by the programmer to perform a specific task. To create a user-defined function, you need to define the function and call it in your code.\n    \n\nDefining a Function\n-------------------\n\nThe general format for defining a function in C++ is:\n\n    return_type function_name(parameter list) {\n        // function body\n    }\n    \n\n*   `return_type`: Data type of the output produced by the function. It can be `void`, indicating that the function doesn't return any value.\n*   `function_name`: Name given to the function, following C++ naming conventions.\n*   `parameter list`: List of input parameters/arguments that are needed to perform the task. It is optional, you can leave it blank when no parameters are needed.\n\nExample\n-------\n\n    #include <iostream>\n    \n    // Function to add two numbers\n    int addNumbers(int a, int b) {\n        int sum = a + b;\n        return sum;\n    }\n    \n    int main() {\n        int num1 = 5, num2 = 10;\n        int result = addNumbers(num1, num2); // Calling the function\n        std::cout << \"The sum is: \" << result << '\\n';\n        return 0;\n    }\n    \n\nIn this example, the function `addNumbers` takes two integer parameters, `a` and `b`, and returns the sum of the numbers. We then call this function from the `main()` function and display the result.\n\nFunction Prototypes\n-------------------\n\nIn some cases, you might want to use a function before actually defining it. To do this, you need to declare a **function prototype** at the beginning of your code.\n\nA function prototype is a declaration of the function without its body, and it informs the compiler about the function's name, return type, and parameters.\n\n    #include <iostream>\n    \n    // Function prototype\n    int multiplyNumbers(int x, int y);\n    \n    int main() {\n        int num1 = 3, num2 = 7;\n        int result = multiplyNumbers(num1, num2); // Calling the function\n        std::cout << \"The product is: \" << result << '\\n';\n        return 0;\n    }\n    \n    // Function definition\n    int multiplyNumbers(int x, int y) {\n        int product = x * y;\n        return product;\n    }\n    \n\nIn this example, we use a function prototype for `multiplyNumbers()` before defining it. This way, we can call the function from the `main()` function even though it hasn't been defined yet in the code.\n\nLearn more from the following resources:",
    "links": [
      {
        "title": "introduction to functions in c++",
        "url": "https://www.learncpp.com/cpp-tutorial/introduction-to-functions/",
        "type": "article"
      }
    ]
  },
  "obZIxRp0eMWdG7gplNIBc": {
    "title": "Static Polymorphism",
    "description": "Static polymorphism, also known as compile-time polymorphism, is a type of polymorphism that resolves the types and method calls at compile time rather than at runtime. This is commonly achieved through the use of function overloading and templates in C++.\n\nFunction Overloading\n--------------------\n\nFunction overloading is a way to create multiple functions with the same name but different parameter lists. The compiler determines the correct function to call based on the types and number of arguments used when the function is called.\n\nExample:\n\n    #include <iostream>\n    \n    void print(int i) {\n        std::cout << \"Printing int: \" << i << '\\n';\n    }\n    \n    void print(double d) {\n        std::cout << \"Printing double: \" << d << '\\n';\n    }\n    \n    void print(const char* s) {\n        std::cout << \"Printing string: \" << s << '\\n';\n    }\n    \n    int main() {\n        print(5);          // Calls print(int i)\n        print(3.14);       // Calls print(double d)\n        print(\"Hello\");    // Calls print(const char* s)\n    \n        return 0;\n    }\n    \n\nTemplates\n---------\n\nTemplates are a powerful feature in C++ that allows you to create generic functions or classes. The actual code for specific types is generated at compile time, which avoids the overhead of runtime polymorphism. The use of templates is the main technique to achieve static polymorphism in C++.\n\nExample:\n\n    #include <iostream>\n    \n    // Template function to print any type\n    template<typename T>\n    void print(const T& value) {\n        std::cout << \"Printing value: \" << value << '\\n';\n    }\n    \n    int main() {\n        print(42);           // int\n        print(3.14159);      // double\n        print(\"Hello\");      // const char*\n    \n        return 0;\n    }\n    \n\nIn conclusion, static polymorphism achieves polymorphic behavior during compile time using function overloading and templates, instead of relying on runtime information like dynamic polymorphism does. This can result in more efficient code since method calls are resolved at compile time.",
    "links": []
  },
  "sgfqb22sdN4VRJYkhAVaf": {
    "title": "Function Overloading",
    "description": "Function overloading in C++ allows multiple functions to share the same name, provided they differ in the number or types of parameters. This facilitates compile-time polymorphism, enhancing code readability and maintainability by enabling functions to perform similar operations on different data types or argument counts.\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Function Overloading - Microsoft Learn",
        "url": "https://learn.microsoft.com/en-us/cpp/cpp/function-overloading",
        "type": "article"
      }
    ]
  },
  "llCBeut_uc9IAe2oi4KZ9": {
    "title": "Operator Overloading",
    "description": "Operator overloading in C++ is a feature that allows you to redefine the way operators work for user-defined types (such as classes and structs). It lets you specify how operators like +, -, \\*, ==, etc., behave when applied to objects of your class. Visit the following resources to learn more:\n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "Operator Overloading - Microsoft Learn",
        "url": "https://learn.microsoft.com/en-us/cpp/cpp/operator-overloading",
        "type": "article"
      },
      {
        "title": "operator overloading - cppreference.com",
        "url": "https://en.cppreference.com/w/cpp/language/operators",
        "type": "article"
      }
    ]
  },
  "xjiFBVe-VGqCqWfkPVGKf": {
    "title": "Lambdas",
    "description": "A lambda function, or simply \"lambda\", is an anonymous (unnamed) function that is defined in place, within your source code, and with a concise syntax. Lambda functions were introduced in C++11 and have since become a widely used feature, especially in combination with the Standard Library algorithms.\n\nSyntax\n------\n\nHere is a basic syntax of a lambda function in C++:\n\n    [capture-list](parameters) -> return_type {\n        // function body\n    };\n    \n\n*   **capture-list**: A list of variables from the surrounding scope that the lambda function can access.\n*   **parameters**: The list of input parameters, just like in a regular function. Optional.\n*   **return\\_type**: The type of the value that the lambda function will return. This part is optional, and the compiler can deduce it in many cases.\n*   **function body**: The code that defines the operation of the lambda function.\n\nUsage Examples\n--------------\n\nHere are a few examples to demonstrate the use of lambda functions in C++:\n\n*   Lambda function with no capture, parameters, or return type.\n\n    auto printHello = []() {\n        std::cout << \"Hello, World!\\n\";\n    };\n    printHello(); // Output: Hello, World!\n    \n\n*   Lambda function with parameters.\n\n    auto add = [](int a, int b) {\n        return a + b;\n    };\n    int result = add(3, 4); // result = 7\n    \n\n*   Lambda function with capture-by-value.\n\n    int multiplier = 3;\n    auto times = [multiplier](int a) {\n        return a * multiplier;\n    };\n    int result = times(5); // result = 15\n    \n\n*   Lambda function with capture-by-reference.\n\n    int expiresInDays = 45;\n    auto updateDays = [&expiresInDays](int newDays) {\n        expiresInDays = newDays;\n    };\n    updateDays(30); // expiresInDays = 30\n    \n\nNote that, when using the capture by reference, any change made to the captured variable _inside_ the lambda function will affect its value in the surrounding scope.\n\nLearn more from the following resources:",
    "links": [
      {
        "title": "Lambda Expressions",
        "url": "https://en.cppreference.com/w/cpp/language/lambda",
        "type": "article"
      },
      {
        "title": "Explore top posts about AWS Lambda",
        "url": "https://app.daily.dev/tags/aws-lambda?ref=roadmapsh",
        "type": "article"
      },
      {
        "title": "Lambdas in C++",
        "url": "https://youtu.be/MH8mLFqj-n8",
        "type": "video"
      }
    ]
  },
  "MwznA4qfpNlv6sqSNjPZi": {
    "title": "Data Types",
    "description": "In C++, data types are used to categorize different types of data that a program can process. They are essential for determining the type of value a variable can hold and how much memory space it will occupy. Some basic data types in C++ include integers, floating-point numbers, characters, and booleans.\n\nFundamental Data Types\n----------------------\n\nInteger (int)\n-------------\n\nIntegers are whole numbers that can store both positive and negative values. The size of `int` depends on the system architecture (usually 4 bytes).\n\nExample:\n\n    int num = 42;\n    \n\nThere are variants of `int` that can hold different ranges of numbers:\n\n*   short (`short int`): Smaller range than `int`.\n*   long (`long int`): Larger range than `int`.\n*   long long (`long long int`): Even larger range than `long int`.\n\nFloating-Point (float, double)\n------------------------------\n\nFloating-point types represent real numbers, i.e., numbers with a decimal point. There are two main floating-point types:\n\n*   **float**: Provides single-precision floating-point numbers. It typically occupies 4 bytes of memory.\n\nExample:\n\n    float pi = 3.14f;\n    \n\n*   **double**: Provides double-precision floating-point numbers. It consumes more memory (usually 8 bytes) but has a higher precision than `float`.\n\nExample:\n\n    double pi_high_precision = 3.1415926535;\n    \n\nCharacter (char)\n----------------\n\nCharacters represent a single character, such as a letter, digit, or symbol. They are stored using the ASCII value of the symbol and typically occupy 1 byte of memory.\n\nExample:\n\n    char letter = 'A';\n    \n\nBoolean (bool)\n--------------\n\nBooleans represent logical values: `true` or `false`. They usually occupy 1 byte of memory.\n\nExample:\n\n    bool is_cpp_great = true;\n    \n\nDerived Data Types\n------------------\n\nDerived data types are types that are derived from fundamental data types. Some examples include:\n\nArrays\n------\n\nArrays are used to store multiple values of the same data type in consecutive memory locations.\n\nExample:\n\n    int numbers[5] = {1, 2, 3, 4, 5};\n    \n\nPointers\n--------\n\nPointers are used to store the memory address of a variable.\n\nExample:\n\n    int num = 42;\n    int* pNum = &num;\n    \n\nReferences\n----------\n\nReferences are an alternative way to share memory locations between variables, allowing you to create an alias for another variable.\n\nExample:\n\n    int num = 42;\n    int& numRef = num;\n    \n\nUser-Defined Data Types\n-----------------------\n\nUser-defined data types are types that are defined by the programmer, such as structures, classes, and unions.\n\nStructures (struct)\n-------------------\n\nStructures are used to store different data types under a single variable and accessibility of member variables and methods are public.\n\nExample:\n\n    struct Person {\n        std::string name;\n        int age;\n        float height;\n    };\n    \n    Person p1 = {\"John Doe\", 30, 5.9};\n    \n\nClasses (class)\n---------------\n\nClasses are similar to structures, but the accessibility of the member data and function are governed by access specifiers. By default access to members of a class is private.\n\nExample:\n\n    class Person {\n    public:\n        std::string name;\n        int age;\n    \n        void printInfo() {\n            std::cout << \"Name: \" << name << \", Age: \" << age << '\\n';\n        };\n    };\n    \n    Person p1;\n    p1.name = \"John Doe\";\n    p1.age = 30;\n    \n\nUnions (union)\n--------------\n\nUnions are used to store different data types in the same memory location.\n\nExample:\n\n    union Data {\n        int num;\n        char letter;\n        float decimal;\n    };\n    \n    Data myData;\n    myData.num = 42;",
    "links": []
  },
  "f1djN0GxoeVPr_0cl6vMq": {
    "title": "Static Typing",
    "description": "In C++, static typing means that the data type of a variable is determined at compile time, before the program is executed. This means that a variable can only be used with data of a specific type, and the compiler ensures that the operations performed with the variable are compatible with its type. If there is a mismatch, the compiler will adjust the data type of variable to match another provided it's feasible. This process is known as `Type Conversion`. If the compiler is not able to achieve type conversion, an `Invalid Type Conversion` error will be raised during compilation of the code.\n\nC++ is a statically typed language, which means that it uses static typing to determine data types and perform type checking during compile time. This helps with ensuring type safety and can prevent certain types of errors from occurring during the execution of the program.\n\nHere's a simple code example to demonstrate static typing in C++:\n\n    #include <iostream>\n    \n    int main() {\n        int num = 65;        // 'num' is statically typed as an integer\n        double pi = 3.14159; // 'pi' is statically typed as a double\n        char c = 'c';        // 'c' is statically typed as a char\n    \n        c = num;    // This asssigment would convert num's value to ASCII equivalent character\n        num = pi; // This assignment would convert pi's value from double type to int type\n        \n        std::cout << \"The value of num is: \" << num << '\\n';\n        std::cout << \"The value of pi is: \" << pi << '\\n';\n        std::cout << \"The value of c is: \"<< c << '\\n';\n        return 0;\n    }\n    \n\nIn the code above, the variable `num` is statically typed as an `int`, `pi` is statically typed as a `double`, and `c` is statically typed as a `char`. If you attempt to assign the value of `pi` to `num`, the value `3.14159` will be converted to the integer `3` and assigned to `num`. Similarly, when the value of `num` is assigned to `c`, the compiler will convert the value `65` to its corresponding [ASCII](https://www.ascii-code.com) code, which is `A`.\n\nLearn more from the following resources:",
    "links": [
      {
        "title": "Type-Coversion",
        "url": "https://www.programiz.com/cpp-programming/type-conversion",
        "type": "article"
      },
      {
        "title": "Static Vs Dynamic",
        "url": "https://www.techtarget.com/searchapparchitecture/tip/Static-vs-dynamic-typing-The-details-and-differences",
        "type": "article"
      }
    ]
  },
  "i0EAFEUB-F0wBJWOtrl1A": {
    "title": "Dynamic Typing",
    "description": "C++ is known as a statically-typed language, which means the data types of its variables are determined at compile time. However, C++ also provides concepts to have certain level of _dynamic typing_, which means determining the data types of variables at runtime.\n\nHere is a brief overview of two ways to achieve dynamic typing in C++:\n\n`void*` Pointers\n----------------\n\nA `void*` pointer is a generic pointer that can point to objects of any data type. They can be used to store a reference to any type of object without knowing the specific type of the object.\n\nExample:\n\n    #include <iostream>\n    \n    int main() {\n        int x = 42;\n        float y = 3.14f;\n        std::string z = \"Hello, world!\";\n    \n        void* void_ptr;\n    \n        void_ptr = &x;\n        std::cout << \"int value: \" << *(static_cast<int*>(void_ptr)) << '\\n';\n    \n        void_ptr = &y;\n        std::cout << \"float value: \" << *(static_cast<float*>(void_ptr)) << '\\n';\n    \n        void_ptr = &z;\n        std::cout << \"string value: \" << *(static_cast<std::string*>(void_ptr)) << '\\n';\n    \n        return 0;\n    }\n    \n\n`std::any` (C++17)\n------------------\n\nC++17 introduced the `std::any` class which represents a generalized type-safe container for single values of any type.\n\nExample:\n\n    #include <iostream>\n    #include <any>\n    \n    int main() {\n        std::any any_value;\n    \n        any_value = 42;\n        std::cout << \"int value: \" << std::any_cast<int>(any_value) << '\\n';\n    \n        any_value = 3.14;\n        std::cout << \"double value: \" << std::any_cast<double>(any_value) << '\\n';\n    \n        any_value = std::string(\"Hello, world!\");\n        std::cout << \"string value: \" << std::any_cast<std::string>(any_value) << '\\n';\n    \n        return 0;\n    }\n    \n\nKeep in mind that both `void*` pointers and `std::any` have performance implications due to the additional type checking and casting that take place during runtime. They should be used carefully and only when absolutely necessary.",
    "links": []
  },
  "r0yD1gfn03wTpEBi6zNsu": {
    "title": "RTTI",
    "description": "Run-Time Type Identification (RTTI) is a feature in C++ that allows you to obtain the type information of an object during program execution. This can be useful when using dynamic typing, where the type of an object can change at runtime.\n\nThere are two main mechanisms for RTTI in C++:\n\n*   `typeid` operator\n*   `dynamic_cast` operator\n\ntypeid operator\n---------------\n\n`typeid` is an operator that returns a reference to an object of type `std::type_info`, which contains information about the type of the object. The header file `<typeinfo>` should be included to use `typeid`.\n\nHere is an example:\n\n    #include <iostream>\n    #include <typeinfo>\n    \n    class Base { virtual void dummy() {} };\n    class Derived : public Base { /* ... */ };\n    \n    int main() {\n        Base* base_ptr = new Derived;\n    \n        // Using typeid to get the type of the object\n        std::cout << \"Type: \" << typeid(*base_ptr).name() << '\\n';\n    \n        delete base_ptr;\n        return 0;\n    }\n    \n\ndynamic\\_cast operator\n----------------------\n\n`dynamic_cast` is a type-casting operator that performs a runtime type check and safely downcasts a base pointer or reference to a derived pointer or reference. It returns null or throws a bad\\_cast exception (if casting references) when the casting fails.\n\nHere is an example:\n\n    #include <iostream>\n    \n    class Base { virtual void dummy() {} };\n    class Derived1 : public Base { /* ... */ };\n    class Derived2 : public Base { /* ... */ };\n    \n    int main() {\n        Base* base_ptr = new Derived1;\n    \n        // Using dynamic_cast to safely downcast the pointer\n        Derived1* derived1_ptr = dynamic_cast<Derived1*>(base_ptr);\n        if (derived1_ptr) {\n            std::cout << \"Downcast to Derived1 successful\\n\";\n        }\n        else {\n            std::cout << \"Downcast to Derived1 failed\\n\";\n        }\n    \n        Derived2* derived2_ptr = dynamic_cast<Derived2*>(base_ptr);\n        if (derived2_ptr) {\n            std::cout << \"Downcast to Derived2 successful\\n\";\n        }\n        else {\n            std::cout << \"Downcast to Derived2 failed\\n\";\n        }\n    \n        delete base_ptr;\n        return 0;\n    }\n    \n\nPlease note that the use of RTTI can have some performance overhead, as it requires additional compiler-generated information to be stored and processed during runtime.",
    "links": []
  },
  "DWw8NxkLpIpiOSUaZZ1oA": {
    "title": "Pointers and References",
    "description": "A pointer is a variable that stores the memory address of another variable (or function). It points to the location of the variable in memory, and it allows you to access or modify the value indirectly. Here's a general format to declare a pointer:\n\n    dataType *pointerName;\n    \n\n**Initializing a pointer:**\n\n    int num = 10;\n    int *ptr = &num;  // Pointer 'ptr' now points to the memory address of 'num'\n    \n\n**Accessing value using a pointer:**\n\n    int value = *ptr; // Value now contains the value of the variable that 'ptr' points to (i.e., 10)\n    \n\n**Function pointer:**\n\n    int add(int a, int b)\n    {\n      return a + b;\n    }\n    \n    int main()\n    {\n      int (*funcptr) (int, int) = add; // Pointer 'funcptr' now points to the functions 'add'\n      funcptr(4, 5); // Return 9\n    }\n    \n\nReferences\n----------\n\nA reference is an alias for an existing variable, meaning it's a different name for the same memory location. Unlike pointers, references cannot be null, and they must be initialized when they are declared. Once a reference is initialized, it cannot be changed to refer to another variable.\n\nHere's a general format to declare a reference:\n\n    dataType &referenceName = existingVariable;\n    \n\n**Example:**\n\n    int num = 10;\n    int &ref = num; // Reference 'ref' is now an alias of 'num'\n    \n\nModifying the value of `ref` will also modify the value of `num` because they share the same memory location.\n\n**Note:** References are generally used when you want to pass a variable by reference in function arguments or when you want to create an alias for a variable without the need for pointer syntax.\n\nLearn more from the following resources:",
    "links": [
      {
        "title": "Function Pointer in C++",
        "url": "https://www.scaler.com/topics/cpp/function-pointer-cpp/",
        "type": "article"
      }
    ]
  },
  "uUzRKa9wGzdUwwmAg3FWr": {
    "title": "References",
    "description": "A reference can be considered as a constant pointer (not to be confused with a pointer to a constant value) which always points to (references) the same object. They are declared using the `&` (ampersand) symbol.\n\nDeclaration and Initialization\n------------------------------\n\nTo declare a reference, use the variable type followed by the `&` symbol and the reference's name. Note that you must initialize a reference when you declare it.\n\n    int var = 10;        // Declare an integer variable\n    int& ref = var;      // Declare a reference that \"points to\" var\n    \n\nUsage\n-----\n\nYou can use the reference just like you'd use the original variable. When you change the value of the reference, the value of the original variable also changes, because they both share the same memory location.\n\n    var = 20;            // Sets the value of var to 20\n    std::cout << ref << '\\n'; // Outputs 20\n    \n    ref = 30;            // Sets the value of ref to 30\n    std::cout << var << '\\n'; // Outputs 30\n    \n\nFunction Parameters\n-------------------\n\nYou can use references as function parameters to create an alias for an argument. This is commonly done when you need to modify the original variable or when passing an object of considerable size to avoid the cost of copying.\n\n    void swap(int& a, int& b) {\n        int temp = a;\n        a = b;\n        b = temp;\n    }\n    \n    int main() {\n       int x = 5, y = 10;\n       std::cout << \"Before Swap: x = \" << x << \" y = \" << y << '\\n'; // Outputs 5 10\n       \n       swap(x, y);\n       std::cout << \"After Swap: x = \" << x << \" y = \" << y << '\\n';  // Outputs 10 5\n    }",
    "links": []
  },
  "mSFwsTYvmg-GwG4_DEIEf": {
    "title": "Memory Model",
    "description": "The memory model in C++ defines how the program stores and accesses data in computer memory. It consists of different segments, such as the Stack, Heap, Data and Code segments. Each of these segments is used to store different types of data and has specific characteristics.\n\nStack Memory\n------------\n\nStack memory is used for automatic storage duration variables, such as local variables and function call data. Stack memory is managed by the compiler, and it's allocation and deallocation are done automatically. The stack memory is also a LIFO (Last In First Out) data structure, meaning that the most recent data allocated is the first to be deallocated.\n\n    void functionExample() {\n        int x = 10; // x is stored in the stack memory\n    }\n    \n\nHeap Memory\n-----------\n\nHeap memory is used for dynamic storage duration variables, such as objects created using the `new` keyword. The programmer has control over the allocation and deallocation of heap memory using `new` and `delete` operators. Heap memory is a larger pool of memory than the stack, but has a slower access time.\n\n    void functionExample() {\n        int* p = new int; // dynamically allocated int in heap memory\n        *p = 10;\n        // more code\n        delete p; // deallocate memory\n    }\n    \n\nData Segment\n------------\n\nThe Data segment is composed of two parts: the initialized data segment and the uninitialized data segment. The initialized data segment stores global, static, and constant variables with initial values, whereas the uninitialized segment stores uninitialized global and static variables.\n\n    // Initialized data segment\n    int globalVar = 10; // global variables\n    static int staticVar = 10; // static local variables\n    const int constVar = 10; // constant variables with value\n    \n    // Uninitialized data segment\n    int globalVar; // uninitialized global variables\n    \n\nCode Segment\n------------\n\nThe Code segment (also known as the Text segment) stores the executable code (machine code) of the program. It's usually located in a read-only area of memory to prevent accidental modification.\n\n    void functionExample() {\n        // The machine code for this function is stored in the code segment.\n    }\n    \n\nIn summary, understanding the memory model in C++ helps to optimize the usage of memory resources and improves overall program performance.",
    "links": []
  },
  "9aA_-IfQ9WmbPgwic0mFN": {
    "title": "Lifetime of Objects",
    "description": "Object lifetime refers to the time during which an object exists, from the moment it is created until it is destroyed. In C++, an object's lifetime can be classified into four categories:\n\n*   **Static Storage Duration**: Objects with static storage duration exist for the entire run of the program. These objects are allocated at the beginning of the program's run and deallocated when the program terminates. Global variables, static data members, and static local variables fall into this category.\n    \n        int global_var;            // Static storage duration\n        class MyClass {\n          static int static_var;   // Static storage duration\n        };\n        void myFunction() {\n          static int local_var;    // Static storage duration\n        }\n        \n    \n*   **Thread Storage Duration**: Objects with thread storage duration exist for the lifetime of the thread they belong to. They are created when a thread starts and destroyed when the thread exits. Thread storage duration can be specified using the `thread_local` keyword.\n    \n        thread_local int my_var;   // Thread storage duration\n        \n    \n*   **Automatic Storage Duration**: Objects with automatic storage duration are created at the point of definition and destroyed when the scope in which they are declared is exited. These objects are also known as \"local\" or \"stack\" objects. Function parameters and local non-static variables fall into this category.\n    \n        void myFunction() {\n          int local_var;           // Automatic storage duration\n        }\n        \n    \n*   **Dynamic Storage Duration**: Objects with dynamic storage duration are created at runtime, using memory allocation functions such as `new` or `malloc`. The lifetime of these objects must be managed manually, as they are not automatically deallocated when the scope is exited. Instead, it is the programmer's responsibility to destroy the objects using the `delete` or `free` functions when they are no longer needed, to avoid memory leaks.\n    \n        int* ptr = new int;        // Dynamic storage duration\n        delete ptr;\n        \n    \n\nUnderstanding object lifetimes is essential for managing memory efficiently in C++ programs and avoiding common issues like memory leaks and undefined behavior.\n\nKeep in mind that a proper understanding of constructors and destructors for classes is also essential when working with objects of varying lifetimes, as they allow you to control the behavior of object creation and destruction.",
    "links": []
  },
  "ulvwm4rRPgkpgaqGgyH5a": {
    "title": "Smart Pointers",
    "description": "",
    "links": []
  },
  "vUwSS-uX36OWZouO0wOcy": {
    "title": "weak_ptr",
    "description": "",
    "links": []
  },
  "b5jZIZD_U_CPg-_bdndjz": {
    "title": "shared_ptr",
    "description": "",
    "links": []
  },
  "k9c5seRkhgm_yHPpiz2X0": {
    "title": "unique_ptr",
    "description": "One of C++'s main features includes variants of the normal _raw_ C pointers. One of these is the `unique_ptr`, which is a type of smart pointer that claims exclusive ownership over a value.\n\nThese types of pointers **can be moved** (`std::move`), but not **copied** and are automatically deleted when out of scope. The recommended way to create a `unique_ptr` is using `std::make_unique`.\n\n    #include <memory>\n    #include <iostream>\n    \n    int main() {\n        std::unique_ptr<int> uptr = std::make_unique<int>(10);\n        std::cout << *uptr << std::endl;\n    \n        std::unique_ptr<int> uptr2 = uptr; // compile error\n        std::unique_ptr<int> uptr2 = std::move(uptr); // transferring ownership\n    }",
    "links": [
      {
        "title": "std::unique_ptr - Detailed Reference",
        "url": "https://en.cppreference.com/w/cpp/memory/unique_ptr",
        "type": "article"
      },
      {
        "title": "Smart Pointers – unique_ptr",
        "url": "https://www.learncpp.com/cpp-tutorial/unique-ptr/",
        "type": "article"
      },
      {
        "title": "When should you use std::unique_ptr? - StackOverflow Discussion",
        "url": "https://stackoverflow.com/questions/13782051/when-should-you-use-stdunique-ptr",
        "type": "video"
      }
    ]
  },
  "uEGEmbxegATIrvGfobJb9": {
    "title": "Raw Pointers",
    "description": "",
    "links": []
  },
  "Gld0nRs0sM8kRe8XmYolu": {
    "title": "New/Delete Operators",
    "description": "",
    "links": []
  },
  "6w0WExQ4lGIGgok6Thq0s": {
    "title": "Memory Leakage",
    "description": "",
    "links": []
  },
  "Zw2AOTK5uc9BoKEpY7W1C": {
    "title": "Structuring Codebase",
    "description": "Structuring codebase is an essential part of software development that deals with organizing and modularizing your code to make it more maintainable, efficient, and easier to understand. A well-structured codebase enhances collaboration, simplifies adding new features, and makes debugging faster. In C++, there are various techniques to help you structure your codebase effectively.\n\nNamespaces\n----------\n\nNamespaces are one of the tools in C++ to organize your code by providing a named scope for different identifiers you create, like functions, classes, and variables. They help avoid name clashes and make your code more modular.\n\n    namespace MyNamespace {\n        int aFunction() {\n            // function implementation\n        }\n    }\n    // to use the function\n    MyNamespace::aFunction();\n    \n\nInclude Guards\n--------------\n\nInclude guards are a tool for preventing multiple inclusions of a header file in your project. They consist of preprocessor directives that conditionally include the header file only once, even if it's included in multiple places.\n\n    #ifndef MY_HEADER_FILE_H\n    #define MY_HEADER_FILE_H\n    \n    // Your code here\n    \n    #endif // MY_HEADER_FILE_H\n    \n\nHeader and Source Files\n-----------------------\n\nSeparating your implementation and declarations into header (_.h) and source (_.cpp) files is a key aspect of structuring your codebase in C++. Header files usually contain class and function declarations, while source files contain their definitions.\n\n// MyClass.h\n\n    #ifndef MY_CLASS_H\n    #define MY_CLASS_H\n    \n    class MyClass\n    {\n    public:\n        MyClass();\n        int myMethod();\n    };\n     \n    #endif // MY_CLASS_H\n    \n\n// MyClass.cpp\n\n    #include \"MyClass.h\"\n    \n    MyClass::MyClass() {\n        // constructor implementation\n    }\n    \n    int MyClass::myMethod() {\n        // method implementation\n    }\n    \n\nCode Formatting\n---------------\n\nConsistent code formatting and indentation play a crucial role in structuring your codebase, making it easier to read and understand for both you and other developers. A style guide such as the [Google C++ Style Guide](https://google.github.io/styleguide/cppguide.html) can help you maintain consistent formatting throughout your project.",
    "links": []
  },
  "dKCYmxDNZubCVcR5rf8b-": {
    "title": "Scope",
    "description": "**Scope** refers to the visibility and accessibility of variables, functions, classes, and other identifiers in a C++ program. It determines the lifetime and extent of these identifiers. In C++, there are four types of scope:\n\n*   **Global scope:** Identifiers declared outside any function or class have a global scope. They can be accessed from any part of the program (unless hidden by a local identifier with the same name). The lifetime of a global identifier is the entire duration of the program.\n\n    #include <iostream>\n    \n    int globalVar; // This is a global variable\n    \n    int main() {\n        std::cout << \"Global variable: \" << globalVar << '\\n';\n    }\n    \n\n*   **Local scope:** Identifiers declared within a function or a block have a local scope. They can be accessed only within the function or the block they were declared in. Their lifetime is limited to the duration of the function/block execution.\n\n    #include <iostream>\n    \n    void localExample() {\n        int localVar; // This is a local variable\n        localVar = 5;\n        std::cout << \"Local variable: \" << localVar << '\\n';\n    }\n    \n    int main() {\n        localExample();\n        // std::cout << localVar << '\\n'; //error: ‘localVar’ was not declared in this scope\n    }\n    \n\n*   **Namespace scope:** A namespace is a named scope that groups related identifiers together. Identifiers declared within a namespace have the namespace scope. They can be accessed using the namespace name and the scope resolution operator `::`.\n\n    #include <iostream>\n    \n    namespace MyNamespace {\n        int namespaceVar = 42;\n    }\n    \n    int main() {\n        std::cout << \"Namespace variable: \" << MyNamespace::namespaceVar << '\\n';\n    }\n    \n\n*   **Class scope:** Identifiers declared within a class have a class scope. They can be accessed using the class name and the scope resolution operator `::` or, for non-static members, an object of the class and the dot `.` or arrow `->` operator.\n\n    #include <iostream>\n    \n    class MyClass {\n    public:\n        static int staticMember;\n        int nonStaticMember;\n    \n        MyClass(int value) : nonStaticMember(value) {}\n    };\n    \n    int MyClass::staticMember = 7;\n    \n    int main() {\n        MyClass obj(10);\n        std::cout << \"Static member: \" << MyClass::staticMember << '\\n';\n        std::cout << \"Non-static member: \" << obj.nonStaticMember << '\\n';\n    }\n    \n\nUnderstanding various types of scope in C++ is essential for effective code structuring and management of resources in a codebase.",
    "links": []
  },
  "iIdC7V8sojwyEqK1xMuHn": {
    "title": "Namespaces",
    "description": "In C++, a namespace is a named scope or container that is used to organize and enclose a collection of code elements, such as variables, functions, classes, and other namespaces. They are mainly used to divide and manage the code base, giving developers control over name collisions and the specialization of code.\n\nSyntax\n------\n\nHere's the syntax for declaring a namespace:\n\n    namespace identifier {\n        // code elements\n    }\n    \n\nUsing Namespaces\n----------------\n\nTo access elements within a namespace, you can use the scope resolution operator `::`. Here are some examples:\n\n### Declaring and accessing a namespace\n\n    #include <iostream>\n    \n    namespace animals {\n        std::string dog = \"Bobby\";\n        std::string cat = \"Lilly\";\n    }\n    \n    int main() {\n        std::cout << \"Dog's name: \" << animals::dog << '\\n';\n        std::cout << \"Cat's name: \" << animals::cat << '\\n';\n    \n        return 0;\n    }\n    \n\n### Nesting namespaces\n\nNamespaces can be nested within other namespaces:\n\n    #include <iostream>\n    \n    namespace outer {\n        int x = 10;\n    \n        namespace inner {\n            int y = 20;\n        }\n    }\n    \n    int main() {\n        std::cout << \"Outer x: \" << outer::x << '\\n';\n        std::cout << \"Inner y: \" << outer::inner::y << '\\n';\n    \n        return 0;\n    }\n    \n\n`using` Keyword\n---------------\n\nYou can use the `using` keyword to import namespaced elements into the current scope. However, this might lead to name conflicts if multiple namespaces have elements with the same name.\n\n### Using a single element from a namespace\n\n    #include <iostream>\n    \n    namespace animals {\n        std::string dog = \"Bobby\";\n        std::string cat = \"Lilly\";\n    }\n    \n    int main() {\n        using animals::dog;\n        \n        std::cout << \"Dog's name: \" << dog << '\\n';\n    \n        return 0;\n    }\n    \n\n### Using the entire namespace\n\n    #include <iostream>\n    \n    namespace animals {\n        std::string dog = \"Bobby\";\n        std::string cat = \"Lilly\";\n    }\n    \n    int main() {\n        using namespace animals;\n        \n        std::cout << \"Dog's name: \" << dog << '\\n';\n        std::cout << \"Cat's name: \" << cat << '\\n';\n    \n        return 0;\n    }\n    \n\nIn conclusion, namespaces are a useful mechanism in C++ to organize code, avoid naming conflicts, and manage the visibility of code elements.",
    "links": []
  },
  "CK7yf8Bo7kfbV6x2tZTrh": {
    "title": "Headers / CPP Files",
    "description": "Code splitting refers to the process of breaking down a large code base into smaller, more manageable files or modules. This helps improve the organization, maintainability, and readability of the code. In C++, code splitting is generally achieved through the use of separate compilation, header files, and source files.\n\n### Header Files (.h or .hpp)\n\nHeader files, usually with the `.h` or `.hpp` extension, are responsible for declaring classes, functions, and variables that are needed by multiple source files. They act as an interface between different parts of the code, making it easier to manage dependencies and reduce the chances of duplicated code.\n\nExample of a header file:\n\n    // example.h\n    #ifndef EXAMPLE_H\n    #define EXAMPLE_H\n    \n    class Example {\n    public:\n        void printMessage();\n    };\n    \n    #endif\n    \n\n### Source Files (.cpp)\n\nSource files, with the `.cpp` extension, are responsible for implementing the actual functionality defined in the corresponding header files. They include the header files as needed and provide the function and class method definitions.\n\nExample of a source file:\n\n    // example.cpp\n    #include \"example.h\"\n    #include <iostream>\n    \n    void Example::printMessage() {\n        std::cout << \"Hello, code splitting!\\n\";\n    }\n    \n\n### Separate Compilation\n\nC++ allows for separate compilation, which means that each source file can be compiled independently into an object file. These object files can then be linked together to form the final executable. This provides faster build times when making changes to a single source file since only that file needs to be recompiled, and the other object files can be reused.\n\nExample of separate compilation and linking:\n\n    # Compile each source file into an object file\n    g++ -c main.cpp -o main.o\n    g++ -c example.cpp -o example.o\n    \n    # Link object files together to create the executable\n    g++ main.o example.o -o my_program\n    \n\nBy following the code splitting technique, you can better organize your C++ codebase, making it more manageable and maintainable.",
    "links": []
  },
  "CMlWNQwpywNhO9B6Yj6Me": {
    "title": "Structures and Classes",
    "description": "Structures and classes are user-defined data types in C++ that allow for the grouping of variables of different data types under a single name. They make it easier to manage and organize complex data by creating objects that have particular attributes and behaviors. The main difference between a structure and a class is their default access specifier: members of a structure are public by default, while members of a class are private.\n\nStructures\n----------\n\nA structure is defined using the `struct` keyword, followed by the structure's name and a set of curly braces `{}` enclosing the members (variables and/or functions) of the structure. The members can be of different data types. To create an object of the structure's type, use the structure name followed by the object name.\n\nHere's an example of defining a structure and creating an object:\n\n    struct Employee {\n        int id;\n        std::string name;\n        float salary;\n    };\n    \n    Employee e1; // create an object of the 'Employee' structure\n    \n\nYou can access the members of a structure using the dot operator `.`:\n\n    e1.id = 1;\n    e1.name = \"John Doe\";\n    e1.salary = 40000;\n    \n\nClasses\n-------\n\nA class is defined using the `class` keyword, followed by the class's name and a set of curly braces `{}` enclosing the members (variables and/or functions) of the class. Like structures, class members can be of different data types. You can create objects of a class using the class name followed by the object name.\n\nHere's an example of a class definition and object creation:\n\n    class Student {\n        int roll_no;\n        std::string name;\n        float marks;\n    \n    public:\n        void set_data(int r, std::string n, float m) {\n            roll_no = r;\n            name = n;\n            marks = m;\n        }\n    \n        void display() {\n            std::cout << \"Roll no: \" << roll_no\n                      << \"\\nName: \" << name\n                      << \"\\nMarks: \" << marks << '\\n';\n        }\n    };\n    \n    Student s1; // create an object of the 'Student' class\n    \n\nSince the data members of a class are private by default, we cannot access them directly using the dot operator from outside the class. Instead, we use public member functions to set or get their values:\n\n    s1.set_data(1, \"Alice\", 95.0);\n    s1.display();\n    \n\nThat's a brief summary of structures and classes in C++. Remember that while they may seem similar, classes provide more control over data encapsulation and can be used to implement more advanced features like inheritance and polymorphism.",
    "links": []
  },
  "7sdEzZCIoarzznwO4XcCv": {
    "title": "Rule of Zero, Five, Three",
    "description": "**Rule of Zero, Three, and Five in C++**\n\nThe Rule of Zero, Three, and Five is a set of guidelines for managing object resources in modern C++, related to structures and classes. These rules deal with the default behavior of constructors, destructors, and other special member functions that are necessary for proper resource management.\n\n**Rule of Zero**\n\nThe Rule of Zero states that if a class or structure does not explicitly manage resources, it should not define any of the special member functions, i.e., destructor, copy constructor, copy assignment operator, move constructor, and move assignment operator. The compiler will automatically generate these functions, and the behavior will be correct for managing resources like memory and file handles.\n\n_Example:_\n\n    struct MyResource {\n        std::string name;\n        int value;\n    };\n    \n\nIn this example, MyResource is a simple structure that does not manage any resources, so it does not define any special member functions. The compiler will generate them automatically, and the behavior will be correct.\n\n**Rule of Three**\n\nThe Rule of Three states that a class or structure that manages resources should define the following three special member functions:\n\n*   Destructor\n*   Copy constructor\n*   Copy assignment operator\n\nThese functions are necessary for proper resource management, such as releasing memory or correctly handling deep copies.\n\n_Example:_\n\n    class MyResource {\n    public:\n        // Constructor and destructor\n        MyResource() : data(new int[100]) {} \n        ~MyResource() { delete[] data; } \n    \n        // Copy constructor\n        MyResource(const MyResource& other) : data(new int[100]) {\n            std::copy(other.data, other.data + 100, data);\n        }\n    \n        // Copy assignment operator\n        MyResource& operator=(const MyResource& other) {\n            if (&other == this) { return *this; }\n            std::copy(other.data, other.data + 100, data);\n            return *this;\n        }\n    \n    private:\n        int* data;\n    };\n    \n\nIn this example, MyResource is a class that manages a resource (an array of integers), so it defines the destructor, copy constructor, and copy assignment operator.\n\n**Rule of Five**\n\nThe Rule of Five extends the Rule of Three to include two additional special member functions:\n\n*   Move constructor\n*   Move assignment operator\n\nModern C++ introduces move semantics, which allows for more efficient handling of resources by transferring ownership without necessarily copying all the data.\n\n_Example:_\n\n    class MyResource {\n    public:\n        // Constructors and destructor\n        MyResource() : data(new int[100]) {}\n        ~MyResource() { delete[] data; }\n    \n        // Copy constructor\n        MyResource(const MyResource& other) : data(new int[100]) {\n            std::copy(other.data, other.data + 100, data);\n        }\n    \n        // Copy assignment operator\n        MyResource& operator=(const MyResource& other) {\n            if (&other == this) { return *this; }\n            std::copy(other.data, other.data + 100, data);\n            return *this;\n        }\n    \n        // Move constructor\n        MyResource(MyResource&& other) noexcept : data(other.data) {\n            other.data = nullptr;\n        }\n    \n        // Move assignment operator\n        MyResource& operator=(MyResource&& other) noexcept {\n            if (&other == this) { return *this; }\n            delete[] data;\n            data = other.data;\n            other.data = nullptr;\n            return *this;\n        }\n    \n    private:\n        int* data;\n    };\n    \n\nIn this example, MyResource is a class that manages a resource (an array of integers), so it defines all five special member functions for proper resource management and move semantics.",
    "links": []
  },
  "WjHpueZDK-d3oDNMVZi9w": {
    "title": "Multiple Inheritance",
    "description": "Multiple inheritance is a feature in C++ where a class can inherit characteristics (data members and member functions) from more than one parent class. The concept is similar to single inheritance (where a class inherits from a single base class), but in multiple inheritance, a class can have multiple base classes.\n\nWhen a class inherits multiple base classes, it becomes a mixture of their properties and behaviors, and can override or extend them as needed.\n\nSyntax\n------\n\nHere is the syntax to declare a class with multiple inheritance:\n\n    class DerivedClass : access-specifier BaseClass1, access-specifier BaseClass2, ...\n    {\n        // class body\n    };\n    \n\nThe `DerivedClass` will inherit members from both `BaseClass1` and `BaseClass2`. The `access-specifier` (like `public`, `protected`, or `private`) determines the accessibility of the inherited members.\n\nExample\n-------\n\nHere is an example of multiple inheritance in action:\n\n    #include <iostream>\n    \n    // Base class 1\n    class Animal\n    {\n    public:\n        void eat()\n        {\n            std::cout << \"I can eat!\\n\";\n        }\n    };\n    \n    // Base class 2\n    class Mammal\n    {\n    public:\n        void breath()\n        {\n            std::cout << \"I can breathe!\\n\";\n        }\n    };\n    \n    // Derived class inheriting from both Animal and Mammal\n    class Dog : public Animal, public Mammal\n    {\n    public:\n        void bark()\n        {\n            std::cout << \"I can bark! Woof woof!\\n\";\n        }\n    };\n    \n    int main()\n    {\n        Dog myDog;\n    \n        // Calling members from both base classes\n        myDog.eat();\n        myDog.breath();\n        \n        // Calling a member from the derived class\n        myDog.bark();\n    \n        return 0;\n    }\n    \n\nNote\n----\n\nIn some cases, multiple inheritance can lead to complications such as ambiguity and the \"diamond problem\". Ensure that you use multiple inheritance judiciously and maintain well-structured and modular classes to prevent issues.\n\nFor more information on C++ multiple inheritance and related topics, refer to C++ documentation or a comprehensive C++ programming guide.",
    "links": []
  },
  "b3-QYKNcW3LYCNOza3Olf": {
    "title": "Object Oriented Programming",
    "description": "Object-oriented programming (OOP) is a programming paradigm that uses objects, which are instances of classes, to perform operations and interact with each other. In C++, you can achieve OOP through the use of classes and objects.\n\nClasses\n-------\n\nA class is a blueprint for creating objects. It defines the structure (data members) and behavior (member functions) for a type of object. Here's an example of a simple class:\n\n    class Dog {\n    public:\n        std::string name;\n        int age;\n    \n        void bark() {\n            std::cout << name << \" barks!\\n\";\n        }\n    };\n    \n\nThis `Dog` class has two data members: `name` and `age`, and one member function `bark`. You can create an object of this class and access its members like this:\n\n    Dog myDog;\n    myDog.name = \"Fido\";\n    myDog.age = 3;\n    myDog.bark(); // Output: Fido barks!\n    \n\nEncapsulation\n-------------\n\nEncapsulation is the concept of bundling data and functions that operate on that data within a single unit, such as a class. It helps to hide the internal implementation details of a class and expose only the necessary information and functionalities. In C++, you can use access specifiers like `public`, `private`, and `protected` to control the visibility and accessibility of class members. For example:\n\n    class Dog {\n    private:\n        std::string name;\n        int age;\n    \n    public:\n        void setName(std::string n) {\n            name = n;\n        }\n    \n        void setAge(int a) {\n            age = a;\n        }\n    \n        void bark() {\n            std::cout << name << \" barks!\\n\";\n        }\n    };\n    \n\nIn this example, we've made the `name` and `age` data members `private` and added public member functions `setName` and `setAge` to modify them. This way, the internal data of the `Dog` class is protected and only accessible through the provided functions.\n\nInheritance\n-----------\n\nInheritance is the concept of deriving new classes from existing ones, which enables code reusability and organization. In C++, inheritance is achieved by using a colon `:` followed by the base class' access specifier and the base class name. For example:\n\n    class Animal {\n    public:\n        void breathe() {\n            std::cout << \"I can breathe\\n\";\n        }\n    };\n    \n    class Dog : public Animal {\n    public:\n        void bark() {\n            std::cout << \"Dog barks!\\n\";\n        }\n    };\n    \n\nIn this example, the `Dog` class inherits from the `Animal` class, so the `Dog` class can access the `breathe` function from the `Animal` class. When you create a `Dog` object, you can use both `breathe` and `bark` functions.\n\n    Dog myDog;\n    myDog.breathe(); // Output: I can breathe\n    myDog.bark(); // Output: Dog barks!\n    \n\nPolymorphism\n------------\n\nPolymorphism allows you to use a single interface to represent different types. In C++, it's mainly achieved using function overloading, virtual functions, and overriding. For example:\n\n    class Animal {\n    public:\n        virtual void makeSound() {\n            std::cout << \"The Animal makes a sound\\n\";\n        }\n    };\n    \n    class Dog : public Animal {\n    public:\n        void makeSound() override {\n            std::cout << \"Dog barks!\\n\";\n        }\n    };\n    \n    class Cat : public Animal {\n    public:\n        void makeSound() override {\n            std::cout << \"Cat meows!\\n\";\n        }\n    };\n    \n\nIn this example, we have an `Animal` base class with a virtual `makeSound` function. We then derive two classes, `Dog` and `Cat`, which override the `makeSound` function. This enables polymorphic behavior, where an `Animal` pointer or reference can be used to access the correct `makeSound` function depending on the derived class type.\n\n    Animal *animals[2] = {new Dog, new Cat};\n    animals[0]->makeSound(); // Output: Dog barks!\n    animals[1]->makeSound(); // Output: Cat meows!\n    \n\nThat's a brief overview of object-oriented programming concepts in C++.",
    "links": []
  },
  "hNBErGNiegLsUJn_vgcOR": {
    "title": "Virtual Methods",
    "description": "Virtual functions enable runtime polymorphism in C++, allowing derived classes to override base class behavior. When called via a base pointer/reference, the _actual object's type_ determines which function is executed (dynamic dispatch). Non-virtual functions use compile-time resolution based on the pointer/reference type (static dispatch), which prevents overriding.\n\n    // Base class with virtual function\n    class Animal {\n    public:\n        virtual void speak() { std::cout << \"Generic sound\"; }\n    };\n    \n    // Derived class override\n    class Dog : public Animal {\n    public:\n        void speak() override { std::cout << \"Woof!\"; } // Dynamic dispatch\n    };\n    \n\nVisit the following resources to learn more:",
    "links": [
      {
        "title": "C++ Virtual Functions Documentation",
        "url": "https://en.cppreference.com/w/cpp/language/virtual",
        "type": "article"
      },
      {
        "title": "GeeksforGeeks Virtual Functions Guide",
        "url": "https://www.geeksforgeeks.org/virtual-function-cpp/",
        "type": "article"
      },
      {
        "title": "Virtual Functions Explained (YouTube)",
        "url": "https://www.youtube.com/watch?v=oIV2KchSyGQ&ab_channel=TheCherno",
        "type": "video"
      }
    ]
  },
  "s99ImazcwCgAESxZd8ksa": {
    "title": "Virtual Tables",
    "description": "",
    "links": []
  },
  "7h1VivjCPDwriL7FirtFv": {
    "title": "Dynamic Polymorphism",
    "description": "Dynamic polymorphism is a programming concept in object-oriented languages like C++ where a derived class can override or redefine methods of its base class. This means that a single method call can have different implementations based on the type of object it is called on.\n\nDynamic polymorphism is achieved through **virtual functions**, which are member functions of a base class marked with the `virtual` keyword. When you specify a virtual function in a base class, it can be overridden in any derived class to provide a different implementation.\n\nExample\n-------\n\nHere's an example in C++ demonstrating dynamic polymorphism.\n\n    #include <iostream>\n    \n    // Base class\n    class Shape {\n    public:\n        virtual void draw() {\n            std::cout << \"Drawing a shape\\n\"; \n        }\n    };\n    \n    // Derived class 1\n    class Circle : public Shape {\n    public:\n        void draw() override {\n            std::cout << \"Drawing a circle\\n\"; \n        }\n    };\n    \n    // Derived class 2\n    class Rectangle : public Shape {\n    public:\n        void draw() override {\n            std::cout << \"Drawing a rectangle\\n\";\n        }\n    };\n    \n    int main() {\n        Shape* shape;\n        Circle circle;\n        Rectangle rectangle;\n    \n        // Storing the address of circle\n        shape = &circle;\n    \n        // Call circle draw function\n        shape->draw();\n    \n        // Storing the address of rectangle\n        shape = &rectangle;\n    \n        // Call rectangle draw function\n        shape->draw();\n    \n        return 0;\n    }\n    \n\nThis code defines a base class `Shape` with a virtual function `draw`. Two derived classes `Circle` and `Rectangle` both override the `draw` function to provide their own implementations. Then in the `main` function, a pointer of type `Shape` is used to call the respective `draw` functions of `Circle` and `Rectangle` objects. The output of this program will be:\n\n    Drawing a circle\n    Drawing a rectangle\n    \n\nAs you can see, using dynamic polymorphism, we can determine at runtime which `draw` method should be called based on the type of object being used.",
    "links": []
  },
  "B2SGBENzUMl0SAjG4j91V": {
    "title": "Exception Handling",
    "description": "Exception handling in C++ is a mechanism to handle errors, anomalies, or unexpected events that can occur during the runtime execution of a program. This allows the program to continue running or exit gracefully when encountering errors instead of crashing abruptly.\n\nC++ provides a set of keywords and constructs for implementing exception handling:\n\n*   `try`: Defines a block of code that should be monitored for exceptions.\n*   `catch`: Specifies the type of exception to be caught and the block of code that shall be executed when that exception occurs.\n*   `throw`: Throws an exception that will be caught and handled by the appropriate catch block.\n*   `noexcept`: Specifies a function that doesn't throw exceptions or terminates the program if an exception is thrown within its scope.\n\nExample\n-------\n\nHere's an example demonstrating the basic usage of exception handling:\n\n    #include <iostream>\n    \n    int divide(int a, int b) {\n        if (b == 0) {\n            throw \"Division by zero!\";\n        }\n        return a / b;\n    }\n    \n    int main() {\n        int num1, num2;\n    \n        std::cout << \"Enter two numbers for division: \";\n        std::cin >> num1 >> num2;\n    \n        try {\n            int result = divide(num1, num2);\n            std::cout << \"The result is: \" << result << '\\n';\n        } catch (const char* msg) {\n            std::cerr << \"Error: \" << msg << '\\n';\n        }\n    \n        return 0;\n    }\n    \n\nIn this example, we define a function `divide` that throws an exception if `b` is zero. In the `main` function, we use a `try` block to call `divide` and output the result. If an exception is thrown, it is caught inside the `catch` block, which outputs an error message. This way, we can handle the error gracefully rather than letting the program crash when attempting to divide by zero.\n\nStandard Exceptions\n-------------------\n\nC++ provides a standard set of exception classes under the `<stdexcept>` library which can be used as the exception type for more specific error handling. Some of these classes include:\n\n*   `std::exception`: Base class for all standard exceptions.\n*   `std::logic_error`: Represents errors which can be detected statically by the program.\n*   `std::runtime_error`: Represents errors occurring during the execution of a program.\n\nHere's an example showing how to use standard exceptions:\n\n    #include <iostream>\n    #include <stdexcept>\n    \n    int divide(int a, int b) {\n        if (b == 0) {\n            throw std::runtime_error(\"Division by zero!\");\n        }\n        return a / b;\n    }\n    \n    int main() {\n        int num1, num2;\n    \n        std::cout << \"Enter two numbers for division: \";\n        std::cin >> num1 >> num2;\n    \n        try {\n            int result = divide(num1, num2);\n            std::cout << \"The result is: \" << result << '\\n';\n        } catch (const std::exception& e) {\n            std::cerr << \"Error: \" << e.what() << '\\n';\n        }\n    \n        return 0;\n    }\n    \n\nIn this example, we modified the `divide` function to throw a `std::runtime_error` instead of a simple string. The catch block now catches exceptions derived from `std::exception` and uses the member function `what()` to display the error message.",
    "links": []
  },
  "oWygnpwHq2poXQMTTSCpl": {
    "title": "Exit Codes",
    "description": "Exit codes, also known as \"return codes\" or \"status codes\", are numeric values that a program returns to the calling environment (usually the operating system) when it finishes execution. These codes are used to indicate the success or failure of a program's execution.\n\n0 is the standard exit code for a successful execution, while non-zero exit codes typically indicate errors or other exceptional situations. The actual meanings of non-zero exit codes can vary between different applications or systems.\n\nIn C++, you can return an exit code from the `main` function by using the `return` statement, or you can use the `exit()` function, which is part of the C++ Standard Library.\n\nExample: Using return in `main`\n-------------------------------\n\n    #include <iostream>\n    \n    int main() {\n        // Some code here...\n    \n        if (/*some error condition*/) {\n            std::cout << \"An error occurred.\\n\";\n            return 1;\n        }\n    \n        // More code here...\n    \n        if (/*another error condition*/) {\n            std::cout << \"Another error occurred.\\n\";\n            return 2;\n        }\n    \n        return 0; // Successful execution\n    }\n    \n\nExample: Using the `exit()` function\n------------------------------------\n\n    #include <iostream>\n    #include <cstdlib>\n    \n    void some_function() {\n        // Some code here...\n    \n        if (/*some error condition*/) {\n            std::cout << \"An error occurred.\\n\";\n            std::exit(1);\n        }\n    \n        // More code here...\n    }\n    \n    int main() {\n        some_function();\n    \n        // Some other code here...\n    \n        return 0; // Successful execution\n    }\n    \n\nIn both examples above, the program returns exit codes depending on different error conditions encountered during execution. The codes 1 and 2 are used to distinguish between the two error conditions.",
    "links": []
  },
  "NJud5SXBAUZ6Sr78kZ7jx": {
    "title": "Exceptions",
    "description": "Exception handling is a method used to tackle runtime errors so that normal flow of the program can be maintained. In C++, this is accomplished using three keywords: `try`, `catch`, and `throw`.\n\ntry { ... }\n-----------\n\nIn the `try` block, you write the code that can possibly generate an exception. If an exception is encountered, the control is passed to the relevant `catch` block to handle the issue.\n\nExample:\n\n    try {\n      // code that might throw an exception\n    }\n    \n\ncatch (...) { ... }\n-------------------\n\nThe `catch` block follows the `try` block and is responsible for handling the exceptions thrown by the `try` block. There can be multiple `catch` blocks to handle different types of exceptions.\n\nExample:\n\n    catch (int e) {\n      // handle exception of type int\n    }\n    catch (char e) {\n      // handle exception of type char\n    }\n    catch (...) {\n      // handle any other exception\n    }\n    \n\nthrow ... ;\n-----------\n\nIn case an error occurs within the `try` block, you can use the `throw` keyword to generate an exception of the specific type. This will then be caught and handled by the corresponding `catch` block.\n\nExample:\n\n    try {\n      int num1 = 10, num2 = 0;\n      if (num2 == 0) {\n        throw \"Division by zero not allowed!\";\n      } else {\n        int result = num1 / num2;\n        std::cout << \"Result: \" << result << '\\n';\n      }\n    }\n    catch (const char* e) {\n      std::cout << \"Error: \" << e << '\\n';\n    }\n    \n\nIn summary, exception handling in C++ is a technique to handle runtime errors while maintaining the normal flow of the program. The `try`, `catch`, and `throw` keywords are used together to create the structure to deal with exceptions as they occur.",
    "links": []
  },
  "y4-P4UNC--rE1vni8HdTn": {
    "title": "Access Violations",
    "description": "An access violation is a specific type of error that occurs when a program attempts to access an illegal memory location. In C++, access violations are most commonly caused by:\n\n*   **Dereferencing a null or invalid pointer.**\n*   **Accessing an array out of bounds.**\n*   **Reading or writing to memory freed by the user or the operating system.**\n\nIt is crucial to identify access violations because they can lead to unpredictable behavior, application crashes, or corruption of data.\n\nSome examples of access violations are:\n\nDereferencing null or invalid pointer\n-------------------------------------\n\n    int *p = nullptr;\n    int x = *p;  // Access violation: trying to access null pointer's content\n    \n\nAccessing an array out of bounds\n--------------------------------\n\n    int arr[5] = {1, 2, 3, 4, 5};\n    int y = arr[5];  // Access violation: index out of bounds (valid indices are 0-4)\n    \n\nReading or writing to freed memory\n----------------------------------\n\n    int* p2 = new int[10];\n    delete[] p2;\n    p2[3] = 42;  // Access violation: writing to memory that has been freed\n    \n\n### Debugging Access Violations\n\nTools like _debuggers_, _static analyzers_, and _profilers_ can help identify access violations in your code. For example:\n\n*   **Microsoft Visual Studio**: Use the built-in debugger to identify the line of code responsible for the access violation error.\n    \n*   **Valgrind**: A popular Linux tool that detects memory leaks and access violations in your C++ programs.\n    \n*   **AddressSanitizer**: A runtime memory error detector for C++ that can detect out-of-bounds accesses, memory leaks, and use-after-free errors.",
    "links": []
  },
  "-6fwJQOfsorgHkoQGp4T3": {
    "title": "Language Concepts",
    "description": "C++ is a powerful, high-level, object-oriented programming language that offers several key language concepts. These concepts provide the foundation upon which you can build efficient, reliable, and maintainable programs. Here's a brief summary of some important language concepts in C++.\n\nVariables and Data Types\n------------------------\n\nC++ provides various fundamental data types such as `int`, `float`, `double`, `char`, and `bool` to declare and manipulate variables in a program.\n\nExample:\n\n    int age = 25;\n    float height = 1.7f;\n    double salary = 50000.0;\n    char grade = 'A';\n    bool isEmployed = true;\n    \n\nControl Structures\n------------------\n\nControl structures enable you to control the flow of execution of a program. Key control structures in C++ include:\n\n*   Conditional statement: `if`, `else`, and `else if`\n*   Loop constructs: `for`, `while`, and `do-while`\n*   Switch-case construct\n\nExample:\n\n    // If-else statement\n    if (age > 18) {\n        std::cout << \"You are eligible to vote.\";\n    } else {\n        std::cout << \"You are not eligible to vote.\";\n    }\n    \n    // For loop\n    for (int i = 0; i < 5; i++) {\n        std::cout << \"Hello World!\";\n    }\n    \n\nFunctions\n---------\n\nFunctions in C++ allow you to break down a large program into small, manageable, and reusable pieces of code.\n\nExample:\n\n    int add(int a, int b) {\n        return a + b;\n    }\n    \n    int main() {\n        int sum = add(10, 20);\n        std::cout << \"The sum is: \" << sum;\n        return 0;\n    }\n    \n\nArrays and Vectors\n------------------\n\nArrays and Vectors are commonly used data structures to store and manipulate a collection of elements of the same datatype.\n\nExample:\n\n    // Array\n    int marks[] = {90, 80, 95, 85};\n    \n    // Vector\n    std::vector<int> scores = {10, 20, 30, 40};\n    \n\nPointers\n--------\n\nPointers are variables that store memory addresses of other variables. They enable more efficient handling of memory, and are useful for working with dynamic data structures.\n\nExample:\n\n    int num = 10;\n    int* p = &num; // p stores the address of num\n    \n\nStructures and Classes\n----------------------\n\nStructures and Classes are user-defined data types that allow grouping of variables and functions under a single name.\n\nExample:\n\n    // Structure\n    struct Student {\n        std::string name;\n        int age;\n    };\n    \n    // Class\n    class Employee {\n    public:\n        std::string name;\n        int age;\n        void displayInfo() {\n            std::cout << \"Name: \" << name << \"\\nAge: \" << age;\n        }\n    };\n    \n\nInheritance and Polymorphism\n----------------------------\n\nInheritance is a mechanism that allows a class to inherit properties and methods from a base class. Polymorphism enables you to use a base class type to represent derived class objects.\n\nExample:\n\n    class Base {\n    public:\n        void display() {\n            std::cout << \"This is the base class.\";\n        }\n    };\n    \n    class Derived : public Base {\n    public:\n        void display() {\n            std::cout << \"This is the derived class.\";\n        }\n    };\n    \n\nException Handling\n------------------\n\nC++ provides a mechanism to handle exceptions(runtime errors) gracefully using `try`, `catch`, and `throw` constructs.\n\nExample:\n\n    try {\n        // Code that might throw an exception\n        int result = a / b;\n    } catch (const exception &e) {\n        std::cout << \"Caught an exception: \" << e.what();\n    }\n    \n\nThese are some of the key language concepts in C++, which will help you to understand the language better and develop efficient and maintainable applications.",
    "links": []
  },
  "CG01PTVgHtjfKvsJkJLGl": {
    "title": "auto (Automatic Type Deduction)",
    "description": "**Auto**\n\n`auto` is a keyword in C++ language introduced in C++11, which is used for automatic type deduction. It automatically deduces the type of a variable from the type of its initializer expression at compile time.\n\nThe `auto` keyword is useful when you are dealing with complex types or when the type of a variable is hard to predict. It can help in writing cleaner and less error-prone code.\n\nHere's a simple example of using `auto` for type deduction:\n\n    #include <iostream>\n    #include <vector>\n    \n    int main() {\n        // Traditional way of declaring a variable:\n        int myInt = 5;\n    \n        // Using auto for type deduction:\n        auto myAutoInt = 5; // Automatically deduces the type as 'int'\n    \n        // Example with more complex types:\n        std::vector<int> myVector = {1, 2, 3, 4, 5};\n    \n        // Without auto, iterating the vector would look like this:\n        for (std::vector<int>::iterator it = myVector.begin(); it != myVector.end(); ++it) {\n            std::cout << *it << '\\n';\n        }\n    \n        // With auto, the iterator declaration becomes simpler:\n        for (auto it = myVector.begin(); it != myVector.end(); ++it) {\n            std::cout << *it << '\\n';\n        }\n    }\n    \n\nKeep in mind that `auto` deduces the type based on the initializer expression, so if you don't provide an initial value, you will get a compile-time error:\n\n    auto myVar; // Error: Cannot deduce the type without initializer\n    \n\nIn C++14, you can also use `auto` with function return types to let the compiler automatically deduce the return type based on the returned expression:\n\n    auto add(int x, int y) {\n        return x + y; // The compiler deduces the return type as 'int'\n    }",
    "links": []
  },
  "PiMhw1oP9-NZEa6I9u4lX": {
    "title": "Type Casting",
    "description": "Type casting is the process of converting a value from one data type to another. In C++, there are four different methods of type casting:\n\n*   **C-style casting**: It is the syntax inherited from C, and it is done by simply putting the target data type in parentheses before the value to cast. Example:\n    \n        int a = 10;\n        float b = (float)a;  // C-style cast from int to float\n        \n    \n*   **`static_cast`**: This is the most commonly used method for type casting in C++. It is performed at compile time, and you should use it when you have an explicit conversion between data types. Example:\n    \n        int a = 10;\n        float b = static_cast<float>(a);  // static_cast from int to float\n        \n    \n*   **`dynamic_cast`**: This method is specifically used for safely converting pointers and references between base and derived classes in a class hierarchy. Example:\n    \n        class Base {};\n        class Derived : public Base {};\n        \n        Base* base_ptr = new Derived();\n        Derived* derived_ptr = dynamic_cast<Derived*>(base_ptr);  // dynamic_cast from Base* to Derived*\n        \n    \n*   **`reinterpret_cast`**: This cast changes the type of a pointer, reference, or an integer value. It is also called a bitwise cast because it changes how the compiler interprets the underlying bits. Use `reinterpret_cast` only when you have a deep understanding of what you're doing, as it does not guarantee that the resulting value will be meaningful. Example:\n    \n        int* a = new int(42);\n        long b = reinterpret_cast<long>(a);  // reinterpret_cast from int* to long\n        \n    \n*   **`const_cast`**: This casting method is used to remove the `const` qualifier from a variable. It is generally not recommended, but can be useful in certain situations where you have no control over the constness of a variable. Example:\n    \n        const int a = 10;\n        int* ptr = const_cast<int*>(&a);  // const_cast from const int* to int*\n        *ptr = 20;  // Not recommended, use with caution\n        \n    \n\nRemember to use the right type of casting based on the specific situation and follow good programming practices in order to ensure a safe and efficient code.\n\nLearn more from the following resources:",
    "links": [
      {
        "title": "Casting in C++",
        "url": "https://youtu.be/pWZS1MtxI-A",
        "type": "video"
      }
    ]
  },
  "_XB2Imyf23-6AOeoNLhYQ": {
    "title": "static_cast",
    "description": "`static_cast` is one of the casting operators in C++ that allows you to convert between different data types, such as integer and float, or between pointer types. This type of cast performs a compile-time check and gives an error if there is no valid conversion possible between given types. `static_cast` is generally safer than C-style casts since it does not perform an unsafe reinterpretation of data and allows for better type checking.\n\nSyntax\n------\n\nThe syntax for `static_cast` is as follows:\n\n    static_cast<new_type>(expression)\n    \n\nExamples\n--------\n\n*   Converting between basic data types:\n\n    int i = 42;\n    float f = static_cast<float>(i); // Converts integer i to float f\n    \n\n*   Casting pointers of different object types in an inheritance hierarchy:\n\n    class Base { /* ... */ };\n    class Derived : public Base { /* ... */ };\n    \n    Base *bPtr = new Derived;\n    Derived *dPtr = static_cast<Derived *>(bPtr); // Converts Base pointer bPtr to Derived pointer dPtr\n    \n\n*   Converting an integer to an enumeration:\n\n    enum Color { RED, GREEN, BLUE };\n    int value = 1;\n    Color color = static_cast<Color>(value); // Converts integer value to corresponding Color enumeration\n    \n\nKeep in mind that `static_cast` should be used with caution when casting pointers between different object types. If the original type of the pointer does not match the target type, the result of the cast can be incorrect or cause unexpected behavior.",
    "links": []
  },
  "5g22glc97siQOcTkHbwan": {
    "title": "const_cast",
    "description": "`const_cast` is a type of casting in C++ that allows you to remove or add constness to a variable. In other words, it enables you to modify a `const` or `volatile` object, or change a pointer or reference to a `const` or `volatile` type. This is useful in certain scenarios when you need to pass a `const` variable as an argument or when a function parameter requires a non-const type, but you want to make sure the variable remains constant throughout the code.\n\nKeep in mind that using `const_cast` to modify a truly `const` variable can lead to undefined behavior, so it is best to use this feature only when absolutely necessary.\n\nExample\n-------\n\nHere's a code example showing how to use `const_cast`:\n\n    #include <cassert>\n    #include <iostream>\n    \n    void modifyVariable(int* ptr) {\n        *ptr = 42;\n    }\n    \n    int main() {\n        const int original_value = 10;\n        int* non_const_value_ptr = const_cast<int*>(&original_value);\n        std::cout << \"Original value: \" << original_value << '\\n';\n    \n        modifyVariable(non_const_value_ptr);\n        std::cout << \"Modified value: \" << *non_const_value_ptr << \", original_value: \" << original_value << '\\n';\n    \n        assert(non_const_value_ptr == &original_value);\n    \n        return 0;\n    }\n    \n    \n\nIn this example, we first create a `const` variable, `original_value`. Then we use `const_cast` to remove the constness of the variable and assign it to a non-const pointer, `non_const_value_ptr`. The `modifyVariable` function takes an `int*` as an argument and modifies the value pointed to by the pointer, which would not have been possible if we passed the original `const int` directly. Finally, we print the `original_value` and the `*non_const_value_ptr`, which shows that the value has been modified using `const_cast`.\n\nPlease note that this example comes with some risks, as it touches undefined behavior. \\*/",
    "links": []
  },
  "4BdFcuQ5KNW94cu2jz-vE": {
    "title": "dynamic_cast",
    "description": "`dynamic_cast` is a type of casting operator in C++ that is used specifically for polymorphism. It safely converts pointers and references of a base class to its derived class and checks the validity of the conversion during runtime. If the conversion is not valid (i.e., the object is not of the target type), it returns a null pointer instead of producing undefined behavior. Therefore, `dynamic_cast` can prevent potential crashes and errors when using polymorphism.\n\nHere is a basic example of how `dynamic_cast` can be used:\n\n    #include <iostream>\n    \n    class BaseClass {\n       public:\n        virtual void display() {\n            std::cout << \"BaseClass\\n\";\n        }\n    };\n    \n    class DerivedClass : public BaseClass {\n       public:\n        void display() {\n            std::cout << \"DerivedClass\\n\";\n        }\n    };\n    \n    int main() {\n        BaseClass *basePtr = new DerivedClass();  // Upcasting\n        DerivedClass *derivedPtr;\n    \n        derivedPtr = dynamic_cast<DerivedClass *>(basePtr);  // Downcasting\n        if (derivedPtr) {\n            derivedPtr->display();  // Output: DerivedClass\n        } else {\n            std::cout << \"Invalid type conversion.\";\n        }\n    \n        delete basePtr;\n        return 0;\n    }\n    \n\nIn this example, a pointer to a `DerivedClass` object is assigned to a `BaseClass` pointer (`basePtr`). Then, we attempt to downcast it back to a `DerivedClass` pointer using `dynamic_cast`. If the casting is successful, we can access the `DerivedClass` functionality through the new pointer (`derivedPtr`).",
    "links": []
  },
  "ZMyFDJrpCauGrY5NZkOwg": {
    "title": "reinterpret_cast",
    "description": "`reinterpret_cast` is a type of casting in C++ that allows you to change the type of a pointer or an integer without altering the representation of the data. It is generally used when the conversion required is too low-level or not supported by other casting methods, such as `static_cast`.\n\nUsing `reinterpret_cast` should be handled with care, as it can lead to undefined behavior and severe problems if used incorrectly.\n\nHere's an example of usage:\n\n    #include <iostream>\n    \n    int main() {\n        int num = 42;\n        int *num_ptr = &num;\n    \n        // Disguise the integer pointer as a char pointer\n        char *char_ptr = reinterpret_cast<char *>(num_ptr);\n    \n        for (size_t i = 0; i < sizeof(int); ++i) {\n            // Print the individual bytes of the integer as characters\n            std::cout << \"Byte \" << i << \": \" << char_ptr[i] << '\\n';\n        }\n    \n        return 0;\n    }\n    \n\nIn this example, we're using `reinterpret_cast` to change the type of a pointer from `int *` to `char *`, effectively treating the integer as an array of characters and printing each byte.\n\nRemember that when using `reinterpret_cast`, you should be cautious about dereferencing the converted pointers. The behavior can be unpredictable, and it can lead to issues, such as accessing memory regions that are not intended to be accessed. `reinterpret_cast` should be used sparingly and only when a low-level conversion is necessary.",
    "links": []
  },
  "IDOlquv6jlfecwQoBwkGZ": {
    "title": "Undefined Behavior (UB)",
    "description": "**Undefined Behavior**\n----------------------\n\nUndefined behavior in C++ refers to a situation where a program's behavior cannot be predicted due to any violation of the language rules. It is a result of various factors like uninitialized variables, using pointers to deallocated memory, out-of-bounds memory access, etc. The C++ standard does not define the behavior in such cases, which means the compiler or the runtime system is free to handle these situations in any way it wants.\n\nSome common examples of Undefined Behavior are:\n\n*   **Uninitialized Variables**: Accessing the value of an uninitialized variable can lead to undefined behavior. The value of an uninitialized variable is arbitrary and depends on what was in the memory location before the variable was declared.\n    \n        int x;\n        int y = x + 5; // Undefined behavior since x is uninitialized\n        \n    \n*   **Out-of-bounds Memory Access**: Accessing memory outside the boundaries of an array or buffer may result in undefined behavior.\n    \n        int arr[5];\n        int val = arr[5]; // Undefined behavior since the valid indices are 0 to 4\n        \n    \n*   **Null Pointer Dereference**: Dereferencing a null pointer may lead to undefined behavior.\n    \n        int *ptr = nullptr;\n        int val = *ptr; // Undefined behavior since ptr is a null pointer\n        \n    \n*   **Division by Zero**: Performing a division operation by zero is undefined behavior in C++.\n    \n        int x = 5;\n        int y = 0;\n        int z = x / y; // Undefined behavior since division by zero is not allowed\n        \n    \n\nIt is crucial to detect and fix the root cause of undefined behavior in your programs since it can lead to unpredictable results, data corruption, and security vulnerabilities. To mitigate undefined behavior, you can utilize tools like static code analyzers, dynamic analysis tools, and compiler options that help detect potential issues.",
    "links": []
  },
  "YSWN7nS8vA9nMldSUrZRT": {
    "title": "Argument Dependent Lookup (ADL)",
    "description": "Argument Dependent Lookup (ADL) or Koenig Lookup is a mechanism in C++ that allows the compiler to search for the appropriate function to call based on the types of arguments provided. It is particularly helpful when using overloaded functions or operators in a namespace.\n\nADL allows the compiler to find functions in the same namespace as the arguments, even if the function is not declared at the point of use or within the namespace provided. This is especially useful when working with templates or generic programming.\n\nExample\n-------\n\nConsider the following example using a namespace and overloaded `operator<<()`:\n\n    namespace MyNamespace {\n        class MyClass {\n        public:\n            int value;\n        };\n    \n        std::ostream& operator<<(std::ostream& os, const MyClass& obj) {\n            os << \"MyClass: \" << obj.value;\n            return os;\n        }\n    }\n    \n    int main() {\n        MyNamespace::MyClass obj;\n        obj.value = 42;\n        using std::cout; // Required to use 'cout' without fully qualifying it.\n        cout << obj << '\\n'; // ADL is used to find the correct overloaded 'operator<<'.\n    }\n    \n\nIn this example, when you call `cout << obj;` in `main()`, ADL is used to find the correct `operator<<()` in the `MyNamespace` namespace because the argument `obj` is of type `MyNamespace::MyClass`.",
    "links": []
  },
  "Lt7ss59KZw9Jwqj234jm2": {
    "title": "Name Mangling",
    "description": "Name mangling, also known as name decoration, is a technique used by compilers to encode additional information about the scope, type, linkage, or other identifying information of an identifier (function names, variable names, etc.) within its name. The primary purpose of name mangling is to support function overloading, which allows multiple functions with the same name but different parameter lists to coexist in a single program.\n\nIn C++, the compiler generates a mangled name for each function and variable based on their scopes and types. The mangled name is usually formed by concatenating the original name, parameter types, and other information, often using a prefix or suffix.\n\nFor example, suppose you have the following function:\n\n    int add(int a, int b)\n    {\n        return a + b;\n    }\n    \n\nThe compiler might generate a mangled name such as `_Z3addii`, which encodes the function name `add` and its two `int` parameters.\n\nThe exact rules for name mangling are implementation and platform dependent. Different compilers may mangle names differently, which can lead to incompatibilities when attempting to link together object files or libraries compiled with different compilers.\n\nSome tools, such as c++filt (included in GCC and Clang), can be used to demangle a mangled name back to the original identifier, which can be useful when debugging or working with symbol tables.\n\n    $ echo \"_Z3addii\" | c++filt\n    add(int, int)\n    \n\nIn general, it is not necessary for you to understand the details of name mangling when writing code in C++, as the compiler handles it automatically. However, it can affect program behavior in some cases, such as when using external libraries or linking object files from different compilers.",
    "links": []
  },
  "zKdlfZTRHwjtmRUGW9z9-": {
    "title": "Macros",
    "description": "Macros are preprocessing directives in C++ used by the preprocessor to perform text substitution. They are defined using the `#define` directive, followed by the macro name and the value to be substituted.\n\nMacros can be used to define constants, create function-like macros, or perform conditional compilation.\n\nConstant Macros\n---------------\n\nConstant macros are used to define symbolic constants for use in code. They do not use any memory and are replaced by the preprocessor before the compilation process.\n\nExample:\n\n    #define PI 3.14159\n    \n\nThis macro defines a symbolic constant `PI`. You can use it in your code as if it were a regular variable.\n\n    double circumference = 2 * PI * radius;\n    \n\nFunction-like Macros\n--------------------\n\nFunction-like macros are similar to regular functions. They take a list of arguments and perform text substitution.\n\nExample:\n\n    #define SQUARE(x) ((x) * (x))\n    \n\nThis macro defines a function-like macro `SQUARE` that calculates the square of a number.\n\n    int square_of_five = SQUARE(5); // expands to ((5) * (5))\n    \n\nConditional Compilation\n-----------------------\n\nMacros can be used for conditional compilation using the `#ifdef`, `#ifndef`, `#if`, `#else`, `#elif`, and `#endif` directives.\n\nExample:\n\n    #define DEBUG_MODE\n    \n    #ifdef DEBUG_MODE\n      // Code to be compiled only in debug mode\n    #else\n      // Code to be compiled only if DEBUG_MODE is not defined\n    #endif\n    \n\nThis example demonstrates how you can use macros to control the parts of code that are being compiled, depending on the presence or absence of a macro definition.",
    "links": []
  },
  "DHdNBP7_ixjr6h-dIQ7g6": {
    "title": "Standard Library + STL",
    "description": "The C++ Standard Template Library (STL) is a collection of header files that provide several data structures, algorithms, and functions to simplify your C++ coding experience. The primary purpose of the STL is to save time and increase efficiency by providing a ready-to-use set of useful tools. The most commonly used features of the STL can be divided into three main categories: containers, algorithms, and iterators.\n\nContainers\n----------\n\nContainers are the data structures used for data storage and manipulation in C++. They are classified into four types: sequence containers, associative containers, unordered associative containers, and container adaptors.\n\n*   **Sequence Containers**: These are linear data structures that store elements in a sequential manner. Examples include:\n    \n    *   `std::vector`: A dynamic array that grows and shrinks at runtime.\n        \n            std::vector<int> my_vector;\n            \n        \n    *   `std::list`: A doubly linked list.\n        \n            std::list<int> my_list;\n            \n        \n    *   `std::deque`: A double-ended queue allowing insertion and deletion at both ends.\n        \n            std::deque<int> my_deque;\n            \n        \n*   **Associative Containers**: These containers store data in a sorted manner with unique keys. Examples include:\n    \n    *   `std::set`: A collection of unique elements sorted by keys.\n        \n            std::set<int> my_set;\n            \n        \n    *   `std::map`: A collection of key-value pairs sorted by keys.\n        \n            std::map<std::string, int> my_map;\n            \n        \n*   **Unordered Associative Containers**: These containers store data in an unordered manner using hash tables. Examples include:\n    \n    *   `std::unordered_set`: A collection of unique elements in no specific order.\n        \n            std::unordered_set<int> my_unordered_set;\n            \n        \n    *   `std::unordered_map`: A collection of key-value pairs in no specific order.\n        \n            std::unordered_map<std::string, int> my_unordered_map;\n            \n        \n*   **Container Adaptors**: These are containers based on other existing containers. Examples include:\n    \n    *   `std::stack`: A LIFO data structure based on deque or list.\n        \n            std::stack<int> my_stack;\n            \n        \n    *   `std::queue`: A FIFO data structure based on deque or list.\n        \n            std::queue<int> my_queue;\n            \n        \n    *   `std::priority_queue`: A sorted queue based on vector or deque.\n        \n            std::priority_queue<int> my_priority_queue;\n            \n        \n\nAlgorithms\n----------\n\nThe STL provides several generic algorithms that can be used to perform various operations on the data stored in containers. They are divided into five categories: non-modifying sequence algorithms, modifying sequence algorithms, sorting algorithms, sorted range algorithms, and numeric algorithms.\n\nSome examples include `std::find`, `std::replace`, `std::sort`, and `std::binary_search`.\n\nFor example, to sort a vector, you can use the following code:\n\n    std::vector<int> my_vec = {4, 2, 5, 1, 3};\n    std::sort(my_vec.begin(), my_vec.end());\n    \n\nIterators\n---------\n\nIterators are a fundamental concept in the STL, as they provide a unified way to access elements in containers. Iterators can be thought of as an advanced form of pointers.\n\nEach container has its own iterator type, which can be used to traverse elements and modify values. The most common iterator operations are `begin()` and `end()` for getting iterators pointing to the first and one past the last element of a container, respectively.\n\nFor example, to iterate through a vector and print its elements, you can use the following code:\n\n    std::vector<int> my_vec = {1, 2, 3, 4, 5};\n    for (auto it = my_vec.begin(); it != my_vec.end(); ++it) {\n        std::cout << *it << \" \";\n    }\n    \n\nThis is just a brief overview of the C++ Standard Template Library. There are many other features and functions available in the STL, and familiarizing yourself with them is crucial for efficient C++ programming.\n\nLearn more from the following resources:",
    "links": [
      {
        "title": "Mastering STL in C++23: New Features, Updates, and Best Practices",
        "url": "https://simplifycpp.org/books/Mastering_STL.pdf",
        "type": "article"
      },
      {
        "title": "C++ Standard Template Library (STL) Short Overview",
        "url": "https://www.youtube.com/watch?v=Id6ZEb_Lg58",
        "type": "video"
      }
    ]
  },
  "Ebu8gzbyyXEeJryeE0SpG": {
    "title": "Iterators",
    "description": "Iterators are objects in the C++ Standard Library (`STL`) that help us traverse containers like arrays, lists, and vectors. Essentially, they act as a bridge between container classes and algorithms. Iterators behave similar to pointers but provide a more generalized and abstract way of accessing elements in a container.\n\nThere are different types of iterators which you would encounter depending on their use cases:\n\n*   **Input Iterator**: Used to read elements in a container only once, in a forward direction. They cannot modify elements.\n\nExample:\n\n    std::vector<int> nums = {1, 2, 3, 4};\n    std::istream_iterator<int> input(std::cin);\n    std::copy(input, std::istream_iterator<int>(), std::back_inserter(nums));\n    \n\n*   **Output Iterator**: Used to write elements in a container only once, in a forward direction. They cannot re-write elements.\n\nExample:\n\n    std::vector<int> nums = {1, 2, 3, 4};\n    std::ostream_iterator<int> output(std::cout, \", \");\n    std::copy(nums.begin(), nums.end(), output);\n    \n\n*   **Forward Iterator**: Similar to input iterators but can be used for multiple passes over the elements in a container. They cannot move backward.\n\nExample:\n\n    std::forward_list<int> nums = {1, 2, 3, 4};\n    std::forward_list<int>::iterator itr = nums.begin();\n    while (itr != nums.end()) {\n        std::cout << *itr << \" \";\n        ++itr;\n    }\n    \n\n**Reverse Iterator**: Similar to input iterators but can be used for multiple passes over the elements in a container. They cannot move forward.\n\nExample:\n\n    std::list<int> nums = {1, 2, 3, 4};\n    std::list<int>::reverse_iterator itr = nums.rbegin();\n    while (itr != nums.rend()) {\n        std::cout << *itr << \" \";\n        ++itr;\n    }\n    \n\n*   **Bidirectional Iterator**: These iterators offer the ability to move both forward and backward in a container. List and set containers have bi-directional iterators.\n\nExample:\n\n    std::list<int> nums = {1, 2, 3, 4};\n    std::list<int>::iterator itr;\n    for (itr = nums.begin(); itr != nums.end(); ++itr) {\n        std::cout << *itr << \" \";\n    }\n    for (--itr; itr != nums.begin(); --itr) {\n        std::cout << *itr << \" \";\n    }\n    \n\n*   **Random Access Iterator**: These iterators provide the most flexible ways to access elements in a container. They can move forwards, backwards, jump directly to other elements, and access elements at a given index.\n\nExample:\n\n    std::vector<int> nums = {1, 2, 3, 4};\n    std::vector<int>::iterator itr;\n    for (itr = nums.begin(); itr != nums.end(); ++itr) {\n        std::cout << *itr << \" \";\n    }\n    for (itr -= 1; itr != nums.begin() - 1; --itr) {\n        std::cout << *itr << \" \";\n    }\n    \n\nFor most cases, you would want to start with the `auto` keyword and the appropriate container methods (like `begin()` and `end()`) to work with iterators.\n\nExample:\n\n    std::vector<int> nums = {1, 2, 3, 4};\n    for (auto itr = nums.begin(); itr != nums.end(); ++itr) {\n        std::cout << *itr << \" \";\n    }\n    \n\nWhen working with algorithms, remember that the C++ Standard Library provides various algorithms that already utilize iterators for tasks like searching, sorting, and manipulating elements.",
    "links": []
  },
  "VeVxZ230xkesQsIDig8zQ": {
    "title": "iostream",
    "description": "`iostream` is a header in the C++ Standard Library that provides functionality for basic input and output (I/O) operations. The I/O streams facilitate communication between your program and various sources, such as the console, files, or other programs.\n\n`iostream` includes the following classes:\n\n*   `istream`: for input operations from an input source.\n*   `ostream`: for output operations to an output target.\n*   `iostream`: a combination of `istream` and `ostream` for both input and output operations.\n\nThese classes inherit from base classes `ios` and `ios_base`.\n\nAdditionally, `iostream` defines several objects that are instances of these classes and represent the standard input and output streams:\n\n*   `cin`: an `istream` object to read from the standard input, typically corresponding to the keyboard.\n*   `cout`: an `ostream` object to write to the standard output, typically the console.\n*   `cerr`: an `ostream` object to write to the standard error output, typically used for displaying error messages.\n*   `clog`: an `ostream` object, similar to `cerr`, but its output can be buffered.\n\nHere are some code examples on using `iostream` for input and output operations:\n\n    #include <iostream>\n    \n    int main() {\n        int a;\n        std::cout << \"Enter a number: \";\n        std::cin >> a;\n        std::cout << \"You entered: \" << a << '\\n';\n        return 0;\n    }\n    \n\n    #include <iostream>\n    \n    int main() {\n        std::cerr << \"An error occurred.\\n\";\n        std::clog << \"Logging information.\\n\";\n        return 0;\n    }\n    \n\nRemember to include the `iostream` header when using these features:\n\n    #include <iostream>",
    "links": []
  },
  "whyj6Z4RXFsVQYRfYYn7B": {
    "title": "Algorithms",
    "description": "The Standard Template Library (STL) in C++ provides a collection of generic algorithms that are designed to work with various container classes. These algorithms are implemented as functions and can be applied to different data structures, such as arrays, vectors, lists, and others. The primary header file for algorithms is `<algorithm>`.\n\nKey Concepts\n------------\n\nSorting\n-------\n\nSorting refers to arranging a sequence of elements in a specific order. The STL provides several sorting algorithms, such as `std::sort`, `std::stable_sort`, and `std::partial_sort`.\n\n### std::sort\n\n`std::sort` is used to sort a range of elements \\[first, last) in non-descending order (by default). You can also use custom comparison functions or lambda expressions to change the sorting order.\n\nExample:\n\n    #include <algorithm>\n    #include <vector>\n    #include <iostream>\n    \n    int main() {\n        std::vector<int> nums = {10, 9, 8, 7, 6, 5};\n        std::sort(nums.begin(), nums.end());\n    \n        for (int num : nums) {\n            std::cout << num << ' ';\n        }\n        // Output: 5 6 7 8 9 10\n    }\n    \n\nSearching\n---------\n\nSearching refers to finding if a particular element is present within a given range of elements. STL provides various searching algorithms, such as `std::find`, `std::binary_search`, and `std::find_if`.\n\n### std::find\n\n`std::find` is used to find the iterator of the first occurrence of a given value within the range \\[first, last).\n\nExample:\n\n    #include <algorithm>\n    #include <vector>\n    #include <iostream>\n    \n    int main() {\n        std::vector<int> nums = {5, 6, 7, 8, 9, 10};\n        auto it = std::find(nums.begin(), nums.end(), 9);\n    \n        if (it != nums.end()) {\n            std::cout << \"Found 9 at position: \" << (it - nums.begin());\n        } else {\n            std::cout << \"9 not found\";\n        }\n        // Output: Found 9 at position: 4\n    }\n    \n\nModifying Sequences\n-------------------\n\nThe STL also provides algorithms for modifying sequences, such as `std::remove`, `std::replace`, and `std::unique`.\n\n### std::remove\n\n`std::remove` is used to remove all instances of a value from a container within the given range \\[first, last). Note that the function does not resize the container after removing elements.\n\nExample:\n\n    #include <algorithm>\n    #include <vector>\n    #include <iostream>\n    \n    int main() {\n        std::vector<int> nums = {5, 6, 7, 6, 8, 6, 9, 6, 10};\n        nums.erase(std::remove(nums.begin(), nums.end(), 6), nums.end());\n    \n        for (int num : nums) {\n            std::cout << num << ' ';\n        }\n        // Output: 5 7 8 9 10\n    }\n    \n\nSummary\n-------\n\nSTL algorithms in C++ provide a set of useful functions for key operations such as sorting, searching, and modifying sequences. The algorithms can be used with a variety of container classes, making them highly versatile and an essential part of C++ programming.",
    "links": []
  },
  "yGvE6eHKlPMBB6rde0llR": {
    "title": "Date / Time",
    "description": "In C++, you can work with dates and times using the `chrono` library, which is part of the Standard Library (STL). The `chrono` library provides various data types and functions to represent and manipulate time durations, time points, and clocks.\n\nDuration\n--------\n\nA `duration` represents a span of time, which can be expressed in various units such as seconds, minutes, hours, etc. To create a duration, use the `std::chrono::duration` template class. Common predefined duration types are:\n\n*   `std::chrono::seconds`\n*   `std::chrono::minutes`\n*   `std::chrono::hours`\n\n**Example:**\n\n    #include <iostream>\n    #include <chrono>\n    \n    int main() {\n        std::chrono::seconds sec(5);\n        std::chrono::minutes min(2);\n        std::chrono::hours hr(1);\n        return 0;\n    }\n    \n\nTime Point\n----------\n\nA `time_point` represents a specific point in time. It is usually created using a combination of duration and a clock. In C++, there are three clock types provided by the `chrono` library:\n\n*   `std::chrono::system_clock`: Represents the system-wide real time wall clock.\n*   `std::chrono::steady_clock`: Represents a monotonic clock that is guaranteed to never be adjusted.\n*   `std::chrono::high_resolution_clock`: Represents the clock with the shortest tick period.\n\n**Example:**\n\n    #include <iostream>\n    #include <chrono>\n    \n    int main() {\n        std::chrono::system_clock::time_point tp = std::chrono::system_clock::now();\n        return 0;\n    }\n    \n\nClock\n-----\n\nA clock provides access to the current time. It consists of the following elements:\n\n*   `time_point`: A specific point in time.\n*   `duration`: The time duration between two time points.\n*   `now()`: A static function that returns the current time point.\n\n**Example:**\n\n    #include <iostream>\n    #include <chrono>\n    \n    int main() {\n        // Get the current time_point using system_clock\n        std::chrono::system_clock::time_point now = std::chrono::system_clock::now();\n    \n        // Get the time_point 1 hour from now\n        std::chrono::system_clock::time_point one_hour_from_now = now + std::chrono::hours(1);\n        return 0;\n    }\n    \n\nConverting Time Points to Calendar Time\n---------------------------------------\n\nTo convert a time point to calendar representation, you can use the `std::chrono::system_clock::to_time_t` function.\n\n**Example:**\n\n    #include <iostream>\n    #include <chrono>\n    #include <ctime>\n    \n    int main() {\n        std::chrono::system_clock::time_point now = std::chrono::system_clock::now();\n        std::time_t now_c = std::chrono::system_clock::to_time_t(now);\n        std::cout << \"Current time: \" << std::ctime(&now_c) << '\\n';\n        return 0;\n    }\n    \n\nThis summarizes the basic functionality of working with date and time in C++ using the `chrono` library. You can find more advanced features, such as casting durations and time arithmetic, in the [C++ reference](https://en.cppreference.com/w/cpp/chrono).",
    "links": []
  },
  "OXQUPqxzs1-giAACwl3X1": {
    "title": "Multithreading",
    "description": "Multithreading is the concurrent execution of multiple threads within a single process or program. It improves the performance and efficiency of an application by allowing multiple tasks to be executed in parallel.\n\nIn C++, multithreading support is available through the `thread` library introduced in the C++11 standard.\n\nBasic Thread Creation\n---------------------\n\nTo create a new thread, include the `<thread>` header file and create an instance of `std::thread` that takes a function as an argument. The function will be executed in a new thread.\n\n    #include <iostream>\n    #include <thread>\n    \n    void my_function() {\n        std::cout << \"This function is executing in a separate thread\\n\";\n    }\n    \n    int main() {\n        std::thread t(my_function);\n        t.join(); // waits for the thread to complete\n        return 0;\n    }\n    \n\nThread with Arguments\n---------------------\n\nYou can pass arguments to the thread function by providing them as additional arguments to the `std::thread` constructor.\n\n    #include <iostream>\n    #include <thread>\n    \n    void print_sum(int a, int b) {\n        std::cout << \"The sum is: \" << a + b << '\\n';\n    }\n    \n    int main() {\n        std::thread t(print_sum, 3, 5);\n        t.join();\n        return 0;\n    }\n    \n\nMutex and Locks\n---------------\n\nWhen multiple threads access shared resources, there is a possibility of a data race. To avoid this, use mutex and locks to synchronize shared resource access.\n\n    #include <iostream>\n    #include <mutex>\n    #include <thread>\n    \n    std::mutex mtx;\n    \n    void print_block(int n, char c) {\n        {\n            std::unique_lock<std::mutex> locker(mtx);\n            for (int i = 0; i < n; ++i) {\n                std::cout << c;\n            }\n            std::cout << '\\n';\n        }\n    }\n    \n    int main() {\n        std::thread t1(print_block, 50, '*');\n        std::thread t2(print_block, 50, '$');\n    \n        t1.join();\n        t2.join();\n    \n        return 0;\n    }\n    \n\nThis short introduction should help you get started with basic multithreading techniques in C++. There is a lot more to learn, such as thread pools, condition variables, and atomic operations for advanced synchronization and performance tuning.",
    "links": []
  },
  "1pydf-SR0QUfVNuBEyvzc": {
    "title": "Containers",
    "description": "C++ Containers are a part of the Standard Template Library (STL) that provide data structures to store and organize data. There are several types of containers, each with its own characteristics and use cases. Here, we discuss some of the commonly used containers:\n\n1\\. Vector\n----------\n\nVectors are dynamic arrays that can resize themselves as needed. They store elements in a contiguous memory location, allowing fast random access using indices.\n\nExample\n-------\n\n    #include <iostream>\n    #include <vector>\n    \n    int main() {\n        std::vector<int> vec = {1, 2, 3, 4, 5};\n    \n        vec.push_back(6); // Add an element to the end\n    \n        std::cout << \"Vector contains:\";\n        for (int x : vec) {\n            std::cout << ' ' << x;\n        }\n        std::cout << '\\n';\n    }\n    \n\n2\\. List\n--------\n\nA list is a doubly-linked list that allows elements to be inserted or removed from any position in constant time. It does not support random access. Lists are better than vectors for scenarios where you need to insert or remove elements in the middle frequently.\n\nExample\n-------\n\n    #include <iostream>\n    #include <list>\n    \n    int main() {\n        std::list<int> lst = {1, 2, 3, 4, 5};\n    \n        lst.push_back(6); // Add an element to the end\n        \n        std::cout << \"List contains:\";\n        for (int x : lst) {\n            std::cout << ' ' << x;\n        }\n        std::cout << '\\n';\n    }\n    \n\n3\\. Map\n-------\n\nA map is an associative container that stores key-value pairs. It supports the retrieval of values based on their keys. The keys are sorted in ascending order by default.\n\nExample\n-------\n\n    #include <iostream>\n    #include <map>\n    \n    int main() {\n        std::map<std::string, int> m;\n    \n        m[\"one\"] = 1;\n        m[\"two\"] = 2;\n    \n        std::cout << \"Map contains:\\n\";\n        for (const auto &pair : m) {\n            std::cout << pair.first << \": \" << pair.second << '\\n';\n        }\n    }\n    \n\n4\\. Unordered\\_map\n------------------\n\nSimilar to a map, an unordered map stores key-value pairs, but it is implemented using a hash table. This means unordered\\_map has faster average-case performance compared to map, since it does not maintain sorted order. However, worst-case performance can be worse than map.\n\nExample\n-------\n\n    #include <iostream>\n    #include <unordered_map>\n    \n    int main() {\n        std::unordered_map<std::string, int> um;\n    \n        um[\"one\"] = 1;\n        um[\"two\"] = 2;\n    \n        std::cout << \"Unordered map contains:\\n\";\n        for (const auto &pair : um) {\n            std::cout << pair.first << \": \" << pair.second << '\\n';\n        }\n    }\n    \n\nThese are just a few examples of C++ containers. There are other container types, such as `set`, `multiset`, `deque`, `stack`, `queue`, and `priority_queue`. Each container has its own use cases and unique characteristics. Learning about these containers and when to use them can greatly improve your efficiency and effectiveness in using C++.",
    "links": []
  },
  "-6AOrbuOE7DJCmxlcgCay": {
    "title": "Templates",
    "description": "Templates in C++ are a powerful feature that allows you to write generic code, meaning that you can write a single function or class that can work with different data types. This means you do not need to write separate functions or classes for each data type you want to work with.\n\nTemplate Functions\n------------------\n\nTo create a template function, you use the `template` keyword followed by the type parameters or placeholders enclosed in angle brackets (`< >`). Then, you define your function as you normally would, using the type parameters to specify the generic types.\n\nHere's an example of a simple template function that takes two arguments and returns the larger of the two:\n\n    template <typename T>\n    T max(T a, T b) {\n        return (a > b) ? a : b;\n    }\n    \n\nTo use this function, you can either explicitly specify the type parameter:\n\n    int result = max<int>(10, 20);\n    \n\nOr, you can let the compiler deduce the type for you:\n\n    int result = max(10, 20);\n    \n\nTemplate Classes\n----------------\n\nSimilarly, you can create template classes using the `template` keyword. Here's an example of a simple template class that represents a pair of values:\n\n    template <typename T1, typename T2>\n    class Pair {\n    public:\n        T1 first;\n        T2 second;\n    \n        Pair(T1 first, T2 second) : first(first), second(second) {}\n    };\n    \n\nTo use this class, you need to specify the type parameters when creating an object:\n\n    Pair<int, std::string> pair(1, \"Hello\");\n    \n\nTemplate Specialization\n-----------------------\n\nSometimes, you may need special behavior for a specific data type. In this case, you can use template specialization. For example, you can specialize the `Pair` class for a specific type, like `char`:\n\n    template <>\n    class Pair<char, char> {\n    public:\n        char first;\n        char second;\n    \n        Pair(char first, char second) : first(first), second(second) {\n            // Special behavior for characters (e.g., convert to uppercase)\n            this->first = std::toupper(this->first);\n            this->second = std::toupper(this->second);\n        }\n    };\n    \n\nNow, when you create a `Pair` object with `char` template arguments, the specialized behavior will be used:\n\n    Pair<char, char> charPair('a', 'b');\n    \n\nIn summary, templates in C++ allow you to write generic functions and classes that can work with different data types, reducing code duplication and making your code more flexible and reusable.",
    "links": []
  },
  "w4EIf58KP-Pq-yc0HlGxc": {
    "title": "Variadic Templates",
    "description": "Variadic templates are a feature in C++11 that allows you to define a template with a variable number of arguments. This is especially useful when you need to write a function or class that can accept different numbers and types of arguments.\n\nSyntax\n------\n\nThe syntax for variadic templates is very simple. To define a variadic template, use the `...` (ellipsis) notation:\n\n    template <typename... Args>\n    \n\nThis notation represents a parameter pack, which can contain zero or more arguments. You can use this parameter pack as a variable list of template parameters in your template definition.\n\nExamples\n--------\n\n### Summing Multiple Arguments Using Variadic Templates\n\n    #include <iostream>\n    \n    // Base case for recursion\n    template <typename T>\n    T sum(T t) {\n      return t;\n    }\n    \n    // Variadic template\n    template <typename T, typename... Args>\n    T sum(T t, Args... args) {\n      return t + sum(args...);\n    }\n    \n    int main() {\n      int result = sum(1, 2, 3, 4, 5);  // expands to 1 + 2 + 3 + 4 + 5\n      std::cout << \"The sum is: \" << result << '\\n';\n    \n      return 0;\n    }\n    \n\n### Tuple Class Using Variadic Templates\n\n    template <typename... Types>\n    class Tuple;\n    \n    // Base case: empty tuple\n    template <>\n    class Tuple<> {};\n    \n    // Recursive case: Tuple with one or more elements\n    template <typename Head, typename... Tail>\n    class Tuple<Head, Tail...> : public Tuple<Tail...> {\n     public:\n      Tuple(Head head, Tail... tail) : Tuple<Tail...>(tail...), head_(head) {}\n    \n      Head head() const { return head_; }\n    \n     private:\n      Head head_;\n    };\n    \n    int main() {\n      Tuple<int, float, double> tuple(1, 2.0f, 3.0);\n      std::cout << \"First element: \" << tuple.head() << '\\n';\n      return 0;\n    }\n    \n\nPlease note that the examples shown are for educational purposes and might not be the most efficient or production-ready implementations. With C++17 and onward, there are even more concise ways to handle variadic templates, like using fold expressions.",
    "links": []
  },
  "sObOuccY0PDeGG-9GrFDF": {
    "title": "Template Specialization",
    "description": "Template specialization is a way to customize or modify the behavior of a template for a specific type or a set of types. This can be useful when you want to optimize the behavior or provide specific implementation for a certain type, without affecting the overall behavior of the template for other types.\n\nThere are two main ways you can specialize a template:\n\n*   **Full specialization:** This occurs when you provide a specific implementation for a specific type or set of types.\n    \n*   **Partial specialization:** This occurs when you provide a more general implementation for a subset of types that match a certain pattern or condition.\n    \n\nFull Template Specialization\n----------------------------\n\nFull specialization is used when you want to create a separate implementation of a template for a specific type. To do this, you need to use keyword `template<>` followed by the function template with the desired specialized type.\n\nHere is an example:\n\n    #include <iostream>\n    \n    template <typename T>\n    void printData(const T& data) {\n        std::cout << \"General template: \" << data << '\\n';\n    }\n    \n    template <>\n    void printData(const char* const & data) {\n        std::cout << \"Specialized template for const char*: \" << data << '\\n';\n    }\n    \n    int main() {\n        int a = 5;\n        const char* str = \"Hello, world!\";\n        printData(a); // General template: 5\n        printData(str); // Specialized template for const char*: Hello, world!\n    }\n    \n\nPartial Template Specialization\n-------------------------------\n\nPartial specialization is used when you want to create a separate implementation of a template for a subset of types that match a certain pattern or condition.\n\nHere is an example of how you can partially specialize a template class:\n\n    #include <iostream>\n    \n    template <typename K, typename V>\n    class MyPair {\n    public:\n        MyPair(K k, V v) : key(k), value(v) {}\n    \n        void print() const {\n            std::cout << \"General template: key = \" << key << \", value = \" << value << '\\n';\n        }\n    \n    private:\n        K key;\n        V value;\n    };\n    \n    template <typename T>\n    class MyPair<T, int> {\n    public:\n        MyPair(T k, int v) : key(k), value(v) {}\n    \n        void print() const {\n            std::cout << \"Partial specialization for int values: key = \" << key\n                      << \", value = \" << value << '\\n';\n        }\n    \n    private:\n        T key;\n        int value;\n    };\n    \n    int main() {\n        MyPair<double, std::string> p1(3.2, \"example\");\n        MyPair<char, int> p2('A', 65);\n        p1.print(); // General template: key = 3.2, value = example\n        p2.print(); // Partial specialization for int values: key = A, value = 65\n    }\n    \n\nIn this example, the `MyPair` template class is partially specialized to provide a different behavior when the second template parameter is of type `int`.",
    "links": []
  },
  "WptReUOwVth3C9-AVmMHF": {
    "title": "Type Traits",
    "description": "Type Traits are a set of template classes in C++ that help in getting the information about the type's properties, behavior, or characteristics. They can be found in the `<type_traits>` header file. By using Type Traits, you can adapt your code depending on the properties of a given type, or even enforce specific properties for your type parameters in template code.\n\nSome common type traits are:\n\n*   `std::is_pointer`: Checks if a given type is a pointer type.\n*   `std::is_arithmetic`: Checks if the given type is an arithmetic type.\n*   `std::is_function`: Checks if the given type is a function type.\n*   `std::decay`: Applies decltype rules to the input type ( strips references, cv-qualifiers, etc. ).\n\nUsage\n-----\n\nYou can use type traits like this:\n\n    #include <iostream>\n    #include <type_traits>\n    \n    int main() {\n        int a;\n        int* a_ptr = &a;\n    \n        std::cout << \"Is 'a' a pointer? \" << std::boolalpha << std::is_pointer<decltype(a)>::value << '\\n';\n        std::cout << \"Is 'a_ptr' a pointer? \" << std::boolalpha << std::is_pointer<decltype(a_ptr)>::value << '\\n';\n    \n        return 0;\n    }\n    \n\nComposing Type Traits\n---------------------\n\nSome type traits help you compose other traits or modify them, such as:\n\n*   `std::conditional`: If a given boolean value is true, use type A; otherwise, use type B.\n*   `std::enable_if`: If a given boolean value is true, use type A; otherwise, there is no nested type.\n\n    #include <iostream>\n    #include <type_traits>\n    \n    template <typename T>\n    typename std::enable_if<std::is_arithmetic<T>::value, T>::type find_max(T a, T b) {\n        return a > b ? a : b;\n    }\n    \n    int main() {\n        int max = find_max(10, 20);\n        std::cout << \"Max: \" << max << '\\n';\n    \n        return 0;\n    }\n    \n\nIn this example, the `find_max` template function is only defined when T is an arithmetic type (e.g., int, float, double). This prevents unintended usage of the `find_max` function with non-arithmetic types.\n\nOverall, type traits are a powerful tool to create more generic, extensible, and efficient C++ code, providing a way to query and adapt your code based on type characteristics.",
    "links": []
  },
  "3C5UfejDX-1Z8ZF6C53xD": {
    "title": "SFINAE",
    "description": "SFINAE is a principle in C++ template metaprogramming that allows the compiler to select the appropriate function or class when a specific template specialization fails during substitution. The term \"substitution failure\" refers to the process where the compiler tries to substitute template arguments into a function template or class template. If the substitution causes an error, the compiler won't consider that specific specialization as a candidate and will continue searching for a valid one.\n\nThe key idea behind SFINAE is that if a substitution error occurs, it is silently ignored, and the compiler continues to explore other template specializations or overloads. This allows you to write more flexible and generic code, as it enables you to have multiple specializations for different scenarios.\n\nCode Example\n------------\n\nHere's an example that demonstrates SFINAE in action:\n\n    #include <iostream>\n    #include <type_traits>\n    \n    template <typename T, typename = void>\n    struct foo_impl {\n        void operator()(T t) {\n            std::cout << \"Called when T is not arithmetic\\n\";\n        }\n    };\n    \n    template <typename T>\n    struct foo_impl<T, std::enable_if_t<std::is_arithmetic<T>::value>> {\n        void operator()(T t) {\n            std::cout << \"Called when T is arithmetic\\n\";\n        }\n    };\n    \n    template <typename T>\n    void foo(T t) {\n        foo_impl<T>()(t);\n    }\n    \n    int main() {\n        int a = 5;\n        foo(a); // output: Called when T is arithmetic\n    \n        std::string s = \"example\";\n        foo(s); // output: Called when T is not arithmetic\n    }\n    \n\nIn this example, we define two `foo_impl` functions are specialized based on the boolean value of `std::is_arithmetic<T>`. The first one is enabled when `T` is an arithmetic type, while the second one is enabled when `T` is not an arithmetic type. The `foo` function then calls the appropriate `foo_impl` specialization based on the result of the type trait.\n\nWhen calling `foo(a)` with an integer, the first specialization is selected, and when calling `foo(s)` with a string, the second specialization is selected. If there is no valid specialization, the code would fail to compile.",
    "links": []
  },
  "6hTcmJwNnQstbWWzNCfTe": {
    "title": "Full Template Specialization",
    "description": "Full template specialization allows you to provide a specific implementation, or behavior, for a template when used with a certain set of type parameters. It is useful when you want to handle special cases or optimize your code for specific types.\n\nSyntax\n------\n\nTo create a full specialization of a template, you need to define the specific type for which the specialization should happen. The syntax looks as follows:\n\n    template <> //Indicates that this is a specialization\n    className<specificType> //The specialized class for the specific type\n    \n\nExample\n-------\n\nConsider the following example to demonstrate full template specialization:\n\n    // Generic template\n    template <typename T>\n    class MyContainer {\n    public:\n        void print() {\n            std::cout << \"Generic container.\\n\";\n        }\n    };\n    \n    // Full template specialization for int\n    template <>\n    class MyContainer<int> {\n    public:\n        void print() {\n            std::cout << \"Container for integers.\\n\";\n        }\n    };\n    \n    int main() {\n        MyContainer<double> d;\n        MyContainer<int> i;\n    \n        d.print(); // Output: Generic container.\n        i.print(); // Output: Container for integers.\n    \n        return 0;\n    }\n    \n\nIn this example, we defined a generic `MyContainer` template class along with a full specialization for `int` type. When we use the container with the `int` type, the specialized implementation's `print` method is called. For other types, the generic template implementation will be used.",
    "links": []
  },
  "1NYJtbdcdOB4-vIrnq4yX": {
    "title": "Partial Template Specialization",
    "description": "Partial template specialization is a concept in C++ templates, which allows you to specialize a template for a subset of its possible type arguments. It is particularly useful when you want to provide a customized implementation for a particular group of types without having to define separate specializations for all types in that group.\n\nPartial template specialization is achieved by providing a specialization of a template with a new set of template parameters. This new template will be chosen when the compiler deduces the types that match the partial specialization.\n\nHere is a code example that demonstrates partial template specialization:\n\n    // Primary template\n    template <typename T>\n    struct MyTemplate {\n        static const char* name() {\n            return \"General case\";\n        }\n    };\n    \n    // Partial specialization for pointers\n    template <typename T>\n    struct MyTemplate<T*> {\n        static const char* name() {\n            return \"Partial specialization for pointers\";\n        }\n    };\n    \n    // Full specialization for int\n    template <>\n    struct MyTemplate<int> {\n        static const char* name() {\n            return \"Full specialization for int\";\n        }\n    };\n    \n    int main() {\n        MyTemplate<double> t1; // General case\n        MyTemplate<double*> t2; // Partial specialization for pointers\n        MyTemplate<int> t3; // Full specialization for int\n    \n        std::cout << t1.name() << '\\n';\n        std::cout << t2.name() << '\\n';\n        std::cout << t3.name() << '\\n';\n    \n        return 0;\n    }\n    \n\nIn the example above, we have defined a primary template `MyTemplate` with a single type parameter `T`. We then provide a partial template specialization for pointer types by specifying `MyTemplate<T*>`. This means that the partial specialization will be chosen when the type argument is a pointer type.\n\nLastly, we provide a full specialization for the `int` type by specifying `MyTemplate<int>`. This will be chosen when the type argument is `int`.\n\nWhen running this example, the output will be:\n\n    General case\n    Partial specialization for pointers\n    Full specialization for int\n    \n\nThis demonstrates that the partial specialization works as expected, and is chosen for pointer types, while the full specialization is chosen for the `int` type.",
    "links": []
  },
  "fb3bnfKXjSIjPAk4b95lg": {
    "title": "Idioms",
    "description": "C++ idioms are well-established patterns or techniques that are commonly used in C++ programming to achieve a specific outcome. They help make code efficient, maintainable, and less error-prone. Here are some of the common C++ idioms:\n\n1\\. Resource Acquisition is Initialization (RAII)\n-------------------------------------------------\n\nThis idiom ensures that resources are always properly acquired and released by tying their lifetime to the lifetime of an object. When the object gets created, it acquires the resources and when it gets destroyed, it releases them.\n\n    class Resource {\n    public:\n        Resource() { /* Acquire resource */ }\n        ~Resource() { /* Release resource */ }\n    };\n    \n    void function() {\n        Resource r; // Resource is acquired\n        // ...\n    } // Resource is released when r goes out of scope\n    \n\n2\\. Rule of Three\n-----------------\n\nIf a class defines any one of the following, it should define all three: copy constructor, copy assignment operator, and destructor.\n\n    class MyClass {\n    public:\n        MyClass();\n        MyClass(const MyClass& other); // Copy constructor\n        MyClass& operator=(const MyClass& other); // Copy assignment operator\n        ~MyClass(); // Destructor\n    };\n    \n\n3\\. Rule of Five\n----------------\n\nWith C++11, the rule of three was extended to five, covering move constructor and move assignment operator.\n\n    class MyClass {\n    public:\n        MyClass();\n        MyClass(const MyClass& other); // Copy constructor\n        MyClass(MyClass&& other); // Move constructor\n        MyClass& operator=(const MyClass& other); // Copy assignment operator\n        MyClass& operator=(MyClass&& other); // Move assignment operator\n        ~MyClass(); // Destructor\n    };\n    \n\n4\\. PImpl (Pointer to Implementation) Idiom\n-------------------------------------------\n\nThis idiom is used to separate the implementation details of a class from its interface, resulting in faster compile times and the ability to change implementation without affecting clients.\n\n    // header file\n    class MyClass {\n    public:\n        MyClass();\n        ~MyClass();\n        void someMethod();\n    \n    private:\n        class Impl;\n        Impl* pImpl;\n    };\n    \n    // implementation file\n    class MyClass::Impl {\n    public:\n        void someMethod() { /* Implementation */ }\n    };\n    \n    MyClass::MyClass() : pImpl(new Impl()) {}\n    MyClass::~MyClass() { delete pImpl; }\n    void MyClass::someMethod() { pImpl->someMethod(); }\n    \n\n5\\. Non-Virtual Interface (NVI)\n-------------------------------\n\nThis enforces a fixed public interface and allows subclasses to only override specific private or protected virtual methods.\n\n    class Base {\n    public:\n        void publicMethod() {\n            // Common behavior\n            privateMethod(); // Calls overridden implementation\n        }\n    \n    protected:\n        virtual void privateMethod() = 0; // Pure virtual method\n    };\n    \n    class Derived : public Base {\n    protected:\n        virtual void privateMethod() override {\n            // Derived implementation\n        }\n    };\n    \n\nThese are just a few examples of the many idioms in C++ programming. They can provide guidance when designing and implementing your code, but it's essential to understand the underlying concepts to adapt them to different situations.",
    "links": []
  },
  "xjUaIp8gGxkN-cp8emJ2M": {
    "title": "Non-Copyable / Non-Moveable",
    "description": "The non-copyable idiom is a C++ design pattern that prevents objects from being copied or assigned. It's usually applied to classes that manage resources, like file handles or network sockets, where copying the object could cause issues like resource leaks or double deletions.\n\nTo make a class non-copyable, you need to delete the copy constructor and the copy assignment operator. This can be done explicitly in the class declaration, making it clear to other programmers that copying is not allowed.\n\nHere's an example of how to apply the non-copyable idiom to a class:\n\n    class NonCopyable {\n    public:\n      NonCopyable() = default;\n      ~NonCopyable() = default;\n    \n      // Delete the copy constructor\n      NonCopyable(const NonCopyable&) = delete;\n    \n      // Delete the copy assignment operator\n      NonCopyable& operator=(const NonCopyable&) = delete;\n    };\n    \n\nTo use the idiom, simply inherit from the `NonCopyable` class:\n\n    class MyClass : private NonCopyable {\n      // MyClass is now non-copyable\n    };\n    \n\nThis ensures that any attempt to copy or assign objects of `MyClass` will result in a compilation error, thus preventing unwanted behavior.",
    "links": []
  },
  "YvmjrZSAOmjhVPo05MJqN": {
    "title": "Erase-Remove",
    "description": "The erase-remove idiom is a common C++ technique to efficiently remove elements from a container, particularly from standard sequence containers like `std::vector`, `std::list`, and `std::deque`. It leverages the standard library algorithms `std::remove` (or `std::remove_if`) and the member function `erase()`.\n\nThe idiom consists of two steps:\n\n*   `std::remove` (or `std::remove_if`) moves the elements to be removed towards the end of the container and returns an iterator pointing to the first element to remove.\n*   `container.erase()` removes the elements from the container using the iterator obtained in the previous step.\n\nHere's an example:\n\n    #include <algorithm>\n    #include <vector>\n    #include <iostream>\n    \n    int main() {\n        std::vector<int> numbers = {1, 3, 2, 4, 3, 5, 3};\n        \n        // Remove all occurrences of 3 from the vector.\n        numbers.erase(std::remove(numbers.begin(), numbers.end(), 3), numbers.end());\n    \n        for (int number : numbers) {\n            std::cout << number << \" \";\n        }\n    \n        return 0;\n    }\n    \n\nOutput:\n\n    1 2 4 5\n    \n\nIn this example, we used the `std::remove` algorithm to remove all occurrences of the number 3 from the `std::vector<int> numbers`. After the removal, the vector contains only 1, 2, 4, and 5, as the output shows.",
    "links": []
  },
  "lxAzI42jQdaofzQ5MXebG": {
    "title": "Copy and Swap",
    "description": "Copy-swap is a C++ idiom that leverages the copy constructor and swap function to create an assignment operator. It follows a simple, yet powerful paradigm: create a temporary copy of the right-hand side object, and swap its contents with the left-hand side object.\n\nHere's a brief summary:\n\n*   **Copy**: Create a local copy of the right-hand side object. This step leverages the copy constructor, providing exception safety and code reuse.\n*   **Swap**: Swap the contents of the left-hand side object with the temporary copy. This step typically involves swapping internal pointers or resources, without needing to copy the full contents again.\n*   **Destruction**: Destroy the temporary copy. This happens upon the exit of the assignment operator.\n\nHere's a code example for a simple `String` class:\n\n    class String {\n        // ... rest of the class ...\n    \n        String(const String& other);\n        \n        friend void swap(String& first, String& second) {\n            using std::swap; // for arguments-dependent lookup (ADL)\n            swap(first.size_, second.size_);\n            swap(first.buffer_, second.buffer_);\n        }\n    \n        String& operator=(String other) {\n            swap(*this, other);\n            return *this;\n        }\n    };\n    \n\nUsing the copy-swap idiom:\n\n*   The right-hand side object is copied when passed by value to the assignment operator.\n*   The left-hand side object's contents are swapped with the temporary copy.\n*   The temporary copy is destroyed, releasing any resources that were previously held by the left-hand side object.\n\nThis approach simplifies the implementation and provides strong exception safety, while reusing the copy constructor and destructor code.",
    "links": []
  },
  "O2Du5gHHxFxAI2u5uO8wu": {
    "title": "Copy on Write",
    "description": "The Copy-Write idiom, sometimes called the Copy-on-Write (CoW) or \"lazy copying\" idiom, is a technique used in programming to minimize the overhead of copying large objects. It helps in reducing the number of actual copy operations by using shared references to objects and only copying the data when it's required for modification.\n\nLet's understand this with a simple example:\n\n    #include <iostream>\n    #include <memory>\n    \n    class MyString {\n    public:\n        MyString(const std::string &str) : data(std::make_shared<std::string>(str)) {}\n    \n        // Use the same shared data for copying.\n        MyString(const MyString &other) : data(other.data) { \n            std::cout << \"Copied using the Copy-Write idiom.\\n\";\n        }\n    \n        // Make a copy only if we want to modify the data.\n        void write(const std::string &str) {\n            // Check if there's more than one reference.\n            if (data.use_count() > 1) {\n                data = std::make_shared<std::string>(*data);\n                std::cout << \"Copy is actually made for writing.\\n\";\n            }\n            *data = str;\n        }\n    \n    private:\n        std::shared_ptr<std::string> data;\n    };\n    \n    int main() {\n        MyString str1(\"Hello\");\n        MyString str2 = str1; // No copy operation, just shared references.\n    \n        str1.write(\"Hello, World!\"); // This is where the actual duplication happens.\n        return 0;\n    }\n    \n\nIn this example, we have a class `MyString` that simulates the Copy-Write idiom. When a `MyString` object is created, it constructs a `shared_ptr` pointing to a string. When a `MyString` object is copied, it does not perform any actual copy operation, but simply increases the reference count of the shared object. Finally, when the `write` function is called, it checks if there's more than one reference to the data and if so, it actually creates a new copy and updates the reference. This way, unnecessary copies can be avoided until they are actually needed for modification.",
    "links": []
  },
  "OmHDlLxCnH8RDdu5vx9fl": {
    "title": "RAII",
    "description": "RAII is a popular idiom in C++ that focuses on using the object's life cycle to manage resources. It encourages binding the resource lifetime to the scope of a corresponding object so that it's automatically acquired when an object is created and released when the object is destroyed. This helps in simplifying the code, avoiding leaks and managing resources efficiently.\n\nCode Examples\n-------------\n\nHere's an example of using RAII to manage resources, specifically a dynamically allocated array:\n\n    class ManagedArray {\n    public:\n        ManagedArray(size_t size) : size_(size), data_(new int[size]) {\n        }\n    \n        ~ManagedArray() {\n            delete[] data_;\n        }\n    \n        // Access function\n        int& operator [](size_t i) {\n            return data_[i];\n        }\n    \n    private:\n        size_t size_;\n        int* data_;\n    };\n    \n\nUsages:\n\n    {\n        ManagedArray arr(10);\n        arr[0] = 42;\n    \n        // No need to explicitly free memory, it will be automatically released when arr goes out of scope.\n    }\n    \n\nAnother common use case is managing a mutex lock:\n\n    class Lock {\n    public:\n        Lock(std::mutex& mtx) : mutex_(mtx) {\n            mutex_.lock();\n        }\n    \n        ~Lock() {\n            mutex_.unlock();\n        }\n    \n    private:\n        std::mutex& mutex_;\n    };\n    \n\nUsages:\n\n    std::mutex some_mutex;\n    \n    void protected_function() {\n        Lock lock(some_mutex);\n    \n        // Do some work that must be synchronized\n    \n        // No need to explicitly unlock the mutex, it will be automatically unlocked when lock goes out of scope.\n    }\n    \n\nIn both examples, the constructor acquires the resource (memory for the array and the lock for the mutex), and the destructor takes care of releasing them. This way, the resource management is tied to the object's lifetime, and the resource is correctly released even in case of an exception being thrown.",
    "links": []
  },
  "MEoWt8NKjPLVTeGgYf3cR": {
    "title": "Pimpl",
    "description": "Pimpl (Pointer-to-Implementation) idiom, also known as a private class data, compiler firewall, or handle classes, is a technique used in C++ to hide the implementation details of a class by using a forward declaration to a private structure or class, keeping the public interface of the class clean, and reducing compile-time dependencies.\n\nImplementation\n--------------\n\nHere is a simple example illustrating the Pimpl idiom:\n\n**my\\_class.h**\n\n    class MyClass_Impl; // forward declaration\n    \n    class MyClass\n    {\n    public:\n        MyClass();\n        ~MyClass();\n        void some_method();\n    \n    private:\n        MyClass_Impl *pimpl; // pointer to the implementation\n    };\n    \n\n**my\\_class.cpp**\n\n    #include \"my_class.h\"\n    #include <iostream>\n    \n    class MyClass_Impl // the actual implementation\n    {\n    public:\n        void some_method()\n        {\n            std::cout << \"Implementation method called!\\n\";\n        }\n    };\n    \n    MyClass::MyClass() : pimpl(new MyClass_Impl()) {} // constructor\n    \n    MyClass::~MyClass() { delete pimpl; } // destructor\n    \n    void MyClass::some_method()\n    {\n        pimpl->some_method(); // delegation to the implementation\n    }\n    \n\nNow, all the public methods of `MyClass` will delegate the calls to the corresponding methods of `MyClass_Impl`. By doing this, you can hide the details of class implementation, reduce the compile-time dependencies, and ease the maintenance of your code.",
    "links": []
  },
  "ttt-yeIi4BPWrgvW324W7": {
    "title": "CRTP",
    "description": "**Curiously Recurring Template Pattern (CRTP)**\n\nThe Curiously Recurring Template Pattern (CRTP) is a C++ idiom that involves a class template being derived from its own specialization. This pattern allows for the creation of static polymorphism, which differs from regular runtime polymorphism that relies on virtual functions and inheritance.\n\nCRTP is usually employed when you want to customize certain behavior in the base class without adding the overhead of a virtual function call. In short, CRTP can be used for achieving compile-time polymorphism without the runtime performance cost.\n\nHere's an example demonstrating CRTP:\n\n    template <typename Derived>\n    class Base {\n    public:\n        void interface() {\n            static_cast<Derived*>(this)->implementation();\n        }\n    \n        void implementation() {\n            std::cout << \"Default implementation in Base\\n\";\n        }\n    };\n    \n    class Derived1 : public Base<Derived1> {\n    public:\n        void implementation() {\n            std::cout << \"Custom implementation in Derived1\\n\";\n        }\n    };\n    \n    class Derived2 : public Base<Derived2> {\n        // No custom implementation, so Base::implementation will be used.\n    };\n    \n    int main() {\n        Derived1 d1;\n        d1.interface();  // Output: \"Custom implementation in Derived1\"\n    \n        Derived2 d2;\n        d2.interface();  // Output: \"Default implementation in Base\"\n    \n        return 0;\n    }\n    \n\nIn this example, the `Base` class is a template that takes a single type parameter. `Derived1` and `Derived2` are derived from their respective specialization of `Base`. CRTP is employed to allow custom implementations of the `implementation()` function in derived classes while providing a default behavior in the `Base` class. The `interface()` function in the `Base` class is a template for the derived class's behavior and calls the corresponding `implementation()` function based on the static type.\n\nThis pattern enables you to override certain behavior in derived classes with additional functionality, all while avoiding the overhead of virtual function calls and, in turn, achieving a higher degree of efficiency at runtime.",
    "links": []
  },
  "vvE1aUsWbF1OFcmMUHbJa": {
    "title": "Standards",
    "description": "C++ standards are a set of rules and guidelines that define the language's features, syntax, and semantics. The International Organization for Standardization (ISO) is responsible for maintaining and updating the C++ standards. The main purpose of the standards is to ensure consistency, efficiency, and maintainability across multiple platforms and compilers.\n\nHere's a brief summary of the different C++ standards released to date:\n\n*   **C++98/C++03**: The first standardized version of C++, which introduced many features like templates, exceptions, and the Standard Template Library (STL). C++03 is a minor update to C++98 with some bug fixes and performance improvements.\n    \n*   **C++11**: A major upgrade to the language, which introduced features such as:\n    \n    *   Lambda expressions:\n    \n        auto sum = [](int a, int b) -> int { return a + b; };\n        \n    \n    *   Range-based for loops:\n    \n        std::vector<int> numbers = {1, 2, 3, 4};\n        for (int num : numbers) {\n            std::cout << num << '\\n';\n        }\n        \n    \n    *   Smart pointers like `std::shared_ptr` and `std::unique_ptr`.\n*   **C++14**: A minor update to C++11, which added features such as:\n    \n    *   Generic lambda expressions:\n    \n        auto generic_sum = [](auto a, auto b) { return a + b; };\n        \n    \n    *   Binary literals:\n    \n        int binary_number = 0b1010;\n        \n    \n*   **C++17**: Another major update that introduced features such as:\n    \n    *   `if` and `switch` with initializers:\n    \n        if (auto it = my_map.find(key); it != my_map.end()) {\n            // use 'it' here\n        }\n        \n    \n    *   Structured bindings:\n    \n        std::map<std::string, int> my_map = {{\"A\", 1}, {\"B\", 2}};\n        for (const auto& [key, value] : my_map) {\n            // use 'key' and 'value' here\n        }\n        \n    \n*   **C++20**: The latest major update to the language, with features such as:\n    \n    *   Concepts:\n    \n        template<typename T>\n        concept Addable = requires(T a, T b) {\n            { a + b } -> std::same_as<T>;\n        };\n        \n    \n    *   Ranges:\n    \n        std::vector<int> numbers = {1, 2, 3, 4};\n        auto doubled = numbers | std::views::transform([](int n) { return n * 2; });\n        \n    \n    *   Coroutines and more.\n\nRemember that to use these language features, you might need to configure your compiler to use the specific C++ standard version. For example, with GCC or Clang, you can use the `-std=c++11`, `-std=c++14`, `-std=c++17`, or `-std=c++20` flags.",
    "links": []
  },
  "T6rCTv9Dxkm-tEA-l9XEv": {
    "title": "C++ 11 / 14",
    "description": "**C++11** The C++11 standard, also known as C++0x, was officially released in September 2011. It introduced several new language features and improvements, including:\n\n*   **Auto**: Allows compiler to infer the variable type based on its initializing expression.\n    \n        auto integer = 42; // integer is of int type\n        auto floating = 3.14; // floating is of double type\n        \n    \n*   **Range-Based for Loop**: Provides foreach-like semantics for iterating through a container or array.\n    \n        std::vector<int> numbers {1, 2, 3, 4};\n        for (int number : numbers) {\n            std::cout << number << '\\n';\n        }\n        \n    \n*   **Lambda Functions**: Anonymous functions that allow the creation of function objects more easily.\n    \n        auto add = [](int a, int b) -> int { return a + b; };\n        int sum = add(42, 13); // sum is equal to 55\n        \n    \n*   **nullptr**: A new keyword to represent null pointers, more type-safe than using a literal '0' or \"NULL\".\n    \n        int *ptr = nullptr;\n        \n    \n*   **Thread Support Library**: Provides a standard way to work with threads and synchronize data access across threads.\n    \n        std::thread t([]() { std::cout << \"Hello from another thread\\n\"; });\n        t.join();\n        \n    \n\n**C++14** The C++14 standard was officially released in December 2014 as a small extension over C++11, focusing more on fine-tuning language features and fixing issues. Some of the new features introduced:\n\n*   **Generic Lambdas**: Allows lambda function parameters to be declared with 'auto' type placeholders.\n    \n        auto add = [](auto a, auto b) { return a + b; };\n        auto sum_i = add(42, 13); // Still works with integers\n        auto sum_f = add(3.14, 2.72); // Now works with doubles too\n        \n    \n*   **Binary Literals**: Allow you to input integers as binary literals for better readability.\n    \n        int b = 0b110101; // Decimal value is 53\n        \n    \n*   **decltype(auto)**: Deduces the type of variable to match that of the expression it is initialized with.\n    \n        auto func = [](auto a, auto b) { return a * b; };\n        decltype(auto) result = func(5, 3.14); // decltype(auto) deduces to \"double\"\n        \n    \n*   **Variable Templates**: Allows you to define variables with template parameters.\n    \n        template <typename T>\n        constexpr T pi = T(3.1415926535897932385);\n        float r = pi<float>; // Instantiated as a float\n        double d = pi<double>; // Instantiated as a double",
    "links": []
  },
  "R2-qWGUxsTOeSHRuUzhd2": {
    "title": "C++ 17",
    "description": "C++17, also known as C++1z, is the version of the C++ programming language published in December 2017. It builds upon the previous standard, C++14, and adds various new features and enhancements to improve the language's expressiveness, performance, and usability.\n\nKey Features:\n-------------\n\n*   If-init-statement: Introduces a new syntax for writing conditions with scope inside if and switch statements.\n\n    if (auto it = map.find(key); it != map.end())\n    {\n        // Use it\n    }\n    \n\n*   Structured Binding Declarations: Simplify the process of unpacking a tuple, pair, or other aggregate types.\n\n    map<string, int> data;\n    auto [iter, success] = data.emplace(\"example\", 42);\n    \n\n*   Inline variables: Enables `inline` keyword for variables and allows single definition of global and class static variables in header files.\n\n    inline int globalVar = 0;\n    \n\n*   Folds expressions: Introduce fold expressions for variadic templates.\n\n    template <typename... Ts>\n    auto sum(Ts... ts)\n    {\n        return (ts + ...);\n    }\n    \n\n*   constexpr if statement: Allows conditional compilation during compile time.\n\n    template <typename T>\n    auto get_value(T t)\n    {\n        if constexpr (std::is_pointer_v<T>)\n        {\n            return *t;\n        }\n        else\n        {\n            return t;\n        }\n    }\n    \n\n*   Improved lambda expression: Allows lambda to capture a single object without changing its type or constness.\n\n    auto func = [x = std::move(obj)] { /* use x */ };\n    \n\n*   Standard file system library: `std::filesystem` as a standardized way to manipulate paths, directories, and files.\n    \n*   New Standard Library additions: `<string_view>` (non-owning string reference), `<any>` (type-erased container), `<optional>` (optional value wrapper), `<variant>` (type-safe discriminated union / sum type), and `<memory_resource>` (library for polymorphic allocators).\n    \n*   Parallel Algorithms: Adds support for parallel execution of Standard Library algorithms.\n    \n\nThis is a brief summary of the key features of C++17; it includes more features and library updates. For a complete list, you can refer to the [full list of C++17 features and changes](https://en.cppreference.com/w/cpp/17).",
    "links": []
  },
  "o3no4a5_iMFzEAGs56-BJ": {
    "title": "C++ 20",
    "description": "C++20 is the latest standard of the C++ programming language, which brings significant improvements and new features to the language. This version is aimed at facilitating better software development practices and enabling developers to write more efficient, readable, and maintainable code.\n\nHere are some of the key features introduced in C++20:\n\nConcepts\n--------\n\nConcepts are a way to enforce specific requirements on template parameters, allowing you to write more expressive and understandable code. They improve the error messages when using templates and ensure that the template parameters fulfill specific criteria.\n\n    template <typename T>\n    concept Addable = requires (T a, T b) {\n        { a + b } -> std::same_as<T>;\n    };\n    \n    template <Addable T>\n    T add(T a, T b) {\n        return a + b;\n    }\n    \n\nRanges\n------\n\nRanges provide a new way to work with sequences of values, enhancing the power and expressiveness of the Standard Library algorithms. The range-based algorithms make it easier and more convenient to work with sequences.\n\n    #include <algorithm>\n    #include <iostream>\n    #include <ranges>\n    #include <vector>\n    \n    int main() {\n        std::vector<int> numbers = { 1, 2, 3, 4, 5 };\n    \n        auto even_numbers = numbers | std::views::filter([](int n) { return n % 2 == 0; });\n    \n        for (int n : even_numbers) {\n            std::cout << n << ' ';\n        }\n    }\n    \n\nCoroutines\n----------\n\nCoroutines are a new way to write asynchronous and concurrent code with improved readability. They allow functions to be suspended and resumed, enabling you to write more efficient, non-blocking code.\n\n    #include <coroutine>\n    #include <iostream>\n    #include <future>\n    \n    std::future<int> async_value(int value) {\n        co_await std::chrono::seconds(1);\n        co_return value * 2;\n    }\n    \n    int main() {\n        auto result = async_value(42);\n        std::cout << \"Result: \" << result.get() << '\\n';\n    }\n    \n\nThe `constexpr` and `consteval` Keywords\n----------------------------------------\n\nBoth `constexpr` and `consteval` are related to compile-time evaluation. Functions marked with `constexpr` can be executed at compile-time or runtime, while functions marked with `consteval` can only be executed at compile-time.\n\n    constexpr int add(int a, int b) {\n        return a + b;\n    }\n    \n    consteval int square(int x) {\n        return x * x;\n    }\n    \n    int main() {\n        constexpr int result1 = add(3, 4);   // evaluated at compile-time\n        int result2 = add(5, 6);             // evaluated at runtime\n        constexpr int result3 = square(7);   // evaluated at compile-time\n    }\n    \n\nThese are just some of the highlights of the C++20 standard. It also includes many other features and improvements, like structured bindings, improved lambdas, and new standard library components. Overall, C++20 makes it easier for developers to write clean, efficient, and expressive code.",
    "links": []
  },
  "sxbbKtg7kMNbkx7fXhjR9": {
    "title": "Newest",
    "description": "C++20 is the newest standard of the C++ programming language, which was officially published in December 2020. It introduces many new features, enhancements, and improvements over the previous standards. Here is a brief summary of some key features in C++20.\n\n*   **Concepts**: Concepts provide a way to specify constraints on template parameters, ensuring that they meet a specific set of requirements. This allows for better compile-time error messages and code readability.\n    \n    Example:\n    \n        template<typename T>\n        concept Printable = requires(T x) {\n            {std::cout << x};\n        };\n        \n        template<Printable T>\n        void print(const T& x) {\n            std::cout << x << '\\n';\n        }\n        \n    \n*   **Ranges**: Ranges build on the iterator concept and provide a more usable and composable framework for dealing with sequences of values. They simplify the way algorithms can be applied to collections of data.\n    \n    Example:\n    \n        #include <iostream>\n        #include <vector>\n        #include <ranges>\n        \n        int main() {\n            std::vector<int> numbers{1, 2, 3, 4, 5};\n            auto even_view = numbers | std::views::filter([](int n) { return n % 2 == 0; });\n        \n            for (int n : even_view) {\n                std::cout << n << ' ';\n            }\n        }\n        \n    \n*   **Coroutines**: Coroutines offer a way to split complex, long-running functions into smaller, more manageable chunks, allowing them to be suspended and resumed at specific points.\n    \n    Example:\n    \n        #include <iostream>\n        #include <coroutine>\n        \n        std::generator<int> generator() {\n            for (int i = 0; i < 5; ++i)\n                co_yield i;\n        }\n        \n        int main() {\n            for (int value : generator())\n                std::cout << value << ' ';\n        }\n        \n    \n*   **Lambdas with template parameters**: C++20 enables using `auto` as a lambda parameter, allowing for generic lambdas with templated parameters.\n    \n    Example:\n    \n        auto sum = [](auto a, auto b) {\n            return a + b;\n        };\n        \n        int res1 = sum(1, 2);           // int\n        double res2 = sum(1.0, 2.0);    // double\n        \n    \n*   **Constexpr enhancements**: `constexpr` support is extended with additional features, such as `constexpr` dynamic allocations, `constexpr` try-catch blocks, and `constexpr` lambdas.\n    \n    Example:\n    \n        struct Point {\n            constexpr Point(int x, int y): x_{x}, y_{y} {}\n            int x_, y_;\n        };\n        \n        constexpr auto create_points() {\n            Point points[3]{};\n        \n            for (int i = 0; i < 3; ++i) {\n                points[i] = Point{i, i * i};\n            }\n        \n            return points;\n        }\n        \n        constexpr auto points = create_points();\n        \n    \n\nThere are many other features in C++20, such as new standard library improvements, `std::format`, improvements to compile-time programming, and more. These are just a few highlights that showcase the versatility and power of the newest standard of C++.",
    "links": []
  },
  "PPg0V5EzGBeJsysg1215V": {
    "title": "C++ 0x",
    "description": "`cpp0x` refers to the working name for [C++11](https://en.cppreference.com/w/cpp/11), which was previously known as C++0x before its final release. C++11 is a major revision of the C++ language standard, published in 2011, and brought several new features and improvements to the language.\n\nSome of the notable features in C++11 include:\n\n*   **Auto** keyword for automatic type inference.\n    \n        auto i = 42; // i is an int\n        auto s = \"hello\"; // s is a const char*\n        \n    \n*   **Range-based for loop** for easier iteration over containers.\n    \n        std::vector<int> vec = {1, 2, 3};\n        for (int i : vec) {\n            std::cout << i << '\\n';\n        }\n        \n    \n*   **Lambda functions** for creating anonymous functions.\n    \n        auto add = [](int a, int b) { return a + b; };\n        int result = add(3, 4); // result is 7\n        \n    \n*   **nullptr** for representing null pointer values, instead of using `NULL`.\n    \n        int* p = nullptr;\n        \n    \n*   **Rvalue references and move semantics** to optimize the handling of temporary objects.\n    \n        std::string str1 = \"hello\";\n        std::string str2 = std::move(str1); // move the content of str1 to str2\n        \n    \n*   **Variadic templates** for creating templates that take a variable number of arguments.\n    \n        template <typename... Args>\n        void printArgs(Args... args) {\n            // function body\n        }\n        \n    \n*   **Static assertions** for compile-time assertions.\n    \n        static_assert(sizeof(int) == 4, \"This code requires int to be 4 bytes.\");\n        \n    \n*   **Thread support** for multithreading programming.\n    \n        #include <thread>\n        \n        void my_function() {\n            // thread function body\n        }\n        \n        int main() {\n            std::thread t(my_function);\n            t.join();\n            return 0;\n        }\n        \n    \n\nThese are just a few examples of the many new features introduced in C++11. For a comprehensive list, you can refer to the [C++11 documentation](https://en.cppreference.com/w/cpp/11).",
    "links": []
  },
  "qmHs6_BzND_xpMmls5YUH": {
    "title": "Debuggers",
    "description": "Debuggers are essential tools for any C++ programmer, as they help in detecting, diagnosing, and fixing bugs in the code. They serve as an invaluable resource in identifying and understanding potential errors in the program.\n\nTypes of Debuggers\n------------------\n\nThere are several debuggers available for use with C++:\n\n*   **GDB (GNU Debugger):** This is the most widely used C++ debugger in the Linux environment. It can debug many languages, including C and C++.\n    \n    Example usage:\n    \n        g++ -g main.cpp -o main    # compile the code with debug info\n        gdb ./main                 # start gdb session\n        b main                     # set a breakpoint at the start of the main function\n        run                        # run the program\n        next                       # step to the next line\n        \n    \n*   **LLDB:** This is the debugger developed by LLVM. It supports multiple languages and is popular among macOS and iOS developers.\n    \n    Example usage:\n    \n        clang++ -g main.cpp -o main # compile the code with debug info\n        lldb ./main                 # start lldb session\n        breakpoint set --name main  # set a breakpoint at the start of the main function\n        run                         # run the program\n        next                        # step to the next line\n        \n    \n*   **Microsoft Visual Studio Debugger:** This debugger is built into Visual Studio and is typically used in a graphical interface on Windows systems.\n    \n    Example usage:\n    \n        Open your Visual Studio project and go to Debug > Start Debugging. Then use the step over (F10), step into (F11), or continue (F5) commands to navigate through the code.\n        \n    \n*   **Intel Debugger (IDB):** This debugger is part of Intel's parallel development suite and is popular for high-performance applications.\n    \n*   **TotalView Debugger:** Developed by Rogue Wave Software, TotalView Debugger is a commercial debugger designed for parallel, high-performance, and enterprise applications.\n    \n\nEach debugger has its advantages and unique features, so it's essential to choose the one that best suits your needs and works well with your development environment.",
    "links": []
  },
  "VtPb8-AJKzhTB0QbMtoU4": {
    "title": "Understanding Debugger Messages",
    "description": "Debugger messages are notifications or alerts provided by a debugger to help you identify problems or errors in your C++ code. These messages can be warnings or error messages and can provide helpful information about the state of your program and specific issues encountered during the debugging process.\n\nTypes of Debugger Messages\n--------------------------\n\n*   **Error Messages:** Notify you about issues in the code that prevent the program from running or compiling correctly. These messages typically include information about the file and the line number where the error is detected, followed by a description of the issue.\n    \n    Example:\n    \n        test.cpp: In function 'int main()':\n        test.cpp:6:5: error: 'cout' was not declared in this scope\n             cout << \"Hello World!\";\n             ^~~~\n        \n    \n*   **Warning Messages:** Inform you about potential issues or risky programming practices that may not necessarily cause errors but could lead to problems later on. Like error messages, warning messages usually include information about the file and line number where the issue is found, along with a description of the problem.\n    \n    Example:\n    \n        test.cpp: In function 'int main()':\n        test.cpp:6:17: warning: comparison between signed and unsigned integer expressions [-Wsign-compare]\n             if (a < size)\n                      ^\n        \n    \n*   **Informational Messages:** Provide general information about the execution of the program, such as breakpoints, watchpoints, and variable values. These messages can also reveal the current state of the program, including the call stack and the list of active threads.\n    \n    Example (_assuming you are using GDB as debugger_):\n    \n        (gdb) break main\n        Breakpoint 1 at 0x40055f: file test.cpp, line 5.\n        (gdb) run\n        Starting program: /path/to/test\n        Breakpoint 1, main () at test.cpp:5\n        5       int a = 5;\n        \n    \n\nCode Examples\n-------------\n\nTo make use of debugger messages, you need to employ a debugger, such as GDB or Visual Studio Debugger, and include specific flags during the compilation process.\n\nExample using GDB:\n\n    // test.cpp\n    \n    #include <iostream>\n    \n    int main() {\n        int num1 = 10;\n        int num2 = 0;\n        int result = num1 / num2;\n    \n        std::cout << \"Result: \" << result << '\\n';\n    \n        return 0;\n    }\n    \n\n    $ g++ -g -o test test.cpp  // Compile with -g flag to include debugging information\n    $ gdb ./test               // Run the GDB debugger\n    (gdb) run                  // Execute the program inside GDB\n    \n\nAt this point, the debugger will show an error message triggered by the division by zero:\n\n    Program received signal SIGFPE, Arithmetic exception.\n    0x00005555555546fb in main () at test.cpp:7\n    7       int result = num1 / num2;\n    \n\nNow you can make appropriate changes to fix the issue in your C++ code.",
    "links": []
  },
  "sR_FxGZHoMCV9Iv7z2_SX": {
    "title": "Debugging Symbols",
    "description": "Debugger symbols are additional information embedded within the compiled program's binary code, that help debuggers in understanding the structure, source code, and variable representations at a particular point in the execution process.\n\nThere are generally two types of debugging symbols:\n\n*   **Internal Debugging Symbols**: These symbols reside within the compiled binary code itself. When using internal debugging symbols, it is essential to note that the size of the binary increases, which may not be desirable for production environments.\n    \n*   **External Debugging Symbols**: The debugging symbols are kept in separate files apart from the binary code, usually with file extensions such as `.pdb` (Program Database) in Windows or `.dSYM` (DWARF Symbol Information) in macOS.\n    \n\nGenerating Debugger Symbols\n---------------------------\n\nTo generate debugger symbols in C++, you need to specify specific options during the compilation process. We will use `g++` compiler as an example.\n\n**Internal Debugging Symbols (g++)**\n\nTo create a debug build with internal debugging symbols, use the `-g` flag:\n\n    g++ -g -o my_program my_program.cpp\n    \n\nThis command compiles `my_program.cpp` into an executable named `my_program` with internal debugging symbols.\n\n**External Debugging Symbols (g++)**\n\nIn case you want to generate a separate file containing debugging symbols, you can use the `-gsplit-dwarf` flag:\n\n    g++ -g -gsplit-dwarf -o my_program my_program.cpp\n    \n\nThis command compiles `my_program.cpp` into an executable named `my_program` and generates a separate file named `my_program.dwo` containing the debugging symbols.\n\nWhen sharing your compiled binary to end-users, you can remove the debugging symbols using the `strip` command:\n\n    strip --strip-debug my_program\n    \n\nThis command removes internal debug symbols, resulting in a smaller binary size while keeping the `.dwo` file for debugging purposes when needed.\n\nRemember that the availability and syntax of these options may vary between different compilers and platforms. Be sure to consult your compiler's documentation to ensure proper usage of the debugging options.",
    "links": []
  },
  "y8VCbGDUco9bzGRfIBD8R": {
    "title": "WinDBg",
    "description": "WinDbg is a powerful debugger for Windows applications, which is included in the Microsoft Windows SDK. It provides an extensive set of features to help you analyze and debug complex programs, kernel mode, and user-mode code. With a user-friendly graphical interface, WinDbg can help in analyzing crash dumps, setting breakpoints, and stepping through code execution.\n\nGetting Started\n---------------\n\nTo begin using WinDbg, you first need to install it. You can download the [Windows SDK](https://developer.microsoft.com/en-us/windows/downloads/windows-10-sdk/) and install it to get the WinDbg.\n\nLoading Symbols\n---------------\n\nWinDbg relies on symbol files (\\*.pdb) to provide more useful information about a program's internal structures, functions, and variables. To load symbols properly, you may need to configure the symbol path:\n\n    !sym noisy\n    .sympath SRV*C:\\symbols*http://msdl.microsoft.com/download/symbols\n    .reload /f\n    \n\nOpening Executables and Crash Dumps\n-----------------------------------\n\nTo debug an executable using WinDbg, go to `File > Open Executable...`, then locate and open the target program. To analyze a crash dump, use `File > Open Crash Dump...` instead.\n\nBasic Commands\n--------------\n\nSome common commands you might use in WinDbg:\n\n*   `g`: Execute the program until the next breakpoint or exception\n*   `bp <address>`: Set a breakpoint at a given address\n*   `bl`: List all breakpoints\n*   `bd <breakpoint_id>`: Disable a breakpoint\n*   `be <breakpoint_id>`: Enable a breakpoint\n*   `bc <breakpoint_id>`: Clear a breakpoint\n*   `t`: Single-step through instructions (trace)\n*   `p`: Step over instructions (proceed)\n*   `k`: Display call stack\n*   `dd`: Display memory contents in 4-byte units (double words)\n*   `da`: Display memory contents as ASCII strings\n*   `!analyze -v`: Analyze the program state and provide detailed information\n\nExample Usage\n-------------\n\nDebugging a simple program:\n\n*   Open the executable in WinDbg\n*   Set a breakpoint using `bp <address>`\n*   Run the program using `g`\n*   Once the breakpoint is hit, use `t` or `p` to step through the code\n*   Try `k` to view the call stack, or `dd`, `da` to inspect memory\n*   Remove the breakpoint and continue debugging with other commands as needed\n\nRemember that WinDbg has a wealth of commands and functionality, so it's essential to get comfortable with the [documentation](https://docs.microsoft.com/en-us/windows-hardware/drivers/debugger/debugger-download-tools) and explore the wealth of available resources specific to your debugging tasks.",
    "links": []
  },
  "BmWsoL9c_Aag5nVlMsKm2": {
    "title": "GDB",
    "description": "GDB, or the GNU Project Debugger, is a powerful command-line debugger used primarily for C, C++, and other languages. It can help you find runtime errors, examine the program's execution state, and manipulate the flow to detect and fix bugs easily.\n\nGetting started with GDB\n------------------------\n\nTo start using GDB, you first need to compile your code with the `-g` flag, which includes debugging information in the executable:\n\n    g++ -g myfile.cpp -o myfile\n    \n\nNow, you can load your compiled program into GDB:\n\n    gdb myfile\n    \n\nBasic GDB Commands\n------------------\n\nHere are some common GDB commands you'll find useful when debugging:\n\n*   `run`: Start your program.\n*   `break [function/line number]`: Set a breakpoint at the specified function or line.\n*   `continue`: Continue the program execution after stopping on a breakpoint.\n*   `next`: Execute the next line of code, stepping over function calls.\n*   `step`: Execute the next line of code, entering function calls.\n*   `print [expression]`: Evaluate an expression in the current context and display its value.\n*   `backtrace`: Show the current call stack.\n*   `frame [frame-number]`: Switch to a different stack frame.\n*   `quit`: Exit GDB.\n\nExample Usage\n-------------\n\nSuppose you have a simple `cpp` file called `example.cpp`:\n\n    #include <iostream>\n    \n    void my_function(int i) {\n      std::cout << \"In my_function with i = \" << i << '\\n';\n    }\n    \n    int main() {\n      for (int i = 0; i < 5; ++i) {\n        my_function(i);\n      }\n      return 0;\n    }\n    \n\nFirst, compile the code with debugging symbols:\n\n    g++ -g example.cpp -o example\n    \n\nStart GDB and load the `example` program:\n\n    gdb example\n    \n\nSet a breakpoint in the `my_function` function and run the program:\n\n    (gdb) break my_function\n    (gdb) run\n    \n\nOnce stopped at the breakpoint, use `next`, `print`, and `continue` to examine the program's state:\n\n    (gdb) next\n    (gdb) print i\n    (gdb) continue\n    \n\nFinally, exit GDB with the `quit` command.\n\nThis was just a brief summary of GDB; you can find more details in the [official GDB manual](https://sourceware.org/gdb/current/onlinedocs/gdb/).",
    "links": []
  },
  "FTMHsUiE8isD_OVZr62Xc": {
    "title": "Compilers",
    "description": "A compiler is a computer program that translates source code written in one programming language into a different language, usually machine code or assembly code, that can be executed directly by a computer's processor. In the context of C++, compilers take your written C++ source code and convert it into an executable program.\n\nPopular C++ Compilers\n---------------------\n\nThere are several popular C++ compilers available, here's a short list of some common ones:\n\n*   **GNU Compiler Collection (GCC)**: Developed by the GNU Project, GCC is an open-source compiler that supports multiple programming languages, including C++.\n    \n*   **Clang**: As part of the LLVM project, Clang is another open-source compiler that supports C++ and is known for its fast compilation times and extensive diagnostics.\n    \n*   **Microsoft Visual C++ (MSVC)**: MSVC is a commercial compiler provided by Microsoft as part of Visual Studio, and it's widely used on Windows platforms.\n    \n*   **Intel C++ Compiler (ICC)**: ICC is a commercial compiler provided by Intel and is known for its ability to optimize code for the latest Intel processors.\n    \n\nExample of a Simple C++ Compilation\n-----------------------------------\n\nLet's say you have a simple C++ program saved in a file called `hello.cpp`:\n\n    #include <iostream>\n    \n    int main() {\n      std::cout << \"Hello, World!\\n\";\n      return 0;\n    }\n    \n\nYou can compile this program using the GCC compiler by executing the following command in a command-line/terminal:\n\n    g++ hello.cpp -o hello\n    \n\nThis will generate an executable file called `hello` (or `hello.exe` on Windows) which you can run to see the output \"Hello, World!\".\n\nNote\n----\n\nWhen learning about compilers, it's essential to know that they work closely with the linker and the standard library. The linker takes care of combining compiled object files and libraries into a single executable, while the standard library provides implementations for common functionalities used in your code.",
    "links": []
  },
  "DVckzBUMgk_lWThVkLyAT": {
    "title": "Compiler Stages",
    "description": "The process of compilation in C++ can be divided into four primary stages: Preprocessing, Compilation, Assembly, and Linking. Each stage performs a specific task, ultimately converting the source code into an executable program.\n\nPreprocessing\n-------------\n\nThe first stage is the preprocessing of the source code. Preprocessors modify the source code before the actual compilation process. They handle directives that start with a `#` (hash) symbol, like `#include`, `#define`, and `#if`. In this stage, included header files are expanded, macros are replaced, and conditional compilation statements are processed.\n\n**Code Example:**\n\n    #include <iostream>\n    #define PI 3.14\n    \n    int main() {\n        std::cout << \"The value of PI is: \" << PI << '\\n';\n        return 0;\n    }\n    \n\nCompilation\n-----------\n\nThe second stage is the actual compilation of the preprocessed source code. The compiler translates the modified source code into an intermediate representation, usually specific to the target processor architecture. This step also involves performing syntax checking, semantic analysis, and producing error messages for any issues encountered in the source code.\n\n**Code Example:**\n\n    int main() {\n        int a = 10;\n        int b = 20;\n        int sum = a + b;\n        return 0;\n    }\n    \n\nAssembly\n--------\n\nThe third stage is converting the compiler's intermediate representation into assembly language. This stage generates assembly code using mnemonics and syntax that is specific to the target processor architecture. Assemblers then convert this assembly code into object code (machine code).\n\n**Code Example (x86 Assembly):**\n\n    mov eax, 10\n    mov ebx, 20\n    add eax, ebx\n    \n\nLinking\n-------\n\nThe final stage is the linking of the object code with the necessary libraries and other object files. In this stage, the linker merges multiple object files and libraries, resolves external references from other modules or libraries, allocates memory addresses for functions and variables, and generates an executable file that can be run on the target platform.\n\n**Code Example (linking objects and libraries):**\n\n    $ g++ main.o -o main -lm\n    \n\nIn summary, the compilation process in C++ involves four primary stages: preprocessing, compilation, assembly, and linking. Each stage plays a crucial role in transforming the source code into an executable program.",
    "links": []
  },
  "hSG6Aux39X0cXi6ADy2al": {
    "title": "Compilers and Features",
    "description": "Different C++ compilers have different features. Some of the most common features of C++ compilers are:\n\n*   **Optimization:** Compilers can optimize the code to improve the performance of the program. For example, they can remove redundant code, inline functions, and perform loop unrolling.\n*   **Debugging:** Compilers can generate debugging information that can be used to debug the program.\n*   **Warnings:** Compilers can generate warnings for suspicious code that may cause errors.\n\nSome of the most popular C++ compilers are:\n\n*   **GNU Compiler Collection (GCC):** GCC is a free and open-source compiler that supports many programming languages, including C++.\n*   **Clang:** Clang is a C++ compiler that is part of the LLVM project. It is designed to be compatible with GCC.\n*   **Microsoft Visual C++:** Microsoft Visual C++ is a C++ compiler that is part of the Microsoft Visual Studio IDE.\n*   **Intel C++ Compiler:** Intel C++ Compiler is a C++ compiler that is part of the Intel Parallel Studio XE suite.\n\nYou should go through the documentation of your compiler to learn more about its features.",
    "links": []
  },
  "jVXFCo6puMxJ_ifn_uwim": {
    "title": "Build Systems",
    "description": "A build system is a collection of tools and utilities that automate the process of compiling, linking, and executing source code files in a project. The primary goal of build systems is to manage the complexity of the compilation process and produce a build (executable or binary files) in the end. In C++ (cpp), some common build systems are:\n\n*   **GNU Make**: It is a popular build system that uses `Makefile` to define the build process. It checks the dependencies and timestamps of source files to determine which files need to be compiled and linked.\n    \n    Code example:\n    \n        # Makefile\n        CXX = g++\n        CPPFLAGS = -Wall -std=c++11\n        TARGET = HelloWorld\n        \n        all: $(TARGET)\n        \n        $(TARGET): main.cpp\n            $(CXX) $(CPPFLAGS)main.cpp -o $(TARGET)\n        \n        clean:\n            rm $(TARGET)\n        \n    \n*   **CMake**: It is a cross-platform build system that focuses on defining project dependencies and managing build environments. CMake generates build files (like Makefiles) for different platforms and allows developers to write source code once and then compile it for different target platforms.\n    \n    Code example:\n    \n        # CMakeLists.txt\n        cmake_minimum_required(VERSION 3.10)\n        project(HelloWorld)\n        \n        set(CMAKE_CXX_STANDARD 11)\n        \n        add_executable(HelloWorld main.cpp)\n        \n    \n*   **Autotools**: Also known as GNU Build System, consists of the GNU Autoconf, Automake, and Libtool tools that enable developers to create portable software across different Unix-based systems. For a C++ project, you will need to create `configure.ac`, `Makefile.am` files with specific rules, and then run the following commands in the terminal to build the project:\n    \n        autoreconf --install\n        ./configure\n        make\n        make install\n        \n    \n*   **SCons**: This build system uses Python for build scripts, making it more expressive than GNU Make. It can also build for multiple platforms and configurations simultaneously.\n    \n    Code example:\n    \n        # SConstruct\n        env = Environment()\n        env.Program(target=\"HelloWorld\", source=[\"main.cpp\"])\n        \n    \n*   **Ninja**: A small and focused build system that takes a list of build targets specified in a human-readable text file and builds them as fast as possible.\n    \n    Code example:\n    \n        # build.ninja\n        rule cc\n          command = g++ -c $in -o $out\n        \n        rule link\n          command = g++ $in -o $out\n        \n        build main.o: cc main.cpp\n        build HelloWorld: link main.o\n          default HelloWorld\n        \n    \n\nThese are some of the popular build systems in C++, each with their own syntax and capabilities. While Make is widely used, CMake is a cross-platform build system that generates build files for other build systems like Make or Ninja. Autotools is suitable for creating portable software, SCons leverages Python for its build scripts, and Ninja focuses on fast build times.",
    "links": []
  },
  "ysnXvSHGBMMozBJyXpHl5": {
    "title": "CMAKE",
    "description": "CMake is a powerful cross-platform build system that generates build files, Makefiles, or workspaces for various platforms and compilers. Unlike the others build systems, CMake does not actually build the project, it only generates the files needed by build tools. CMake is widely used, particularly in C++ projects, for its ease of use and flexibility.\n\nCMakeLists.txt\n--------------\n\nCMake uses a file called `CMakeLists.txt` to define settings, source files, libraries, and other configurations. A typical `CMakeLists.txt` for a simple project would look like:\n\n    cmake_minimum_required(VERSION 3.0)\n    \n    project(MyProject)\n    \n    set(SRC_DIR \"${CMAKE_CURRENT_LIST_DIR}/src\")\n    set(SOURCES \"${SRC_DIR}/main.cpp\" \"${SRC_DIR}/file1.cpp\" \"${SRC_DIR}/file2.cpp\")\n    \n    add_executable(${PROJECT_NAME} ${SOURCES})\n    \n    target_include_directories(${PROJECT_NAME} PRIVATE \"${CMAKE_CURRENT_LIST_DIR}/include\")\n    \n    set_target_properties(${PROJECT_NAME} PROPERTIES\n        CXX_STANDARD 14\n        CXX_STANDARD_REQUIRED ON\n        CXX_EXTENSIONS OFF\n    )\n    \n\nBuilding with CMake\n-------------------\n\nHere is an example of a simple build process using CMake:\n\n*   Create a new directory for the build.\n\n    mkdir build\n    cd build\n    \n\n*   Generate build files using CMake.\n\n    cmake ..\n    \n\nIn this example, `..` indicates the parent directory where `CMakeLists.txt` is located. The build files will be generated in the `build` directory.\n\n*   Build the project using the generated build files.\n\n    make\n    \n\nOr, on Windows with Visual Studio, you may use:\n\n    msbuild MyProject.sln\n    \n\nCMake makes it easy to manage large projects, define custom build configurations, and work with many different compilers and operating systems. Making it a widely chosen tool for managing build systems in C++ projects.",
    "links": []
  },
  "t6rZLH7l8JQm99ax_fEJ9": {
    "title": "Makefile",
    "description": "A Makefile is a configuration file used by the `make` utility to automate the process of compiling and linking code in a C++ project. It consists of a set of rules and dependencies that help in building the target executable or library from source code files.\n\nMakefiles help developers save time, reduce errors, and ensure consistency in the build process. They achieve this by specifying the dependencies between different source files, and providing commands that generate output files (such as object files and executables) from input files (such as source code and headers).\n\nStructure of a Makefile\n-----------------------\n\nA typical Makefile has the following structure:\n\n*   **Variables**: Define variables to store commonly used values, such as compiler flags, directories, or target names.\n*   **Rules**: Define how to generate output files from input files using a set of commands. Each rule has a _target_, a set of _prerequisites_, and a _recipe_.\n*   **Phony targets**: Targets that do not represent actual files in the project but serve as a way to group related rules and invoke them using a single command.\n\nExample\n-------\n\nConsider a basic C++ project with the following directory structure:\n\n    project/\n    |-- include/\n    |   |-- header.h\n    |-- src/\n    |   |-- main.cpp\n    |-- Makefile\n    \n\nA simple Makefile for this project could be as follows:\n\n    # Variables\n    CXX = g++\n    CXXFLAGS = -Wall -Iinclude\n    SRC = src/main.cpp\n    OBJ = main.o\n    EXE = my_program\n    \n    # Rules\n    $(EXE): $(OBJ)\n    \t$(CXX) $(CXXFLAGS) -o $(EXE) $(OBJ)\n    \n    $(OBJ): $(SRC)\n    \t$(CXX) $(CXXFLAGS) -c $(SRC)\n    \n    # Phony targets\n    .PHONY: clean\n    clean:\n    \trm -f $(OBJ) $(EXE)\n    \n\nWith this Makefile, you can simply run `make` in the terminal to build the project, and `make clean` to remove the output files. The Makefile specifies the dependencies between the source code, object files, and the final executable, as well as the commands to compile and link them.\n\nSummary\n-------\n\nMakefiles provide a powerful way to automate building C++ projects using the `make` utility. They describe the dependencies and commands required to generate output files from source code, saving time and ensuring consistency in the build process.",
    "links": []
  },
  "HkUCD5A_M9bJxJRElkK0x": {
    "title": "Ninja",
    "description": "Ninja is a small build system with a focus on speed. It is designed to handle large projects by generating build files that implement the minimal amount of work necessary to build the code. This results in faster build times, especially for large codebases. Ninja is often used in conjunction with other build systems like CMake, which can generate Ninja build files for you.\n\nNinja build files are typically named `build.ninja` and contain rules, build statements, and variable declarations. Here's a simple example of a Ninja build file for a C++ project:\n\n    # Variable declarations\n    cxx = g++\n    cflags = -Wall -Wextra -std=c++17\n    \n    # Rule for compiling the C++ files\n    rule cxx_compile\n      command = $cxx $cflags -c $in -o $out\n    \n    # Build statements for the source files\n    build main.o: cxx_compile main.cpp\n    build foo.o: cxx_compile foo.cpp\n    \n    # Rule for linking the object files\n    rule link\n      command = $cxx $in -o $out\n    \n    # Build statement for the final executable\n    build my_program: link main.o foo.o\n    \n\nTo build the project using this `build.ninja` file, simply run `ninja` in the terminal:\n\n    $ ninja\n    \n\nThis will build the `my_program` executable by first compiling the `main.cpp` and `foo.cpp` files into object files, and then linking them together.",
    "links": []
  },
  "h29eJG1hWHa7vMhSqtfV2": {
    "title": "Package Managers",
    "description": "Package managers are tools that automate the process of installing, upgrading, and managing software (libraries, frameworks, and other dependencies) for a programming language, such as C++.\n\nSome popular package managers used in the C++ ecosystem include:\n\n*   **Conan**\n*   **vcpkg**\n*   **C++ Archive Network (cppan)**\n\nConan\n-----\n\n[Conan](https://conan.io/) is an open-source, decentralized, cross-platform package manager for C and C++ developers. It simplifies managing dependencies and reusing code, which benefits multi-platform development projects.\n\nFor example, installing a library using Conan:\n\n    conan install poco/1.9.4@\n    \n\nvcpkg\n-----\n\n[vcpkg](https://github.com/microsoft/vcpkg) is a cross-platform package manager created by Microsoft. It is an open-source library management system for C++ developers to build and manage their projects.\n\nFor example, installing a package using vcpkg:\n\n    ./vcpkg install boost:x64-windows\n    \n\nC++ Archive Network (cppan)\n---------------------------\n\n[cppan](https://cppan.org/) is a package manager and software repository for C++ developers, simplifying the process of managing and distributing C++ libraries and tools. It's now part of [build2](https://build2.org/), a build toolchain that provides a package manager.\n\nAn example of a `cppan.yml` file:\n\n    #\n    # cppan.yml\n    #\n    \n    project:\n      api_version: 1\n    \n      depend:\n        - pvt.cppan.demo.sqlite3\n        - pvt.cppan.demo.xz_utils.lzma\n    \n\nWith these package managers, you can streamline your development process and easily manage dependencies in your C++ projects. In addition, you can easily reuse the code in your projects to improve code quality and accelerate development.",
    "links": []
  },
  "PKG5pACLfRS2ogfzBX47_": {
    "title": "vcpkg",
    "description": "`vcpkg` is a cross-platform, open-source package manager for C and C++ libraries. Developed by Microsoft, it simplifies the process of acquiring and building open-source libraries for your projects. `vcpkg` supports various platforms including Windows, Linux, and macOS, enabling you to easily manage and integrate external libraries into your projects.\n\nInstallation\n------------\n\nTo install `vcpkg`, follow these steps:\n\n*   Clone the repository:\n    \n        git clone https://github.com/Microsoft/vcpkg.git\n        \n    \n*   Change to the `vcpkg` directory and run the bootstrap script:\n    \n    *   On Windows:\n        \n            .\\bootstrap-vcpkg.bat\n            \n        \n    *   On Linux/macOS:\n        \n            ./bootstrap-vcpkg.sh\n            \n        \n*   (Optional) Add the `vcpkg` executable to your `PATH` environment variable for easy access.\n    \n\nBasic usage\n-----------\n\nHere are some basic examples of using `vcpkg`:\n\n*   Search for a package:\n    \n        vcpkg search <package_name>\n        \n    \n*   Install a package:\n    \n        vcpkg install <package_name>\n        \n    \n*   Remove a package:\n    \n        vcpkg remove <package_name>\n        \n    \n*   List installed packages:\n    \n        vcpkg list\n        \n    \n*   Integrate `vcpkg` with Visual Studio (Windows only):\n    \n        vcpkg integrate install\n        \n    \n\nFor additional documentation and advanced usage, you can refer to the [official GitHub repository](https://github.com/microsoft/vcpkg).",
    "links": []
  },
  "g0s0F4mLV16eNvMBflN2e": {
    "title": "NuGet",
    "description": "[NuGet](https://www.nuget.org/) is a Microsoft-supported package manager for the .NET framework, mainly used in C# and other .NET languages, but also supports C++ projects with `PackageReference`. It allows you to easily add, update, and manage dependencies in your projects.\n\n### Installation\n\nYou can use NuGet either as a command-line tool or integrated in your preferred IDE like Visual Studio or Visual Studio Code. If you're using Visual Studio, it comes pre-installed. For other editors, you may need to download the command-line tool `nuget.exe`.\n\n### Usage\n\nYou can use NuGet to manage your C++ dependencies using the PackageReference format in vcxproj files:\n\n*   Tools > NuGet Package Manager > Manage NuGet Packages for Solution…\n*   Package source should be set to \"[nuget.org](http://nuget.org)\"\n*   Select the Projects tab\n*   Use the search box to find packages\n\nFor example, to install a package called \"PackageName\" for all configurations:\n\n    <Project>\n      <ItemGroup>\n        <PackageReference Include=\"PackageName\" Version=\"1.0.0\" />\n      </ItemGroup>\n      ...\n    </Project>\n    \n\n### NuGet Command-Line\n\nYou can also use the command-line tool `nuget.exe` for more advanced scenarios or for specific needs.\n\nHere's an example of installing a package using the command line:\n\n    nuget install PackageName\n    \n\nAnd updating a package:\n\n    nuget update PackageName\n    \n\nFor more information and detailed examples on using NuGet in your projects, please refer to the [official documentation](https://docs.microsoft.com/en-us/nuget/guides/native-packages).",
    "links": []
  },
  "ky_UqizToTZHC_b77qFi2": {
    "title": "Conan",
    "description": "[Conan](https://conan.io/) is a popular package manager for C and C++ languages and is designed to be cross-platform, extensible, and easy to use. It allows developers to declare, manage, and fetch dependencies while automating the build process. Conan supports various build systems, such as CMake, Visual Studio, MSBuild, and more.\n\nInstallation\n------------\n\nTo install Conan, you can use pip, the Python package manager:\n\n    pip install conan\n    \n\nBasic Usage\n-----------\n\n*   Create a `conanfile.txt` file in your project root directory, specifying dependencies you need for your project:\n\n    [requires]\n    boost/1.75.0\n    \n    [generators]\n    cmake\n    \n\n*   Run the `conan install` command to fetch and build required dependencies:\n\n    mkdir build && cd build\n    conan install ..\n    \n\n*   Now build your project using your build system, for example CMake:\n\n    cmake .. -DCMAKE_BUILD_TYPE=Release\n    cmake --build .\n    \n\nCreating Packages\n-----------------\n\nTo create a package in Conan, you need to write a `conanfile.py` file with package information and build instructions.\n\nHere's an example:\n\n    from conans import ConanFile, CMake\n    \n    \n    class MyLibraryConan(ConanFile):\n        name = \"MyLibrary\"\n        version = \"0.1\"\n        license = \"MIT\"\n        url = \"https://github.com/username/mylibrary\"\n        description = \"A simple example library\"\n        settings = \"os\", \"compiler\", \"build_type\", \"arch\"\n        generators = \"cmake\"\n    \n        def build(self):\n            cmake = CMake(self)\n            cmake.configure(source_folder=\"src\")\n            cmake.build()\n    \n        def package(self):\n            self.copy(\"*.hpp\", dst=\"include\", src=\"src/include\")\n            self.copy(\"*.lib\", dst=\"lib\", keep_path=False)\n            self.copy(\"*.dll\", dst=\"bin\", keep_path=False)\n            self.copy(\"*.so\", dst=\"lib\", keep_path=False)\n            self.copy(\"*.a\", dst=\"lib\", keep_path=False)\n    \n        def package_info(self):\n            self.cpp_info.libs = [\"MyLibrary\"]\n    \n\nWith that setup, you can create a package by running:\n\n    conan create . username/channel\n    \n\nThis will compile the package and store it in your Conan cache. You can now use this package as a dependency in other projects.",
    "links": []
  },
  "3ehBc2sKVlPj7dn4RVZCH": {
    "title": "Spack",
    "description": "[Spack](https://spack.io/) is a flexible package manager designed to support multiple versions, configurations, platforms, and compilers. It is particularly useful in High Performance Computing (HPC) environments and for those who require fine control over their software stack. Spack is a popular choice in scientific computing due to its support for various platforms such as Linux, macOS, and many supercomputers. It is designed to automatically search for and install dependencies, making it easy to build complex software.\n\nKey Features\n------------\n\n*   **Multi-Version Support**: Spack allows for the installation of multiple versions of packages, enabling users to work with different configurations depending on their needs.\n*   **Compiler Support**: Spack supports multiple compilers, including GCC, Clang, Intel, PGI, and others, allowing users to choose the best toolchain for their application.\n*   **Platform Support**: Spack can run on Linux, macOS, and various supercomputers, and it can even target multiple architectures within a single package.\n*   **Dependencies**: Spack takes care of dependencies, providing automatic installation and management of required packages.\n\nBasic Usage\n-----------\n\n*   To install Spack, clone its Git repository and set up your environment:\n    \n        git clone https://github.com/spack/spack.git\n        cd spack\n        . share/spack/setup-env.sh\n        \n    \n*   Install a package using Spack:\n    \n        spack install <package-name>\n        \n    \n    For example, to install `hdf5`:\n    \n        spack install hdf5\n        \n    \n*   Load a package in your environment:\n    \n        spack load <package-name>\n        \n    \n    For example, to load `hdf5`:\n    \n        spack load hdf5\n        \n    \n*   List installed packages:\n    \n        spack find\n        \n    \n*   Uninstall a package:\n    \n        spack uninstall <package-name>\n        \n    \n\nFor more advanced usage, like installing specific versions or using different compilers, consult the [Spack documentation](https://spack.readthedocs.io/).",
    "links": []
  },
  "4kkX5g_-plX9zVqr0ZoiR": {
    "title": "Working with Libraries",
    "description": "When working with C++, you may need to use external libraries to assist in various tasks. Libraries are precompiled pieces of code that can be reused in your program to perform a specific task or provide a certain functionality. In C++, libraries can be either static libraries (.lib) or dynamic libraries (.dll in Windows, .so in Unix/Linux).\n\n**1\\. Static Libraries**\n\nStatic libraries are incorporated into your program during compile time. They are linked with your code, creating a larger executable file, but it does not require any external files during runtime.\n\nTo create a static library, you'll need to compile your source files into object files, then bundle them into an archive. You can use the following commands:\n\n    g++ -c sourcefile.cpp -o objectfile.o\n    ar rcs libmystaticlibrary.a objectfile.o\n    \n\nTo use a static library, you need to include the header files in your source code and then link the library during the compilation process:\n\n    g++ main.cpp -o myprogram -L/path/to/your/library/ -lmystaticlibrary\n    \n\nReplace `/path/to/your/library/` with the path where your `libmystaticlibrary.a` file is located.\n\n**2\\. Dynamic Libraries**\n\nDynamic libraries are loaded during runtime, which means that your executable file only contains references to these libraries. The libraries need to be available on the system where your program is running.\n\nTo create a dynamic library, you'll need to compile your source files into object files, then create a shared library:\n\n    g++ -c -fPIC sourcefile.cpp -o objectfile.o\n    g++ -shared -o libmydynamiclibrary.so objectfile.o\n    \n\nTo use a dynamic library, include the library's header files in your source code and then link the library during the compilation process:\n\n    g++ main.cpp -o myprogram -L/path/to/your/library/ -lmydynamiclibrary\n    \n\nReplace `/path/to/your/library/` with the path where your `libmydynamiclibrary.so` file is located.\n\n**NOTE:** When using dynamic libraries, make sure the library is in the system's search path for shared libraries. You may need to update the `LD_LIBRARY_PATH` environment variable on Unix/Linux systems or the `PATH` variable on Windows.\n\nIn conclusion, using libraries in C++ involves creating or obtaining a library (static or dynamic), including the library's header files in your source code, and linking the library during the compilation process. Be aware of the differences between static and dynamic libraries, and choose the right approach to suit your needs.",
    "links": []
  },
  "5mNqH_AEiLxUmgurNW1Fq": {
    "title": "Library Inclusion",
    "description": "In C++ programming, inclusion refers to incorporating external libraries, header files, or other code files into your program. This process allows developers to access pre-built functions, classes, and variable declarations that can be used in their own code. There are two types of inclusion in C++:\n\n*   Header Inclusion\n*   Source Inclusion\n\n### Header Inclusion\n\nHeader inclusion involves including header files using the preprocessor directive `#include`. Header files are typically used to provide function prototypes, class declarations, and constant definitions that can be shared across multiple source files. There are two ways to include header files in your program:\n\n*   Angle brackets `<>`: Used for including standard library headers, like `iostream`, `vector`, or `algorithm`.\n\nExample:\n\n    #include <iostream>\n    #include <vector>\n    \n\n*   Double quotes `\"\"`: Used for including user-defined headers or headers provided by third-party libraries.\n\nExample:\n\n    #include \"myHeader.h\"\n    #include \"thirdPartyLibrary.h\"\n    \n\n### Source Inclusion\n\nSource inclusion refers to including the content of a source file directly in another source file. This approach is generally not recommended as it can lead to multiple definitions and increased compile times but it can occasionally be useful for certain tasks (e.g., templates or simple small programs). To include a source file, you can use the `#include` directive with double quotes, just like with header files:\n\nExample:\n\n    #include \"mySourceFile.cpp\"\n    \n\nRemember, using source inclusion for large projects or in situations where it's not necessary can lead to unexpected issues and should be avoided.",
    "links": []
  },
  "sLVs95EOeHZldoKY0L_dH": {
    "title": "Licensing",
    "description": "Licensing is a crucial aspect of working with libraries in C++ because it determines the rights and limitations on how you can use, modify, and distribute a given library. There are various types of licenses applied to open-source libraries. Below is a brief overview of three common licenses:\n\nMIT License\n-----------\n\nThe MIT License is a permissive license that allows users to do whatever they want with the software code. They only need to include the original copyright, license notice, and a disclaimer of warranty in their copies.\n\nExample: Including the MIT License into your project can be done by simply adding the license file and a notice at the top of your source code files like:\n\n    /* Copyright (C) [year] [author]\n     * SPDX-License-Identifier:    MIT\n     */\n    \n\nGNU General Public License (GPL)\n--------------------------------\n\nThe GPL is a copyleft license that grants users the rights to use, study, share, and modify the software code. However, any changes made to the code or any software that uses GPL licensed code must also be distributed under the GPL license.\n\nExample: To include a GPL license in your project, include a `COPYING` file with the full text of the license and place a notice in your source code files like:\n\n    /* Copyright (C) [year] [author]\n     * SPDX-License-Identifier:    GPL-3.0-or-later\n     */\n    \n\nApache License 2.0\n------------------\n\nThe Apache License is a permissive license similar to the MIT license and allows users to do virtually anything with the software code. The primary difference is that it requires that any changes to the code are documented, and it provides specific terms for patent protection.\n\nExample: To include the Apache License in your project, add a `LICENSE` file with the full text of the license. Add a notice to your source code files like:\n\n    /* Copyright (C) [year] [author]\n     * SPDX-License-Identifier:    Apache-2.0\n     */\n    \n\nPlease note that these are brief summaries of the licenses, and there are many other licenses available for use in software projects. When using third-party libraries, it is crucial to understand and adhere to the terms of their respective licenses to avoid legal complications.",
    "links": []
  },
  "1d7h5P1Q0RVHryKPVogQy": {
    "title": "Boost",
    "description": "",
    "links": []
  },
  "Eq3TKSFJ2F2mrTHAaU2J4": {
    "title": "OpenCV",
    "description": "",
    "links": []
  },
  "nOkniNXfXwPPlOEJHJoGl": {
    "title": "POCO",
    "description": "",
    "links": []
  },
  "jpMCIWQko7p3ndezYHL4D": {
    "title": "protobuf",
    "description": "",
    "links": []
  },
  "621J9W4xCofumNZGo4TZT": {
    "title": "gRPC",
    "description": "",
    "links": []
  },
  "j_eNHhs0J08Dt7HVbo4Q2": {
    "title": "Tensorflow",
    "description": "",
    "links": []
  },
  "tEkvlJPAkD5fji-MMODL7": {
    "title": "pybind11",
    "description": "",
    "links": []
  },
  "q64qFxoCrR38RPsN2lC8x": {
    "title": "spdlog",
    "description": "",
    "links": []
  },
  "GGZJaYpRENaqloJzt0VtY": {
    "title": "opencl",
    "description": "",
    "links": []
  },
  "1CqQgmHDeo1HlPdpUJS7H": {
    "title": "fmt",
    "description": "",
    "links": []
  },
  "et-dXKPYuyVW6eV2K3CM8": {
    "title": "ranges_v3",
    "description": "",
    "links": []
  },
  "MrAM-viRaF8DSxB6sVdD9": {
    "title": "gtest / gmock",
    "description": "",
    "links": []
  },
  "gAZ9Dqgj1_UkaLzVgzx1t": {
    "title": "Qt",
    "description": "",
    "links": []
  },
  "s13jQuaC6gw0Lab3Cbyy6": {
    "title": "Catch2",
    "description": "",
    "links": []
  },
  "O0lVEMTAV1pq9sYCKQvh_": {
    "title": "Orbit Profiler",
    "description": "",
    "links": []
  },
  "88pr5aN7cctZfDVVo-2ns": {
    "title": "PyTorch C++",
    "description": "",
    "links": []
  }

}